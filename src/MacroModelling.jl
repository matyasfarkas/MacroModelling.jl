module MacroModelling


import DocStringExtensions: FIELDS, SIGNATURES, TYPEDEF, TYPEDSIGNATURES, TYPEDFIELDS
# import StatsFuns: normcdf
# import ThreadedSparseArrays
using PrecompileTools
import SpecialFunctions: erfcinv, erfc
import SymPyPythonCall as SPyPyC
import Symbolics
import ForwardDiff as ‚Ñ± 
import JuMP
import MadNLP, NLopt # MadNLP doesnt support noninear constraints # StatusSwitchingQP not reliable
# import Zygote
import SparseArrays: SparseMatrixCSC, SparseVector, AbstractSparseArray#, sparse, spzeros, droptol!, sparsevec, spdiagm, findnz#, sparse!
import LinearAlgebra as ‚Ñí
# import ComponentArrays as ùíû
import BlockTriangularForm
import Subscripts: super, sub
import Krylov
import LinearOperators
import DataStructures: CircularBuffer
import ImplicitDifferentiation as ID
import AbstractDifferentiation as AD
import SpeedMapping: speedmapping
import REPL
import Unicode
import MatrixEquations # good overview: https://cscproxy.mpi-magdeburg.mpg.de/mpcsc/benner/talks/Benner-Melbourne2019.pdf
# import NLboxsolve: nlboxsolve
# using NamedArrays
# using AxisKeys

import ChainRulesCore: @ignore_derivatives, ignore_derivatives
import RecursiveFactorization as RF

using RuntimeGeneratedFunctions
RuntimeGeneratedFunctions.init(@__MODULE__)

using Requires

import Reexport
Reexport.@reexport using AxisKeys
Reexport.@reexport import SparseArrays: sparse, spzeros, droptol!, sparsevec, spdiagm, findnz


# Type definitions
Symbol_input = Union{Symbol,Vector{Symbol},Matrix{Symbol},Tuple{Symbol,Vararg{Symbol}}}
String_input = Union{String,Vector{String},Matrix{String},Tuple{String,Vararg{String}}}

# Imports
include("common_docstrings.jl")
include("structures.jl")
include("macros.jl")
include("get_functions.jl")
include("dynare.jl")
include("inspect.jl")

function __init__()
    @require StatsPlots = "f3b207a7-027a-5e70-b257-86293d7955fd" include("plotting.jl")
    @require Turing = "fce5fe82-541a-59a6-adf8-730c64b5f9a0" include("priors.jl")
end


export @model, @parameters, solve!
export plot_irfs, plot_irf, plot_IRF, plot_simulations, plot_solution, plot_simulation#, plot
export plot_conditional_variance_decomposition, plot_forecast_error_variance_decomposition, plot_fevd, plot_model_estimates, plot_shock_decomposition
export get_irfs, get_irf, get_IRF, simulate, get_simulation, get_simulations
export get_conditional_forecast, plot_conditional_forecast
export get_solution, get_first_order_solution, get_perturbation_solution, get_second_order_solution, get_third_order_solution
export get_steady_state, get_SS, get_ss, get_non_stochastic_steady_state, get_stochastic_steady_state, get_SSS, steady_state, SS, SSS, ss, sss
export get_moments, get_statistics, get_covariance, get_standard_deviation, get_variance, get_var, get_std, get_cov, var, std, cov, get_mean#, mean
export get_autocorrelation, get_correlation, get_variance_decomposition, get_corr, get_autocorr, get_var_decomp, corr, autocorr
export get_fevd, fevd, get_forecast_error_variance_decomposition, get_conditional_variance_decomposition
export calculate_jacobian, calculate_hessian, calculate_third_order_derivatives
export calculate_first_order_solution, calculate_second_order_solution, calculate_third_order_solution#, calculate_jacobian_manual, calculate_jacobian_sparse, calculate_jacobian_threaded
export calculate_kalman_filter_loglikelihood, get_shock_decomposition, get_estimated_shocks, get_estimated_variables, get_estimated_variable_standard_deviations
export plotlyjs_backend, gr_backend
export Beta, InverseGamma, Gamma, Normal

export translate_mod_file, translate_dynare_file, import_model, import_dynare
export write_mod_file, write_dynare_file, write_to_dynare_file, write_to_dynare, export_dynare, export_to_dynare, export_mod_file, export_model

export get_equations, get_steady_state_equations, get_dynamic_equations, get_calibration_equations, get_parameters, get_calibrated_parameters, get_parameters_in_equations, get_parameters_defined_by_parameters, get_parameters_defining_parameters, get_calibration_equation_parameters, get_variables, get_nonnegativity_auxilliary_variables, get_dynamic_auxilliary_variables, get_shocks, get_state_variables, get_jump_variables
# Internal
export irf, girf

# Remove comment for debugging
export riccati_forward, block_solver, remove_redundant_SS_vars!, write_parameters_input!, parse_variables_input_to_index, undo_transformer , transformer, SSS_third_order_parameter_derivatives, SSS_second_order_parameter_derivatives, calculate_third_order_stochastic_steady_state, calculate_second_order_stochastic_steady_state, filter_and_smooth
export create_symbols_eqs!, solve_steady_state!, write_functions_mapping!, solve!, parse_algorithm_to_state_update, block_solver, block_solver_AD, calculate_covariance, calculate_jacobian, calculate_first_order_solution, expand_steady_state, calculate_quadratic_iteration_solution, calculate_linear_time_iteration_solution, get_symbols, calculate_covariance_AD, parse_shocks_input_to_index


# StatsFuns
norminvcdf(p) = -erfcinv(2*p) * 1.4142135623730951
norminv(p::Number) = norminvcdf(p)
qnorm(p::Number) = norminvcdf(p)
normlogpdf(z) = -(abs2(z) + 1.8378770664093453)/2
normpdf(z) = exp(-abs2(z)/2) * 0.3989422804014327
normcdf(z) = erfc(-z * 0.7071067811865475)/2
pnorm(p::Number) = normcdf(p)
dnorm(p::Number) = normpdf(p)




Base.show(io::IO, ùìÇ::‚Ñ≥) = println(io, 
                "Model:        ", ùìÇ.model_name, 
                "\nVariables", 
                "\n Total:       ", ùìÇ.timings.nVars,
                "\n  Auxiliary:  ", length(ùìÇ.exo_present) + length(ùìÇ.aux),
                "\n States:      ", ùìÇ.timings.nPast_not_future_and_mixed,
                "\n  Auxiliary:  ",  length(intersect(ùìÇ.timings.past_not_future_and_mixed, ùìÇ.aux_present)),
                "\n Jumpers:     ", ùìÇ.timings.nFuture_not_past_and_mixed, # ùìÇ.timings.mixed, 
                "\n  Auxiliary:  ", length(intersect(ùìÇ.timings.future_not_past_and_mixed, union(ùìÇ.aux_present, ùìÇ.aux_future))),
                "\nShocks:       ", ùìÇ.timings.nExo,
                "\nParameters:   ", length(ùìÇ.parameters_in_equations),
                if ùìÇ.calibration_equations == Expr[]
                    ""
                else
                    "\nCalibration\nequations:    " * repr(length(ùìÇ.calibration_equations))
                end,
                # "\n¬π: including auxilliary variables"
                # "\nVariable bounds (upper,lower,any): ",sum(ùìÇ.upper_bounds .< Inf),", ",sum(ùìÇ.lower_bounds .> -Inf),", ",length(ùìÇ.bounds),
                # "\nNon-stochastic-steady-state found: ",!ùìÇ.solution.outdated_NSSS
                )

check_for_dynamic_variables(ex::Int) = false
check_for_dynamic_variables(ex::Float64) = false
check_for_dynamic_variables(ex::Symbol) = occursin(r"‚Çç‚ÇÅ‚Çé|‚Çç‚ÇÄ‚Çé|‚Çç‚Çã‚ÇÅ‚Çé",string(ex))

function check_for_dynamic_variables(ex::Expr)
    dynamic_indicator = Bool[]

    postwalk(x -> 
        x isa Expr ?
            x.head == :ref ? 
                occursin(r"^(ss|stst|steady|steadystate|steady_state){1}$"i,string(x.args[2])) ?
                    x :
                begin
                    push!(dynamic_indicator,true)
                    x
                end :
            x :
        x,
    ex)

    any(dynamic_indicator)
end


function transform_expression(expr::Expr)
    # Dictionary to store the transformations for reversing
    reverse_transformations = Dict{Symbol, Expr}()

    # Counter for generating unique placeholders
    unique_counter = Ref(0)

    # Step 1: Replace min/max calls and record their original form
    function replace_min_max(expr)
        if expr isa Expr && expr.head == :call && (expr.args[1] == :min || expr.args[1] == :max)
            # Replace min/max functions with a placeholder
            # placeholder = Symbol("minimal__P", unique_counter[])
            placeholder = :minmax__P
            unique_counter[] += 1

            # Store the original min/max call for reversal
            reverse_transformations[placeholder] = expr

            return placeholder
        else
            return expr
        end
    end

    # Step 2: Transform :ref fields in the rest of the expression
    function transform_ref_fields(expr)
        if expr isa Expr && expr.head == :ref && isa(expr.args[1], Symbol)
            # Handle :ref expressions
            if isa(expr.args[2], Number) || isa(expr.args[2], Symbol)
                new_symbol = Symbol(expr.args[1], "_", expr.args[2])
            else
                # Generate a unique placeholder for complex :ref
                unique_counter[] += 1
                placeholder = Symbol("__placeholder", unique_counter[])
                new_symbol = placeholder
            end

            # Record the reverse transformation
            reverse_transformations[new_symbol] = expr

            return new_symbol
        else
            return expr
        end
    end


    # Replace equality sign with minus
    function replace_equality_with_minus(expr)
        if expr isa Expr && expr.head == :(=)
            return Expr(:call, :-, expr.args...)
        else
            return expr
        end
    end

    # Apply transformations
    expr = postwalk(replace_min_max, expr)
    expr = postwalk(transform_ref_fields, expr)
    transformed_expr = postwalk(replace_equality_with_minus, expr)
    
    return transformed_expr, reverse_transformations
end


function reverse_transformation(transformed_expr::Expr, reverse_dict::Dict{Symbol, Expr})
    # Function to replace the transformed symbols with their original form
    function revert_symbol(expr)
        if expr isa Symbol && haskey(reverse_dict, expr)
            return reverse_dict[expr]
        else
            return expr
        end
    end

    # Revert the expression using postwalk
    reverted_expr = postwalk(revert_symbol, transformed_expr)

    return reverted_expr
end


function transform_obc(ex::Expr)
    transformed_expr, reverse_dict = transform_expression(ex)

    for symbs in get_symbols(transformed_expr)
        eval(:($symbs = SPyPyC.symbols($(string(symbs)), real = true, finite = true)))
    end

    eq = eval(transformed_expr)

    soll = try SPyPyC.solve(eq, eval(:minmax__P))
    catch
    end

    if length(soll) == 1
        sorted_minmax = Expr(:call, reverse_dict[:minmax__P].args[1], :($(reverse_dict[:minmax__P].args[2]) - $(Meta.parse(string(soll[1])))),  :($(reverse_dict[:minmax__P].args[3]) - $(Meta.parse(string(soll[1])))))
        return reverse_transformation(sorted_minmax, reverse_dict)
    else
        @error "Occasionally binding constraint not well-defined. See documentation for examples."
    end
end



function set_up_obc_violation_function!(ùìÇ)
    present_varss = collect(reduce(union,match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚ÇÄ‚Çé$")))

    sort!(present_varss ,by = x->replace(string(x),r"‚Çç‚ÇÄ‚Çé$"=>""))

    # write indices in auxiliary objects
    dyn_var_present_list = map(x->Set{Symbol}(map(x->Symbol(replace(string(x),"‚Çç‚ÇÄ‚Çé" => "")),x)),collect.(match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚ÇÄ‚Çé")))

    dyn_var_present = Symbol.(replace.(string.(sort(collect(reduce(union,dyn_var_present_list)))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))

    SS_and_pars_names = vcat(Symbol.(replace.(string.(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")), ùìÇ.calibration_equations_parameters)

    dyn_var_present_idx = indexin(dyn_var_present   , SS_and_pars_names)

    alll = []
    for (i,var) in enumerate(present_varss)
        if !(match(r"^œá·µí·µá·∂ú", string(var)) === nothing)
            push!(alll,:($var = Y[$(dyn_var_present_idx[i]),1:end-1]))
        end
    end

    calc_obc_violation = :(function calculate_obc_violation(x::Vector, 
                                                                initial_state,
                                                                state_update, 
                                                                reference_steady_state, 
                                                                ùìÇ, 
                                                                algorithm,
                                                                periods, 
                                                                shock_values)
        T = ùìÇ.timings

        # if algorithm ‚àà [:first_order, :riccati, :linear_time_iteration, :quadratic_iteration]
        #     Ytype = JuMP.AffExpr
        # elseif algorithm ‚àà [:pruned_second_order, :second_order]
        #     Ytype = JuMP.QuadExpr
        # elseif algorithm ‚àà [:pruned_third_order, :third_order]
        #     Ytype = JuMP.NonlinearExpr
        # end

        # Y = zeros(Ytype, T.nVars, periods+2)

        Y = zeros(JuMP.AffExpr, T.nVars, periods+1)

        shock_values[contains.(string.(T.exo),"·µí·µá·∂ú")] .= x

        zero_shock = zero(shock_values)

        Y[:,1] = state_update(initial_state, shock_values)

        for t in 1:periods
            Y[:,t+1] = state_update(Y[:,t], zero_shock)
        end

        Y .+= reference_steady_state[1:T.nVars]

        $(alll...)

        constraint_values = Vector[]
        # shock_sign_indicators = Bool[]

        $(ùìÇ.obc_violation_equations...)

        return vcat(constraint_values...)#, shock_sign_indicators
    end)

    ùìÇ.obc_violation_function = @RuntimeGeneratedFunction(calc_obc_violation)

    return nothing
end


function check_for_minmax(expr)
    contains_minmax = Bool[]

    postwalk(x -> 
                x isa Expr ?
                    x.head == :call ? 
                        x.args[1] ‚àà [:max,:min] ?
                            begin
                                push!(contains_minmax,true)
                                x
                            end :
                        x :
                    x :
                x,
    expr)

    any(contains_minmax)
end


function write_obc_violation_equations(ùìÇ)
    eqs = Expr[]
    for (i,eq) in enumerate(ùìÇ.dyn_equations)
        if check_for_minmax(eq)
            minmax_fixed_eqs = postwalk(x -> 
                x isa Expr ?
                    x.head == :call ? 
                        length(x.args) == 3 ?
                            x.args[3] isa Expr ?
                                x.args[3].args[1] ‚àà [:Min, :min, :Max, :max] ?
                                    begin
                                        plchldr = Symbol(replace(string(x.args[2]), "‚Çç‚ÇÄ‚Çé" => ""))

                                        ineq_plchldr_1 = x.args[3].args[2] isa Symbol ? Symbol(replace(string(x.args[3].args[2]), "‚Çç‚ÇÄ‚Çé" => "")) : x.args[3].args[2]

                                        arg1 = x.args[3].args[2]
                                        arg2 = x.args[3].args[3]

                                        dyn_1 = check_for_dynamic_variables(x.args[3].args[2])
                                        dyn_2 = check_for_dynamic_variables(x.args[3].args[3])

                                        cond1 = Expr[]
                                        cond2 = Expr[]

                                        maximisation = contains(string(plchldr), "‚Å∫")
                                        
                                        # if dyn_1
                                        #     if maximisation
                                        #         push!(cond1, :(push!(constraint_values, $(x.args[3].args[2]))))
                                        #         # push!(cond2, :(push!(constraint_values, $(x.args[3].args[2]))))
                                        #     else
                                        #         push!(cond1, :(push!(constraint_values, -$(x.args[3].args[2]))))
                                        #         # push!(cond2, :(push!(constraint_values, -$(x.args[3].args[2])))) # RBC
                                        #     end
                                        # end

                                        # if dyn_2
                                        #     if maximisation
                                        #         push!(cond1, :(push!(constraint_values, $(x.args[3].args[3]))))
                                        #         # push!(cond2, :(push!(constraint_values, $(x.args[3].args[3])))) # testmax
                                        #     else
                                        #         push!(cond1, :(push!(constraint_values, -$(x.args[3].args[3]))))
                                        #         # push!(cond2, :(push!(constraint_values, -$(x.args[3].args[3])))) # RBC
                                        #     end
                                        # end


                                        if maximisation
                                            push!(cond1, :(push!(constraint_values, [sum($(x.args[3].args[2]) .* $(x.args[3].args[3]))])))
                                            push!(cond1, :(push!(constraint_values, $(x.args[3].args[2]))))
                                            push!(cond1, :(push!(constraint_values, $(x.args[3].args[3]))))
                                            # push!(cond1, :(push!(constraint_values, max.($(x.args[3].args[2]), $(x.args[3].args[3])))))
                                        else
                                            push!(cond1, :(push!(constraint_values, [sum($(x.args[3].args[2]) .* $(x.args[3].args[3]))])))
                                            push!(cond1, :(push!(constraint_values, -$(x.args[3].args[2]))))
                                            push!(cond1, :(push!(constraint_values, -$(x.args[3].args[3]))))
                                            # push!(cond1, :(push!(constraint_values, min.($(x.args[3].args[2]), $(x.args[3].args[3])))))
                                        end

                                        # if maximisation
                                        #     push!(cond1, :(push!(shock_sign_indicators, true)))
                                        #     # push!(cond2, :(push!(shock_sign_indicators, true)))
                                        # else
                                        #     push!(cond1, :(push!(shock_sign_indicators, false)))
                                        #     # push!(cond2, :(push!(shock_sign_indicators, false)))
                                        # end

                                        # :(if isapprox($plchldr, $ineq_plchldr_1, atol = 1e-12)
                                        #     $(Expr(:block, cond1...))
                                        # else
                                        #     $(Expr(:block, cond2...))
                                        # end)
                                        :($(Expr(:block, cond1...)))
                                    end :
                                x :
                            x :
                        x :
                    x :
                x,
            eq)

            push!(eqs, minmax_fixed_eqs)
        end
    end

    return eqs
end

# function parse_obc_shock_bounds(expr::Expr)
#     # Determine the order of the shock and bound in the expression
#     shock_first = isa(expr.args[2], Symbol)
    
#     # Extract the shock and bound from the expression
#     shock = shock_first ? expr.args[2] : expr.args[3]
#     bound_expr = shock_first ? expr.args[3] : expr.args[2]
    
#     # Evaluate the bound expression to get a numerical value
#     bound = eval(bound_expr) |> Float64
    
#     # Determine whether the bound is a lower or upper bound based on the comparison operator and order
#     is_upper_bound = (expr.args[1] in (:<, :‚â§) && shock_first) || (expr.args[1] in (:>, :‚â•) && !shock_first)
    
#     return shock, is_upper_bound, bound
# end



function mat_mult_kron(A::AbstractArray{T},B::AbstractArray{T},C::AbstractArray{T}; tol::AbstractFloat = eps()) where T <: Real
    n_rowB = size(B,1)
    n_colB = size(B,2)

    n_rowC = size(C,1)
    n_colC = size(C,2)

    BÃÑ = collect(B)
    CÃÑ = collect(C)

    vals = T[]
    rows = Int[]
    cols = Int[]

    for row in 1:size(A,1)
        idx_mat, vals_mat = A[row,:] |> findnz

        if length(vals_mat) == 0 continue end

        for col in 1:(n_colB*n_colC)
            col_1, col_2 = divrem((col - 1) % (n_colB*n_colC), n_colC) .+ 1

            mult_val = 0.0

            for (i,idx) in enumerate(idx_mat)
                i_1, i_2 = divrem((idx - 1) % (n_rowB*n_rowC), n_rowC) .+ 1
                
                mult_val += vals_mat[i] * BÃÑ[i_1,col_1] * CÃÑ[i_2,col_2]
            end

            if abs(mult_val) > tol
                push!(vals,mult_val)
                push!(rows,row)
                push!(cols,col)
            end
        end
    end

    sparse(rows,cols,vals,size(A,1),n_colB*n_colC)
end


function A_mult_kron_power_3_B(A::AbstractArray{R},B::AbstractArray{T}; tol::AbstractFloat = eps()) where {R <: Real, T <: Real}
    n_row = size(B,1)
    n_col = size(B,2)

    BÃÑ = collect(B)

    vals = T[]
    rows = Int[]
    cols = Int[]

    for row in 1:size(A,1)
        idx_mat, vals_mat = A[row,:] |> findnz

        if length(vals_mat) == 0 continue end

        for col in 1:size(B,2)^3
            col_1, col_3 = divrem((col - 1) % (n_col^2), n_col) .+ 1
            col_2 = ((col - 1) √∑ (n_col^2)) + 1

            mult_val = 0.0

            for (i,idx) in enumerate(idx_mat)
                i_1, i_3 = divrem((idx - 1) % (n_row^2), n_row) .+ 1
                i_2 = ((idx - 1) √∑ (n_row^2)) + 1
                mult_val += vals_mat[i] * BÃÑ[i_1,col_1] * BÃÑ[i_2,col_2] * BÃÑ[i_3,col_3]
            end

            if abs(mult_val) > tol
                push!(vals,mult_val)
                push!(rows,row)
                push!(cols,col)
            end
        end
    end

    sparse(rows,cols,vals,size(A,1),size(B,2)^3)
end


function translate_symbol_to_ascii(x::Symbol)
    ss = Unicode.normalize(replace(string(x),  "‚óñ" => "__", "‚óó" => "__"), :NFD)

    outstr = ""

    for i in ss
        out = REPL.symbol_latex(string(i))[2:end]
        if out == ""
            outstr *= string(i)
        else
            outstr *= replace(out,  
                        r"\^" => s"_",
                        r"\_\^" => s"_",
                        r"\+" => s"plus",
                        r"\-" => s"minus",
                        r"\*" => s"times")
            if i != ss[end]
                outstr *= "_"
            end
        end
    end

    return outstr
end


function translate_expression_to_ascii(exp::Expr)
    postwalk(x -> 
                x isa Symbol ?
                    begin
                        x_tmp = translate_symbol_to_ascii(x)

                        if x_tmp == string(x)
                            x
                        else
                            Symbol(x_tmp)
                        end
                    end :
                x,
    exp)
end
                


function jacobian_wrt_values(A, B)
    # does this without creating dense arrays: reshape(permutedims(reshape(‚Ñí.I - ‚Ñí.kron(A, B) ,size(B,1), size(A,1), size(A,1), size(B,1)), [2, 3, 4, 1]), size(A,1) * size(B,1), size(A,1) * size(B,1))

    # Compute the Kronecker product and subtract from identity
    C = ‚Ñí.I - ‚Ñí.kron(A, B)

    # Extract the row, column, and value indices from C
    rows, cols, vals = findnz(C)

    # Lists to store the 2D indices after the operations
    final_rows = zeros(Int,length(rows))
    final_cols = zeros(Int,length(rows))

    Threads.@threads for i = 1:length(rows)
        # Convert the 1D row index to its 2D components
        i1, i2 = divrem(rows[i]-1, size(B,1)) .+ 1

        # Convert the 1D column index to its 2D components
        j1, j2 = divrem(cols[i]-1, size(A,1)) .+ 1

        # Convert the 4D index (i1, j2, j1, i2) to a 2D index in the final matrix
        final_col, final_row = divrem(Base._sub2ind((size(A,1), size(A,1), size(B,1), size(B,1)), i1, j2, j1, i2) - 1, size(A,1) * size(B,1)) .+ 1

        # Store the 2D indices
        final_rows[i] = final_row
        final_cols[i] = final_col
    end

    return sparse(final_rows, final_cols, vals, size(A,1) * size(B,1), size(A,1) * size(B,1))
end




function jacobian_wrt_A(A, X)
    # does this without creating dense arrays: reshape(permutedims(reshape(‚Ñí.I - ‚Ñí.kron(A, B) ,size(B,1), size(A,1), size(A,1), size(B,1)), [2, 3, 4, 1]), size(A,1) * size(B,1), size(A,1) * size(B,1))

    # Compute the Kronecker product and subtract from identity
    C = ‚Ñí.kron(‚Ñí.I(size(A,1)), sparse(A * X))

    # Extract the row, column, and value indices from C
    rows, cols, vals = findnz(C)

    # Lists to store the 2D indices after the operations
    final_rows = zeros(Int,length(rows))
    final_cols = zeros(Int,length(rows))

    Threads.@threads for i = 1:length(rows)
        # Convert the 1D row index to its 2D components
        i1, i2 = divrem(rows[i]-1, size(A,1)) .+ 1

        # Convert the 1D column index to its 2D components
        j1, j2 = divrem(cols[i]-1, size(A,1)) .+ 1

        # Convert the 4D index (i1, j2, j1, i2) to a 2D index in the final matrix
        final_col, final_row = divrem(Base._sub2ind((size(A,1), size(A,1), size(A,1), size(A,1)), i2, i1, j1, j2) - 1, size(A,1) * size(A,1)) .+ 1

        # Store the 2D indices
        final_rows[i] = final_row
        final_cols[i] = final_col
    end

    r,c,_ = findnz(A) 
    
    non_zeros_only = spzeros(Int,size(A,1)^2,size(A,1)^2)
    
    non_zeros_only[CartesianIndex.(r .+ (c.-1) * size(A,1), r .+ (c.-1) * size(A,1))] .= 1
    
    return sparse(final_rows, final_cols, vals, size(A,1) * size(A,1), size(A,1) * size(A,1)) + ‚Ñí.kron(sparse(X * A'), ‚Ñí.I(size(A,1)))' * non_zeros_only
end


# # higher order solutions moment helper functions

# function warshall_algorithm!(R::SparseMatrixCSC{Bool,Int64})
#     # Size of the matrix
#     n, m = size(R)
    
#     @assert n == m "Warshall algorithm only works for square matrices."

#     # The core idea of the Warshall algorithm is to consider each node (in this case, block)
#     # as an intermediate node and check if a path can be created between two nodes by using the
#     # intermediate node.
    
#     # k is the intermediate node (or block).
#     for k in 1:n
#         # i is the starting node (or block).
#         for i in 1:n
#             # j is the ending node (or block).
#             for j in 1:n
#                 # If there is a direct path from i to k AND a direct path from k to j, 
#                 # then a path from i to j exists via k.
#                 # Thus, set the value of R[i, j] to 1 (true).
#                 R[i, j] = R[i, j] || (R[i, k] && R[k, j])
#             end
#         end
#     end
    
#     # Return the transitive closure matrix.
#     return R
# end

function combine_pairs(v::Vector{Pair{Vector{Symbol}, Vector{Symbol}}})
    i = 1
    while i <= length(v)
        subset_found = false
        for j in i+1:length(v)
            # Check if v[i].second is subset of v[j].second or vice versa
            if all(elem -> elem in v[j].second, v[i].second) || all(elem -> elem in v[i].second, v[j].second)
                # Combine the first elements and assign to the one with the larger second element
                if length(v[i].second) > length(v[j].second)
                    v[i] = v[i].first ‚à™ v[j].first => v[i].second
                else
                    v[j] = v[i].first ‚à™ v[j].first => v[j].second
                end
                # Remove the one with the smaller second element
                deleteat!(v, length(v[i].second) > length(v[j].second) ? j : i)
                subset_found = true
                break
            end
        end
        # If no subset was found for v[i], move to the next element
        if !subset_found
            i += 1
        end
    end
    return v
end

function determine_efficient_order(ùêí‚ÇÅ::Matrix{<: Real}, 
    T::timings, 
    variables::Union{Symbol_input,String_input};
    tol::AbstractFloat = eps())

    orders = Pair{Vector{Symbol}, Vector{Symbol}}[]

    nÀ¢ = T.nPast_not_future_and_mixed
    
    if variables == :full_covar
        return [T.var => T.past_not_future_and_mixed]
    else
        var_idx = MacroModelling.parse_variables_input_to_index(variables, T)
        observables = T.var[var_idx]
    end

    for obs in observables
        obs_in_var_idx = indexin([obs],T.var)
        dependencies_in_states = vec(sum(abs, ùêí‚ÇÅ[obs_in_var_idx,1:nÀ¢], dims=1) .> tol) .> 0

        while dependencies_in_states .| vec(abs.(dependencies_in_states' * ùêí‚ÇÅ[indexin(T.past_not_future_and_mixed, T.var),1:nÀ¢]) .> tol) != dependencies_in_states
            dependencies_in_states = dependencies_in_states .| vec(abs.(dependencies_in_states' * ùêí‚ÇÅ[indexin(T.past_not_future_and_mixed, T.var),1:nÀ¢]) .> tol)
        end

        dependencies = T.past_not_future_and_mixed[dependencies_in_states]

        push!(orders,[obs] => sort(dependencies))
    end

    sort!(orders, by = x -> length(x[2]), rev = true)

    return combine_pairs(orders)
end

# function determine_efficient_order(‚àá‚ÇÅ::SparseMatrixCSC{<: Real}, 
#                                     T::timings, 
#                                     variables::Union{Symbol_input,String_input};
#                                     tol::AbstractFloat = eps())

#     droptol!(‚àá‚ÇÅ, tol)

#     if variables == :full_covar
#         return [T.var => T.var]
#     else
#         var_idx = parse_variables_input_to_index(variables, T)
#         observables = T.var[var_idx]
#     end

#     expand = [  spdiagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:],
#                 spdiagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]] 
    
#     ‚àá‚Çä = ‚àá‚ÇÅ[:,1:T.nFuture_not_past_and_mixed] * expand[1]
#     ‚àá‚ÇÄ = ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
#     ‚àá‚Çã = ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1,T.nPast_not_future_and_mixed)] * expand[2]

#     incidence = abs.(‚àá‚Çä) + abs.(‚àá‚ÇÄ) + abs.(‚àá‚Çã)

#     Q, P, R, nmatch, n_blocks = BlockTriangularForm.order(sparse(incidence))
#     RÃÇ = []
#     for i in 1:n_blocks
#         [push!(RÃÇ, n_blocks - i + 1) for ii in R[i]:R[i+1] - 1]
#     end
#     push!(RÃÇ,1)
    
#     vars = hcat(P, RÃÇ)'
#     eqs  = hcat(Q, RÃÇ)'
    
#     dependency_matrix = incidence[vars[1,:], eqs[1,:]] .!= 0
    
#     warshall_algorithm!(dependency_matrix)

#     solve_order = Vector{Symbol}[]
#     already_solved_for = Set{Symbol}()
#     corresponding_dependencies = Vector{Symbol}[]

#     for obs in intersect(T.var[eqs[1,:]], observables)
#         dependencies = T.var[eqs[1,:]][findall(dependency_matrix[indexin([obs], T.var[eqs[1,:]])[1],:])]
#         to_be_solved_for = setdiff(intersect(observables, dependencies), already_solved_for)
#         if length(to_be_solved_for) > 0
#             push!(solve_order, to_be_solved_for)
#             push!(corresponding_dependencies, dependencies)
#         end
#         push!(already_solved_for, intersect(observables, dependencies)...)
#     end

#     return solve_order .=> corresponding_dependencies
# end



function bivariate_moment(moment::Vector{Int}, rho::Int)::Int
    if (moment[1] + moment[2]) % 2 == 1
        return 0
    end

    result = 1
    coefficient = 1
    odd_value = 2 * (moment[1] % 2)

    for j = 1:min(moment[1] √∑ 2, moment[2] √∑ 2)
        coefficient *= 2 * (moment[1] √∑ 2 + 1 - j) * (moment[2] √∑ 2 + 1 - j) * rho^2 / (j * (2 * j - 1 + odd_value))
        result += coefficient
    end

    if odd_value == 2
        result *= rho
    end

    result *= prod(1:2:moment[1]) * prod(1:2:moment[2])

    return result
end


function product_moments(V, ii, nu)
    s = sum(nu)

    if s == 0
        return 1
    elseif isodd(s)
        return 0
    end

    mask = .!(nu .== 0)
    nu = nu[mask]
    ii = ii[mask]
    V = V[ii, ii]

    m, s2 = length(ii), s / 2

    if m == 1
        return (V^s2 * prod(1:2:s-1))[1]
    elseif m == 2
        if V[1,1]==0 || V[2,2]==0
            return 0
        end
        rho = V[1, 2] / sqrt(V[1, 1] * V[2, 2])
        return (V[1, 1]^(nu[1] / 2) * V[2, 2]^(nu[2] / 2) * bivariate_moment(nu, Int(rho)))[1]
    end

    inu = sortperm(nu, rev=true)

    sort!(nu, rev=true)

    V = V[inu, inu]

    x = zeros(Int, 1, m)
    V = V / 2
    nu2 = nu' / 2
    p = 2
    q = nu2 * V * nu2'
    y = 0

    for _ in 1:round(Int, prod(nu .+ 1) / 2)
        y += p * q^s2
        for j in 1:m
            if x[j] < nu[j]
                x[j] += 1
                p = -round(p * (nu[j] + 1 - x[j]) / x[j])
                q -= (2 * (nu2 - x) * V[:, j] .+ V[j, j])[1]
                break
            else
                x[j] = 0
                p = isodd(nu[j]) ? -p : p
                q += (2 * nu[j] * (nu2 - x) * V[:, j] .- nu[j]^2 * V[j, j])[1]
            end
        end
    end

    return y / prod(1:s2)
end


function multiplicate(p::Int, order::Int)
    # precompute p powers
    p‚Åø = [p^i for i in 0:order-1]

    DP = spzeros(Bool, p^order, prod(p - 1 .+ (1:order)) √∑ factorial(order))

    binom_p_ord = binomial(p + order - 1, order)

    # Initialize index and binomial arrays
    indexes = ones(Int, order)  # Vector to hold current indexes
    binomials = zeros(Int, order)  # Vector to hold binomial values

    # Helper function to handle the nested loops
    function loop(level::Int)
        for i=1:p
            indexes[level] = i
            binomials[level] = binomial(p + level - 1 - i, level)

            if level < order  # If not at innermost loop yet, continue nesting
                loop(level + 1)
            else  # At innermost loop, perform calculation
                n = sum((indexes[k] - 1) * p‚Åø[k] for k in 1:order)
                m = binom_p_ord - sum(binomials[k] for k in 1:order)
                DP[n+1, m] = 1  # Arrays are 1-indexed in Julia
            end
        end
    end

    loop(1)  # Start the recursive loop

    return DP
end


function generateSumVectors(vectorLength::Int, totalSum::Int)
    # Base case: if vectorLength is 1, return totalSum
    if vectorLength == 1
        return [totalSum]
    end

    # Recursive case: generate all possible vectors for smaller values of vectorLength and totalSum
    return [[currentInt; smallerVector...]' for currentInt in totalSum:-1:0 for smallerVector in generateSumVectors(vectorLength-1, totalSum-currentInt)]
end


function match_pattern(strings::Union{Set,Vector}, pattern::Regex)
    return filter(r -> match(pattern, string(r)) !== nothing, strings)
end

# try: run optim only if there is a violation / capture case with small shocks and set them to zero
function parse_occasionally_binding_constraints(equations_block; max_obc_horizon::Int = 40)
    # precision_factor = 1e  #factor to force the optimiser to have non-relevatn shocks at zero

    eqs = []
    obc_shocks = Expr[]

    for arg in equations_block.args
        if isa(arg,Expr)
            if check_for_minmax(arg)
                arg_trans = transform_obc(arg)
            else
                arg_trans = arg
            end

            eq = postwalk(x -> 
                    x isa Expr ?
                        x.head == :call ? 
                            x.args[1] == :max ?
                                begin

                                    obc_vars_left = Expr(:ref, Meta.parse("œá·µí·µá·∂ú‚Å∫Íúù" * super(string(length(obc_shocks) + 1)) * "ÍúùÀ°" ), 0)
                                    obc_vars_right = Expr(:ref, Meta.parse("œá·µí·µá·∂ú‚Å∫Íúù" * super(string(length(obc_shocks) + 1)) * "Íúù ≥" ), 0)

                                    if !(x.args[2] isa Symbol) && check_for_dynamic_variables(x.args[2])
                                        push!(eqs, :($obc_vars_left = $(x.args[2])))
                                    else
                                        obc_vars_left = x.args[2]
                                    end

                                    if !(x.args[3] isa Symbol) && check_for_dynamic_variables(x.args[3])
                                        push!(eqs, :($obc_vars_right = $(x.args[3])))
                                    else
                                        obc_vars_right = x.args[3]
                                    end

                                    obc_inequality = Expr(:ref, Meta.parse("Œß·µí·µá·∂ú‚Å∫Íúù" * super(string(length(obc_shocks) + 1)) * "Íúù" ), 0)

                                    push!(eqs, :($obc_inequality = $(Expr(x.head, x.args[1], obc_vars_left, obc_vars_right))))

                                    obc_shock = Expr(:ref, Meta.parse("œµ·µí·µá·∂ú‚Å∫Íúù" * super(string(length(obc_shocks) + 1)) * "Íúù"), 0)

                                    push!(obc_shocks, obc_shock)

                                    :($obc_inequality - $obc_shock)
                                end :
                            x.args[1] == :min ?
                                begin
                                    obc_vars_left = Expr(:ref, Meta.parse("œá·µí·µá·∂ú‚ÅªÍúù" * super(string(length(obc_shocks) + 1)) * "ÍúùÀ°" ), 0)
                                    obc_vars_right = Expr(:ref, Meta.parse("œá·µí·µá·∂ú‚ÅªÍúù" * super(string(length(obc_shocks) + 1)) * "Íúù ≥" ), 0)

                                    if !(x.args[2] isa Symbol) && check_for_dynamic_variables(x.args[2])
                                        push!(eqs, :($obc_vars_left = $(x.args[2])))
                                    else
                                        obc_vars_left = x.args[2]
                                    end

                                    if !(x.args[3] isa Symbol) && check_for_dynamic_variables(x.args[3])
                                        push!(eqs, :($obc_vars_right = $(x.args[3])))
                                    else
                                        obc_vars_right = x.args[3]
                                    end

                                    obc_inequality = Expr(:ref, Meta.parse("Œß·µí·µá·∂ú‚ÅªÍúù" * super(string(length(obc_shocks) + 1)) * "Íúù" ), 0)

                                    push!(eqs, :($obc_inequality = $(Expr(x.head, x.args[1], obc_vars_left, obc_vars_right))))

                                    obc_shock = Expr(:ref, Meta.parse("œµ·µí·µá·∂ú‚ÅªÍúù" * super(string(length(obc_shocks) + 1)) * "Íúù"), 0)

                                    push!(obc_shocks, obc_shock)

                                    :($obc_inequality - $obc_shock)
                                end :
                            x :
                        x :
                    x,
            arg_trans)

            push!(eqs, eq)
        end
    end

    for obc in obc_shocks
        # push!(eqs, :($(obc) = $(Expr(:ref, obc.args[1], -1)) * 0.3 + $(Expr(:ref, Meta.parse(string(obc.args[1]) * "·¥∏‚ÅΩ‚Åª" * super(string(max_obc_horizon)) * "‚Åæ"), 0))))
        push!(eqs, :($(obc) = $(Expr(:ref, Meta.parse(string(obc.args[1]) * "·¥∏‚ÅΩ‚Åª" * super(string(max_obc_horizon)) * "‚Åæ"), 0))))

        push!(eqs, :($(Expr(:ref, Meta.parse(string(obc.args[1]) * "·¥∏‚ÅΩ‚Åª‚Å∞‚Åæ"), 0)) = active·µí·µá·∂úshocks * $(Expr(:ref, Meta.parse(string(obc.args[1]) * "‚ÅΩ" * super(string(max_obc_horizon)) * "‚Åæ"), :x))))

        for i in 1:max_obc_horizon
            push!(eqs, :($(Expr(:ref, Meta.parse(string(obc.args[1]) * "·¥∏‚ÅΩ‚Åª" * super(string(i)) * "‚Åæ"), 0)) = $(Expr(:ref, Meta.parse(string(obc.args[1]) * "·¥∏‚ÅΩ‚Åª" * super(string(i-1)) * "‚Åæ"), -1)) + active·µí·µá·∂úshocks * $(Expr(:ref, Meta.parse(string(obc.args[1]) * "‚ÅΩ" * super(string(max_obc_horizon-i)) * "‚Åæ"), :x))))
        end
    end

    return Expr(:block, eqs...)
end


# compatibility with SymPy
Max = max
Min = min

function simplify(ex::Expr)
    ex_ss = convert_to_ss_equation(ex)

    for x in get_symbols(ex_ss)
	    eval(:($x = SPyPyC.symbols($(string(x)), real = true, finite = true)))
    end

	parsed = ex_ss |> eval |> string |> Meta.parse

    postwalk(x ->   x isa Expr ? 
                        x.args[1] == :conjugate ? 
                            x.args[2] : 
                        x : 
                    x, parsed)
end

function convert_to_ss_equation(eq::Expr)
    postwalk(x -> 
        x isa Expr ? 
            x.head == :(=) ? 
                Expr(:call,:(-),x.args[1],x.args[2]) : #convert = to -
                    x.head == :ref ?
                        occursin(r"^(x|ex|exo|exogenous){1}"i,string(x.args[2])) ? 0 :
                x.args[1] : 
            x.head == :call ?
                x.args[1] == :* ?
                    x.args[2] isa Int ?
                        x.args[3] isa Int ?
                            x :
                        :($(x.args[3]) * $(x.args[2])) : # avoid 2X syntax. doesnt work with sympy
                    x :
                x :
            unblock(x) : 
        x,
    eq)
end


function replace_indices_inside_for_loop(exxpr,index_variable,indices,concatenate, operator)
    @assert operator ‚àà [:+,:*] "Only :+ and :* allowed as operators in for loops."
    calls = []
    indices = indices.args[1] == :(:) ? eval(indices) : [indices.args...]
    for idx in indices
        push!(calls, postwalk(x -> begin
            x isa Expr ?
                x.head == :ref ?
                    @capture(x, name_{index_}[time_]) ?
                        index == index_variable ?
                            :($(Expr(:ref, Symbol(string(name) * "‚óñ" * string(idx) * "‚óó"),time))) :
                        time isa Expr || time isa Symbol ?
                            index_variable ‚àà get_symbols(time) ?
                                :($(Expr(:ref, Expr(:curly,name,index), Meta.parse(replace(string(time), string(index_variable) => idx))))) :
                            x :
                        x :
                    @capture(x, name_[time_]) ?
                        time isa Expr || time isa Symbol ?
                            index_variable ‚àà get_symbols(time) ?
                                :($(Expr(:ref, name, Meta.parse(replace(string(time), string(index_variable) => idx))))) :
                            x :
                        x :
                    x :
                @capture(x, name_{index_}) ?
                    index == index_variable ?
                        :($(Symbol(string(name) * "‚óñ" * string(idx) * "‚óó"))) :
                    x :
                x :
            @capture(x, name_) ?
                name == index_variable && idx isa Int ?
                    :($idx) :
                x :
            x
        end,
        exxpr))
    end

    if concatenate
        return :($(Expr(:call, operator, calls...)))
    else
        return calls
    end
end


replace_indices(x::Symbol) = x

replace_indices(x::String) = Symbol(replace(x, "{" => "‚óñ", "}" => "‚óó"))

replace_indices_in_symbol(x::Symbol) = replace(string(x), "‚óñ" => "{", "‚óó" => "}")

function replace_indices(exxpr::Expr)
    postwalk(x -> begin
        @capture(x, name_{index_}) ?
            :($(Symbol(string(name) * "‚óñ" * string((index)) * "‚óó"))) :
        x
        end,
    exxpr)
end


function write_out_for_loops(arg::Expr)
    postwalk(x -> begin
                    x = unblock(x)
                    x isa Expr ?
                        x.head == :for ?
                            x.args[2] isa Array ?
                                length(x.args[2]) >= 1 ?
                                    x.args[1].head == :block ?
                                        [replace_indices_inside_for_loop(X, Symbol(x.args[1].args[2].args[1]), (x.args[1].args[2].args[2]), false, x.args[1].args[1].args[2].value) for X in x.args[2]] :
                                    [replace_indices_inside_for_loop(X, Symbol(x.args[1].args[1]), (x.args[1].args[2]), false, :+) for X in x.args[2]] :
                                x :
                            x.args[2].head ‚àâ [:(=), :block] ?
                                x.args[1].head == :block ?
                                    replace_indices_inside_for_loop(unblock(x.args[2]), 
                                                        Symbol(x.args[1].args[2].args[1]), 
                                                        (x.args[1].args[2].args[2]),
                                                        true,
                                                        x.args[1].args[1].args[2].value) : # for loop part of equation
                                replace_indices_inside_for_loop(unblock(x.args[2]), 
                                                    Symbol(x.args[1].args[1]), 
                                                    (x.args[1].args[2]),
                                                    true,
                                                    :+) : # for loop part of equation
                            x.args[1].head == :block ?
                                replace_indices_inside_for_loop(unblock(x.args[2]), 
                                                    Symbol(x.args[1].args[2].args[1]), 
                                                    (x.args[1].args[2].args[2]),
                                                    false,
                                                    x.args[1].args[1].args[2].value) : # for loop part of equation
                            replace_indices_inside_for_loop(unblock(x.args[2]), 
                                                Symbol(x.args[1].args[1]), 
                                                (x.args[1].args[2]),
                                                false,
                                                :+) :
                        x :
                    x
                end,
    arg)
end


function parse_for_loops(equations_block)
    eqs = Expr[]
    for arg in equations_block.args
        if isa(arg,Expr)
            parsed_eqs = write_out_for_loops(arg)
            if parsed_eqs isa Expr
                push!(eqs,unblock(replace_indices(parsed_eqs)))
            elseif parsed_eqs isa Array
                for B in parsed_eqs
                    if B isa Array
                        for b in B
                            push!(eqs,unblock(replace_indices(b)))
                        end
                    elseif B isa Expr
                        if B.head == :block
                            for b in B.args
                                if b isa Expr
                                    push!(eqs,replace_indices(b))
                                end
                            end
                        else
                            push!(eqs,unblock(replace_indices(B)))
                        end
                    else
                        push!(eqs,unblock(replace_indices(B)))
                    end
                end
            end

        end
    end
    return Expr(:block,eqs...)
end



function decompose_name(name::Symbol)
    name = string(name)
    matches = eachmatch(r"‚óñ([\p{L}\p{N}]+)‚óó|([\p{L}\p{N}]+[^‚óñ‚óó]*)", name)

    result = []
    nested = []

    for m in matches
        if m.captures[1] !== nothing
            push!(nested, m.captures[1])
        else
            if !isempty(nested)
                push!(result, Symbol.(nested))
                nested = []
            end
            push!(result, Symbol(m.captures[2]))
        end
    end

    if !isempty(nested)
        push!(result, (nested))
    end

    return result
end



function get_possible_indices_for_name(name::Symbol, all_names::Vector{Symbol})
    indices = filter(x -> length(x) < 3 && x[1] == name, decompose_name.(all_names))

    indexset = []

    for i in indices
        if length(i) > 1
            push!(indexset, Symbol.(i[2])...)
        end
    end

    return indexset
end



function expand_calibration_equations(calibration_equation_parameters::Vector{Symbol}, calibration_equations::Vector{Expr}, ss_calib_list::Vector, par_calib_list::Vector, all_names::Vector{Symbol})
    expanded_parameters = Symbol[]
    expanded_equations = Expr[]
    expanded_ss_var_list = []
    expanded_par_var_list = []

    for (u,par) in enumerate(calibration_equation_parameters)
        indices_in_calibration_equation = Set()
        indexed_names = []
        for i in get_symbols(calibration_equations[u])
            indices = get_possible_indices_for_name(i, all_names)
            if indices != Any[]
                push!(indices_in_calibration_equation, indices)
                push!(indexed_names,i)
            end
        end

        par_indices = get_possible_indices_for_name(par, all_names)
        
        if length(par_indices) > 0
            push!(indices_in_calibration_equation, par_indices)
        end
        
        @assert length(indices_in_calibration_equation) <= 1 "Calibration equations cannot have more than one index in the equations or for the parameter."
        
        if length(indices_in_calibration_equation) == 0
            push!(expanded_parameters,par)
            push!(expanded_equations,calibration_equations[u])
            push!(expanded_ss_var_list,ss_calib_list[u])
            push!(expanded_par_var_list,par_calib_list[u])
        else
            for i in collect(indices_in_calibration_equation)[1]
                expanded_ss_var = Set()
                expanded_par_var = Set()
                push!(expanded_parameters, Symbol(string(par) * "‚óñ" * string(i) * "‚óó"))
                push!(expanded_equations, postwalk(x -> x ‚àà indexed_names ? Symbol(string(x) * "‚óñ" * string(i) * "‚óó") : x, calibration_equations[u]))
                for ss in ss_calib_list[u]
                    if ss ‚àà indexed_names
                        push!(expanded_ss_var,Symbol(string(ss) * "‚óñ" * string(i) * "‚óó"))
                    else
                        push!(expanded_ss_var,ss)
                        push!(expanded_par_var,par_calib_list[u])
                    end
                end
                push!(expanded_ss_var_list, expanded_ss_var)
                push!(expanded_par_var_list, expanded_par_var)
            end
        end
    end

    return expanded_parameters, expanded_equations, expanded_ss_var_list, expanded_par_var_list
end



function expand_indices(compressed_inputs::Vector{Symbol}, compressed_values::Vector{T}, expanded_list::Vector{Symbol}) where T
    expanded_inputs = Symbol[]
    expanded_values = T[]

    for (i,par) in enumerate(compressed_inputs)
        par_idx = findall(x -> string(par) == x, first.(split.(string.(expanded_list ), "‚óñ")))

        if length(par_idx) > 1
            for idx in par_idx
                push!(expanded_inputs, expanded_list[idx])
                push!(expanded_values, compressed_values[i])
            end
        else#if par ‚àà expanded_list ## breaks parameters defind in parameter block
            push!(expanded_inputs, par)
            push!(expanded_values, compressed_values[i])
        end
    end
    return expanded_inputs, expanded_values
end


function minmax!(x::Vector{Float64},lb::Vector{Float64},ub::Vector{Float64})
    @inbounds for i in eachindex(x)
        x[i] = max(lb[i], min(x[i], ub[i]))
    end
end



# transformation of NSSS problem
function transform(x::Vector{T}, option::Int, shift::AbstractFloat) where T <: Real
    if option == 4
        return asinh.(asinh.(asinh.(asinh.(x .+ shift))))
    elseif option == 3
        return asinh.(asinh.(asinh.(x .+ shift)))
    elseif option == 2
        return asinh.(asinh.(x .+ shift))
    elseif option == 1
        return asinh.(x .+ shift)
    elseif option == 0
        return x .+ shift
    end
end

function transform(x::Vector{T}, option::Int) where T <: Real
    if option == 4
        return asinh.(asinh.(asinh.(asinh.(x))))
    elseif option == 3
        return asinh.(asinh.(asinh.(x)))
    elseif option == 2
        return asinh.(asinh.(x))
    elseif option == 1
        return asinh.(x)
    elseif option == 0
        return x
    end
end

function undo_transform(x::Vector{T}, option::Int, shift::AbstractFloat) where T <: Real
    if option == 4
        return sinh.(sinh.(sinh.(sinh.(x)))) .- shift
    elseif option == 3
        return sinh.(sinh.(sinh.(x))) .- shift
    elseif option == 2
        return sinh.(sinh.(x)) .- shift
    elseif option == 1
        return sinh.(x) .- shift
    elseif option == 0
        return x .- shift
    end
end

function undo_transform(x::Vector{T}, option::Int) where T <: Real
    if option == 4
        return sinh.(sinh.(sinh.(sinh.(x))))
    elseif option == 3
        return sinh.(sinh.(sinh.(x)))
    elseif option == 2
        return sinh.(sinh.(x))
    elseif option == 1
        return sinh.(x)
    elseif option == 0
        return x
    end
end


function levenberg_marquardt(f::Function, 
    initial_guess::Array{T,1}, 
    lower_bounds::Array{T,1}, 
    upper_bounds::Array{T,1}; 
    parameters::solver_parameters = solver_parameters(eps(), eps(), 250, 2.9912988764832833, 0.8725, 0.0027, 0.028948770826150612, 8.04, 4.076413176215408, 0.06375413238034794, 0.24284340766769424, 0.5634017580097571, 0.009549630552246828, 0.6342888355132347, 0.5275522227754195, 1.0, 0.06178989216048817, 0.5234277812131813, 0.422, 0.011209254402846185, 0.5047, 0.6020757011698457, 1, 0.0, 2)
    ) where {T <: AbstractFloat}
    # issues with optimization: https://www.gurobi.com/documentation/8.1/refman/numerics_gurobi_guidelines.html

    xtol = parameters.xtol
    ftol = parameters.ftol
    iterations = parameters.iterations
    œïÃÑ = parameters.œïÃÑ
    œïÃÇ = parameters.œïÃÇ
    ŒºÃÑ¬π = parameters.ŒºÃÑ¬π
    ŒºÃÑ¬≤ = parameters.ŒºÃÑ¬≤
    pÃÑ¬π = parameters.pÃÑ¬π
    pÃÑ¬≤ = parameters.pÃÑ¬≤
    œÅ = parameters.œÅ
    œÅ¬π = parameters.œÅ¬π
    œÅ¬≤ = parameters.œÅ¬≤
    œÅ¬≥ = parameters.œÅ¬≥
    ŒΩ = parameters.ŒΩ
    Œª¬π = parameters.Œª¬π
    Œª¬≤ = parameters.Œª¬≤
    ŒªÃÇ¬π = parameters.ŒªÃÇ¬π
    ŒªÃÇ¬≤ = parameters.ŒªÃÇ¬≤
    ŒªÃÖ¬π = parameters.ŒªÃÖ¬π
    ŒªÃÖ¬≤ = parameters.ŒªÃÖ¬≤
    ŒªÃÇÃÖ¬π = parameters.ŒªÃÇÃÖ¬π
    ŒªÃÇÃÖ¬≤ = parameters.ŒªÃÇÃÖ¬≤
    transformation_level = parameters.transformation_level
    shift = parameters.shift
    backtracking_order = parameters.backtracking_order

    @assert size(lower_bounds) == size(upper_bounds) == size(initial_guess)
    @assert all(lower_bounds .< upper_bounds)
    @assert backtracking_order ‚àà [2,3] "Backtracking order can only be quadratic (2) or cubic (3)."

    max_linesearch_iterations = 1000

    function fÃÇ(x) 
        f(undo_transform(x,transformation_level))  
        # f(undo_transform(x,transformation_level,shift))  
    end

    upper_bounds  = transform(upper_bounds,transformation_level)
    # upper_bounds  = transform(upper_bounds,transformation_level,shift)
    lower_bounds  = transform(lower_bounds,transformation_level)
    # lower_bounds  = transform(lower_bounds,transformation_level,shift)

    current_guess = copy(transform(initial_guess,transformation_level))
    # current_guess = copy(transform(initial_guess,transformation_level,shift))
    previous_guess = similar(current_guess)
    guess_update = similar(current_guess)

    ‚àá = Array{T,2}(undef, length(initial_guess), length(initial_guess))
    ‚àáÃÇ = similar(‚àá)

    largest_step = zero(T)
    largest_residual = zero(T)

    Œº¬π = ŒºÃÑ¬π
    Œº¬≤ = ŒºÃÑ¬≤

    p¬π = pÃÑ¬π
    p¬≤ = pÃÑ¬≤

	for iter in 1:iterations
        ‚àá .= ‚Ñ±.jacobian(fÃÇ,current_guess)

        previous_guess .= current_guess

        ‚àáÃÇ .= ‚àá' * ‚àá

        ‚àáÃÇ .+= Œº¬π * sum(abs2, fÃÇ(current_guess))^p¬π * ‚Ñí.I + Œº¬≤ * ‚Ñí.Diagonal(‚àáÃÇ).^p¬≤

        if !all(isfinite,‚àáÃÇ)
            return undo_transform(current_guess,transformation_level), (iter, Inf, Inf, upper_bounds)
            # return undo_transform(current_guess,transformation_level,shift), (iter, Inf, Inf, upper_bounds)
        end

        ‚àáÃÑ = RF.lu(‚àáÃÇ, check = false)

        if !‚Ñí.issuccess(‚àáÃÑ)
            ‚àáÃÑ = ‚Ñí.svd(‚àáÃÇ)
        end

        current_guess .-= ‚àáÃÑ \ ‚àá' * fÃÇ(current_guess)

        minmax!(current_guess, lower_bounds, upper_bounds)

        P = sum(abs2, fÃÇ(previous_guess))
        PÃÉ = P

        PÃã = sum(abs2, fÃÇ(current_guess))

        Œ± = 1.0
        Œ±ÃÑ = 1.0

        ŒΩÃÇ = ŒΩ

        guess_update .= current_guess - previous_guess
        g = fÃÇ(previous_guess)' * ‚àá * guess_update
        U = sum(abs2,guess_update)

        if PÃã > œÅ * P 
            linesearch_iterations = 0
            while PÃã > (1 + ŒΩÃÇ - œÅ¬π * Œ±^2) * PÃÉ + œÅ¬≤ * Œ±^2 * g - œÅ¬≥ * Œ±^2 * U && linesearch_iterations < max_linesearch_iterations
                if backtracking_order == 2
                    # Quadratic backtracking line search
                    Œ±ÃÇ = -g * Œ±^2 / (2 * (PÃã - PÃÉ - g * Œ±))
                elseif backtracking_order == 3
                    # Cubic backtracking line search
                    a = (Œ±ÃÑ^2 * (PÃã - PÃÉ - g * Œ±) - Œ±^2 * (P - PÃÉ - g * Œ±ÃÑ)) / (Œ±ÃÑ^2 * Œ±^2 * (Œ± - Œ±ÃÑ))
                    b = (Œ±^3 * (P - PÃÉ - g * Œ±ÃÑ) - Œ±ÃÑ^3 * (PÃã - PÃÉ - g * Œ±)) / (Œ±ÃÑ^2 * Œ±^2 * (Œ± - Œ±ÃÑ))

                    if isapprox(a, zero(a), atol=eps())
                        Œ±ÃÇ = g / (2 * b)
                    else
                        # discriminant
                        d = max(b^2 - 3 * a * g, 0)
                        # quadratic equation root
                        Œ±ÃÇ = (sqrt(d) - b) / (3 * a)
                    end

                    Œ±ÃÑ = Œ±
                end

                Œ±ÃÇ = min(Œ±ÃÇ, œïÃÑ * Œ±)
                Œ± = max(Œ±ÃÇ, œïÃÇ * Œ±)

                current_guess .= previous_guess + Œ± * guess_update
                minmax!(current_guess, lower_bounds, upper_bounds)
                
                P = PÃã

                PÃã = sum(abs2,fÃÇ(current_guess))

                ŒΩÃÇ *= Œ±

                linesearch_iterations += 1
            end

            Œº¬π *= ŒªÃÖ¬π
            Œº¬≤ *= ŒªÃÖ¬≤

            p¬π *= ŒªÃÇÃÖ¬π
            p¬≤ *= ŒªÃÇÃÖ¬≤
        else
            Œº¬π = min(Œº¬π / Œª¬π, ŒºÃÑ¬π)
            Œº¬≤ = min(Œº¬≤ / Œª¬≤, ŒºÃÑ¬≤)

            p¬π = min(p¬π / ŒªÃÇ¬π, pÃÑ¬π)
            p¬≤ = min(p¬≤ / ŒªÃÇ¬≤, pÃÑ¬≤)
        end

        largest_step = maximum(abs, previous_guess - current_guess)
        largest_residual = maximum(abs, f(undo_transform(current_guess,transformation_level)))
        # largest_residual = maximum(abs, f(undo_transform(current_guess,transformation_level,shift)))

        if largest_step <= xtol || largest_residual <= ftol
            return undo_transform(current_guess,transformation_level), (iter, largest_step, largest_residual, f(undo_transform(current_guess,transformation_level)))
            # return undo_transform(current_guess,transformation_level,shift), (iter, largest_step, largest_residual, f(undo_transform(current_guess,transformation_level,shift)))
        end
    end

    best_guess = undo_transform(current_guess,transformation_level)
    # best_guess = undo_transform(current_guess,transformation_level,shift)

    return best_guess, (iterations, largest_step, largest_residual, f(best_guess))
end


function expand_steady_state(SS_and_pars::Vector{M},ùìÇ::‚Ñ≥) where M
    all_variables = sort(union(ùìÇ.var,ùìÇ.aux,ùìÇ.exo_present))

    all_variables[indexin(ùìÇ.aux,all_variables)] = map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  ùìÇ.aux)
    
    NSSS_labels = [sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...]
    
    [SS_and_pars[indexin([s],NSSS_labels)...] for s in all_variables]
end



# function add_auxilliary_variables_to_steady_state(SS_and_pars::Vector{Float64},ùìÇ::‚Ñ≥)
#     all_variables = sort(union(ùìÇ.var,ùìÇ.aux,ùìÇ.exo_present))

#     all_variables[indexin(ùìÇ.aux,all_variables)] = map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  ùìÇ.aux)
    
#     vars_in_ss_equations = sort(collect(setdiff(reduce(union,get_symbols.(ùìÇ.ss_aux_equations)),union(ùìÇ.parameters_in_equations,ùìÇ.‚ûï_vars))))

#     [SS_and_pars[indexin([s],vars_in_ss_equations)...] for s in all_variables]
# end


function create_symbols_eqs!(ùìÇ::‚Ñ≥)
    # create symbols in module scope
    symbols_in_dynamic_equations = reduce(union,get_symbols.(ùìÇ.dyn_equations))

    symbols_in_dynamic_equations_wo_subscripts = Symbol.(replace.(string.(symbols_in_dynamic_equations),r"‚Çç‚Çã?(‚ÇÄ|‚ÇÅ|‚Çõ‚Çõ|‚Çì)‚Çé$"=>""))

    symbols_in_ss_equations = reduce(union,get_symbols.(ùìÇ.ss_aux_equations))

    symbols_in_equation = union(ùìÇ.parameters_in_equations,ùìÇ.parameters,ùìÇ.parameters_as_function_of_parameters,symbols_in_dynamic_equations,symbols_in_dynamic_equations_wo_subscripts,symbols_in_ss_equations)#,ùìÇ.dynamic_variables_future)

    l_bnds = Dict(ùìÇ.bounded_vars .=> ùìÇ.lower_bounds)
    u_bnds = Dict(ùìÇ.bounded_vars .=> ùìÇ.upper_bounds)

    symbols_pos = []
    symbols_neg = []
    symbols_none = []

    for symb in symbols_in_equation
        if symb in ùìÇ.bounded_vars
            if l_bnds[symb] >= 0
                push!(symbols_pos, symb)
            elseif u_bnds[symb] <= 0
                push!(symbols_neg, symb)
            else 
                push!(symbols_none, symb)
            end
        else
            push!(symbols_none, symb)
        end
    end

    for pos in symbols_pos
        eval(:($pos = SPyPyC.symbols($(string(pos)), real = true, finite = true, positive = true)))
    end
    for neg in symbols_neg
        eval(:($neg = SPyPyC.symbols($(string(neg)), real = true, finite = true, negative = true)))
    end
    for none in symbols_none
        eval(:($none = SPyPyC.symbols($(string(none)), real = true, finite = true)))
    end

    symbolics(map(x->eval(:($x)),ùìÇ.ss_aux_equations),
                map(x->eval(:($x)),ùìÇ.dyn_equations),
                # map(x->eval(:($x)),ùìÇ.dyn_equations_future),

                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift_var_present_list),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift_var_past_list),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift_var_future_list),

                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_shift2_var_past_list),

                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_var_present_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_var_past_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_var_future_list),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_ss_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_exo_list),

                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_exo_future_list),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_exo_present_list),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_exo_past_list),

                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_future_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_present_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.dyn_past_list),

                map(x->Set(eval(:([$(x...)]))),ùìÇ.var_present_list_aux_SS),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.var_past_list_aux_SS),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.var_future_list_aux_SS),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.ss_list_aux_SS),

                map(x->Set(eval(:([$(x...)]))),ùìÇ.var_list_aux_SS),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dynamic_variables_list),
                # map(x->Set(eval(:([$(x...)]))),ùìÇ.dynamic_variables_future_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.par_list_aux_SS),

                map(x->eval(:($x)),ùìÇ.calibration_equations),
                map(x->eval(:($x)),ùìÇ.calibration_equations_parameters),
                # map(x->eval(:($x)),ùìÇ.parameters),

                # Set(eval(:([$(ùìÇ.var_present...)]))),
                # Set(eval(:([$(ùìÇ.var_past...)]))),
                # Set(eval(:([$(ùìÇ.var_future...)]))),
                Set(eval(:([$(ùìÇ.vars_in_ss_equations...)]))),
                Set(eval(:([$(ùìÇ.var...)]))),
                Set(eval(:([$(ùìÇ.‚ûï_vars...)]))),

                map(x->Set(eval(:([$(x...)]))),ùìÇ.ss_calib_list),
                map(x->Set(eval(:([$(x...)]))),ùìÇ.par_calib_list),

                [Set() for _ in 1:length(ùìÇ.ss_aux_equations)],
                # [Set() for _ in 1:length(ùìÇ.calibration_equations)],
                # [Set() for _ in 1:length(ùìÇ.ss_aux_equations)],
                # [Set() for _ in 1:length(ùìÇ.calibration_equations)]
                )
end



function remove_redundant_SS_vars!(ùìÇ::‚Ñ≥, Symbolics::symbolics)
    ss_equations = Symbolics.ss_equations

    # check variables which appear in two time periods. they might be redundant in steady state
    redundant_vars = intersect.(
        union.(
            intersect.(Symbolics.var_future_list,Symbolics.var_present_list),
            intersect.(Symbolics.var_future_list,Symbolics.var_past_list),
            intersect.(Symbolics.var_present_list,Symbolics.var_past_list),
            intersect.(Symbolics.ss_list,Symbolics.var_present_list),
            intersect.(Symbolics.ss_list,Symbolics.var_past_list),
            intersect.(Symbolics.ss_list,Symbolics.var_future_list)
        ),
    Symbolics.var_list)
    redundant_idx = getindex(1:length(redundant_vars), (length.(redundant_vars) .> 0) .& (length.(Symbolics.var_list) .> 1))

    for i in redundant_idx
        for var_to_solve_for in redundant_vars[i]
            soll = try SPyPyC.solve(ss_equations[i],var_to_solve_for)
            catch
            end
            
            if isnothing(soll)
                continue
            end
            
            if length(soll) == 0 || soll == SPyPyC.Sym[0] # take out variable if it is redundant from that euation only
                push!(Symbolics.var_redundant_list[i],var_to_solve_for)
                ss_equations[i] = ss_equations[i].subs(var_to_solve_for,1).replace(SPyPyC.Sym(‚ÑØ),exp(1)) # replace euler constant as it is not translated to julia properly
            end

        end
    end

end




function solve_steady_state!(ùìÇ::‚Ñ≥, symbolic_SS, Symbolics::symbolics; verbose::Bool = false)
    unknowns = union(Symbolics.vars_in_ss_equations,Symbolics.calibration_equations_parameters)

    @assert length(unknowns) <= length(Symbolics.ss_equations) + length(Symbolics.calibration_equations) "Unable to solve steady state. More unknowns than equations."

    incidence_matrix = fill(0,length(unknowns),length(unknowns))

    eq_list = vcat(union.(setdiff.(union.(Symbolics.var_list,
                                        Symbolics.ss_list),
                                    Symbolics.var_redundant_list),
                            Symbolics.par_list),
                    union.(Symbolics.ss_calib_list,
                            Symbolics.par_calib_list))


    for i in 1:length(unknowns)
        for k in 1:length(unknowns)
            incidence_matrix[i,k] = collect(unknowns)[i] ‚àà collect(eq_list)[k]
        end
    end

    Q, P, R, nmatch, n_blocks = BlockTriangularForm.order(sparse(incidence_matrix))
    RÃÇ = []
    for i in 1:n_blocks
        [push!(RÃÇ, n_blocks - i + 1) for ii in R[i]:R[i+1] - 1]
    end
    push!(RÃÇ,1)

    vars = hcat(P, RÃÇ)'
    eqs = hcat(Q, RÃÇ)'

    # @assert all(eqs[1,:] .> 0) "Could not solve system of steady state and calibration equations for: " * repr([collect(Symbol.(unknowns))[vars[1,eqs[1,:] .< 0]]...]) # repr([vcat(Symbolics.ss_equations,Symbolics.calibration_equations)[-eqs[1,eqs[1,:].<0]]...])
    @assert all(eqs[1,:] .> 0) "Could not solve system of steady state and calibration equations. Number of redundant euqations: " * repr(sum(eqs[1,:] .< 0)) * ". Try defining some steady state values as parameters (e.g. r[ss] -> rÃÑ). Nonstationary variables are not supported as of now." # repr([vcat(Symbolics.ss_equations,Symbolics.calibration_equations)[-eqs[1,eqs[1,:].<0]]...])
    
    n = n_blocks

    ss_equations = vcat(Symbolics.ss_equations,Symbolics.calibration_equations)# .|> SPyPyC.Sym
    # println(ss_equations)

    SS_solve_func = []

    atoms_in_equations = Set{Symbol}()
    atoms_in_equations_list = []
    relevant_pars_across = []
    NSSS_solver_cache_init_tmp = []

    min_max_errors = []

    n_block = 1

    while n > 0 
        if length(eqs[:,eqs[2,:] .== n]) == 2
            var_to_solve_for = collect(unknowns)[vars[:,vars[2,:] .== n][1]]

            eq_to_solve = ss_equations[eqs[:,eqs[2,:] .== n][1]]

            # eliminate min/max from equations if solving for variables inside min/max. set to the variable we solve for automatically
            parsed_eq_to_solve_for = eq_to_solve |> string |> Meta.parse

            minmax_fixed_eqs = postwalk(x -> 
                x isa Expr ?
                    x.head == :call ? 
                        x.args[1] ‚àà [:Max,:Min] ?
                            Symbol(var_to_solve_for) ‚àà get_symbols(x.args[2]) ?
                                x.args[2] :
                            Symbol(var_to_solve_for) ‚àà get_symbols(x.args[3]) ?
                                x.args[3] :
                            x :
                        x :
                    x :
                x,
            parsed_eq_to_solve_for)

            if parsed_eq_to_solve_for != minmax_fixed_eqs
                [push!(atoms_in_equations, a) for a in setdiff(get_symbols(parsed_eq_to_solve_for), get_symbols(minmax_fixed_eqs))]
                push!(min_max_errors,:(solution_error += abs($parsed_eq_to_solve_for)))
                eq_to_solve = eval(minmax_fixed_eqs)
            end

            soll = try SPyPyC.solve(eq_to_solve,var_to_solve_for)
            catch
            end
            
            if isnothing(soll)
                # println("Could not solve single variables case symbolically.")
                println("Failed finding solution symbolically for: ",var_to_solve_for," in: ",eq_to_solve)
                # solve numerically
                continue
            # elseif PythonCall.pyconvert(Bool,soll[1].is_number)

            elseif soll[1].is_number == true
                # ss_equations = ss_equations.subs(var_to_solve,soll[1])
                ss_equations = [eq.subs(var_to_solve_for,soll[1]) for eq in ss_equations]
                
                push!(ùìÇ.solved_vars,Symbol(var_to_solve_for))
                push!(ùìÇ.solved_vals,Meta.parse(string(soll[1])))

                if (ùìÇ.solved_vars[end] ‚àà ùìÇ.‚ûï_vars) 
                    push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = max(eps(),$(ùìÇ.solved_vals[end]))))
                else
                    push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
                end

                push!(atoms_in_equations_list,[])
            else

                push!(ùìÇ.solved_vars,Symbol(var_to_solve_for))
                push!(ùìÇ.solved_vals,Meta.parse(string(soll[1])))
                
                # atoms = reduce(union,soll[1].atoms())

                [push!(atoms_in_equations, Symbol(a)) for a in soll[1].atoms()]
                push!(atoms_in_equations_list, Set(union(setdiff(get_symbols(parsed_eq_to_solve_for), get_symbols(minmax_fixed_eqs)),Symbol.(soll[1].atoms()))))

                # println(atoms_in_equations)
                # push!(atoms_in_equations, soll[1].atoms())

                if (ùìÇ.solved_vars[end] ‚àà ùìÇ.‚ûï_vars) 
                    push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = min(max($(ùìÇ.lower_bounds[indexin([ùìÇ.solved_vars[end]],ùìÇ.bounded_vars)][1]),$(ùìÇ.solved_vals[end])),$(ùìÇ.upper_bounds[indexin([ùìÇ.solved_vars[end]],ùìÇ.bounded_vars)][1]))))
                else
                    push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
                end
            end

            # push!(single_eqs,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
            # solve symbolically
        else

            vars_to_solve = collect(unknowns)[vars[:,vars[2,:] .== n][1,:]]

            eqs_to_solve = ss_equations[eqs[:,eqs[2,:] .== n][1,:]]

            numerical_sol = false
            
            if symbolic_SS
                soll = try SPyPyC.solve(eqs_to_solve,vars_to_solve)
                # soll = try solve(SPyPyC.Sym(eqs_to_solve),var_order)#,check=false,force = true,manual=true)
                catch
                end

                if isnothing(soll)
                    if verbose
                        println("Failed finding solution symbolically for: ",vars_to_solve," in: ",eqs_to_solve,". Solving numerically.")
                    end
                    numerical_sol = true
                    # continue
                elseif length(soll) == 0
                    if verbose
                        println("Failed finding solution symbolically for: ",vars_to_solve," in: ",eqs_to_solve,". Solving numerically.")
                    end
                    numerical_sol = true
                    # continue
                # elseif length(intersect(vars_to_solve,reduce(union,map(x->x.atoms(),collect(soll[1]))))) > 0
                elseif length(intersect((union(SPyPyC.free_symbols.(soll[1])...) .|> SPyPyC.:‚Üì),(vars_to_solve .|> SPyPyC.:‚Üì))) > 0
                # elseif length(intersect(union(SPyPyC.free_symbols.(soll[1])...),vars_to_solve)) > 0
                    if verbose
                        println("Failed finding solution symbolically for: ",vars_to_solve," in: ",eqs_to_solve,". Solving numerically.")
                    end
                    numerical_sol = true
                    # println("Could not solve for: ",intersect(var_list,reduce(union,map(x->x.atoms(),solll)))...)
                    # break_ind = true
                    # break
                else
                    if verbose
                        println("Solved: ",string.(eqs_to_solve)," for: ",Symbol.(vars_to_solve), " symbolically.")
                    end
                    # relevant_pars = reduce(union,vcat(ùìÇ.par_list,ùìÇ.par_calib_list)[eqs[:,eqs[2,:] .== n][1,:]])
                    # relevant_pars = reduce(union,map(x->x.atoms(),collect(soll[1])))
                    atoms = reduce(union,map(x->x.atoms(),collect(soll[1])))
                    # println(atoms)
                    [push!(atoms_in_equations, Symbol(a)) for a in atoms]
                    
                    for (k, vars) in enumerate(vars_to_solve)
                        push!(ùìÇ.solved_vars,Symbol(vars))
                        push!(ùìÇ.solved_vals,Meta.parse(string(soll[1][k]))) #using convert(Expr,x) leads to ugly expressions

                        push!(atoms_in_equations_list, Set(Symbol.(soll[1][k].atoms())))
                        # push!(atoms_in_equations_list, Set(Symbol.(soll[vars].atoms()))) # to be fixed
                        push!(SS_solve_func,:($(ùìÇ.solved_vars[end]) = $(ùìÇ.solved_vals[end])))
                    end
                end


            end
                
            # try symbolically and use numerical if it does not work
            if numerical_sol || !symbolic_SS
                if !symbolic_SS && verbose
                    println("Solved: ",string.(eqs_to_solve)," for: ",Symbol.(vars_to_solve), " numerically.")
                end
                
                push!(ùìÇ.solved_vars,Symbol.(vars_to_solve))
                push!(ùìÇ.solved_vals,Meta.parse.(string.(eqs_to_solve)))

                syms_in_eqs = Set()

                for i in eqs_to_solve
                    # push!(syms_in_eqs, Symbol.(PythonCall.pystr.(i.atoms()))...)
                    push!(syms_in_eqs, Symbol.(SPyPyC.:‚Üì(SPyPyC.free_symbols(i)))...)
                end

                # println(syms_in_eqs)
                push!(atoms_in_equations_list,setdiff(syms_in_eqs, ùìÇ.solved_vars[end]))

                calib_pars = []
                calib_pars_input = []
                relevant_pars = reduce(union,vcat(ùìÇ.par_list_aux_SS,ùìÇ.par_calib_list)[eqs[:,eqs[2,:] .== n][1,:]])
                relevant_pars_across = union(relevant_pars_across,relevant_pars)
                
                iii = 1
                for parss in union(ùìÇ.parameters,ùìÇ.parameters_as_function_of_parameters)
                    # valss   = ùìÇ.parameter_values[i]
                    if :($parss) ‚àà relevant_pars
                        push!(calib_pars,:($parss = parameters_and_solved_vars[$iii]))
                        push!(calib_pars_input,:($parss))
                        iii += 1
                    end
                end


                guess = []
                result = []
                sorted_vars = sort(ùìÇ.solved_vars[end])
                # sorted_vars = sort(setdiff(ùìÇ.solved_vars[end],ùìÇ.‚ûï_vars))
                for (i, parss) in enumerate(sorted_vars) 
                    push!(guess,:($parss = guess[$i]))
                    # push!(guess,:($parss = undo_transformer(guess[$i])))
                    push!(result,:($parss = sol[$i]))
                end

                
                # separate out auxilliary variables (nonnegativity)
                nnaux = []
                nnaux_linear = []
                nnaux_error = []
                push!(nnaux_error, :(aux_error = 0))
                solved_vals = []
                
                eq_idx_in_block_to_solve = eqs[:,eqs[2,:] .== n][1,:]


                other_vrs_eliminated_by_sympy = Set()

                for (i,val) in enumerate(ùìÇ.solved_vals[end])
                    if typeof(val) ‚àà [Symbol,Float64,Int]
                        push!(solved_vals,val)
                    else
                        if eq_idx_in_block_to_solve[i] ‚àà ùìÇ.ss_equations_with_aux_variables
                            val = vcat(ùìÇ.ss_aux_equations,ùìÇ.calibration_equations)[eq_idx_in_block_to_solve[i]]
                            push!(nnaux,:($(val.args[2]) = max(eps(),$(val.args[3]))))
                            push!(other_vrs_eliminated_by_sympy, val.args[2])
                            push!(nnaux_linear,:($val))
                            push!(nnaux_error, :(aux_error += min(eps(),$(val.args[3]))))
                        else
                            push!(solved_vals,postwalk(x -> x isa Expr ? x.args[1] == :conjugate ? x.args[2] : x : x, val))
                        end
                    end
                end

                # println(other_vrs_eliminated_by_sympy)
                # sort nnaux vars so that they enter in right order. avoid using a variable before it is declared
                # println(nnaux)
                if length(nnaux) > 1
                    all_symbols = map(x->x.args[1],nnaux) #relevant symbols come first in respective equations

                    nn_symbols = map(x->intersect(all_symbols,x), get_symbols.(nnaux))
                    
                    inc_matrix = fill(0,length(all_symbols),length(all_symbols))

                    for i in 1:length(all_symbols)
                        for k in 1:length(nn_symbols)
                            inc_matrix[i,k] = collect(all_symbols)[i] ‚àà collect(nn_symbols)[k]
                        end
                    end

                    QQ, P, R, nmatch, n_blocks = BlockTriangularForm.order(sparse(inc_matrix))

                    nnaux = nnaux[QQ]
                    nnaux_linear = nnaux_linear[QQ]
                end



                other_vars = []
                other_vars_input = []
                # other_vars_inverse = []
                other_vrs = intersect( setdiff( union(ùìÇ.var, ùìÇ.calibration_equations_parameters, ùìÇ.‚ûï_vars),
                                                    sort(ùìÇ.solved_vars[end]) ),
                                        union(syms_in_eqs, other_vrs_eliminated_by_sympy, setdiff(reduce(union, get_symbols.(nnaux), init = []), map(x->x.args[1],nnaux)) ) )

                # println(intersect( setdiff( union(ùìÇ.var, ùìÇ.calibration_equations_parameters, ùìÇ.‚ûï_vars), sort(ùìÇ.solved_vars[end]) ), union(syms_in_eqs, other_vrs_eliminated_by_sympy ) ))
                # println(other_vrs)
                for var in other_vrs
                    # var_idx = findfirst(x -> x == var, union(ùìÇ.var,ùìÇ.calibration_equations_parameters))
                    push!(other_vars,:($(var) = parameters_and_solved_vars[$iii]))
                    push!(other_vars_input,:($(var)))
                    iii += 1
                    # push!(other_vars_inverse,:(ùìÇ.SS_init_guess[$var_idx] = $(var)))
                end

                # augment system for bound constraint violations
                # aug_lag = []
                # aug_lag_penalty = []
                # push!(aug_lag_penalty, :(bound_violation_penalty = 0))

                # for varpar in intersect(ùìÇ.bounded_vars,union(other_vrs,sorted_vars,relevant_pars))
                #     i = indexin([varpar],ùìÇ.bounded_vars)
                #     push!(aug_lag,:($varpar = min(max($varpar,$(ùìÇ.lower_bounds[i...])),$(ùìÇ.upper_bounds[i...]))))
                #     push!(aug_lag_penalty,:(bound_violation_penalty += max(0,$(ùìÇ.lower_bounds[i...]) - $varpar) + max(0,$varpar - $(ùìÇ.upper_bounds[i...]))))
                # end


                # add it also to output from optimisation, in case you use optimiser without bounds
                # aug_lag_results = []

                # for varpar in intersect(ùìÇ.bounded_vars,sorted_vars)
                #     i = indexin([varpar],ùìÇ.bounded_vars)
                #     push!(aug_lag_results,:($varpar = min(max($varpar,ùìÇ.lower_bounds[$i...]),ùìÇ.upper_bounds[$i...])))
                # end

                # funcs_no_transform = :(function block(parameters_and_solved_vars::Vector{Float64}, guess::Vector{Float64})
                #         # if guess isa Tuple guess = guess[1] end
                #         # guess = undo_transformer(guess) 
                #         # println(guess)
                #         $(guess...) 
                #         $(calib_pars...) # add those variables which were previously solved and are used in the equations
                #         $(other_vars...) # take only those that appear in equations - DONE

                #         # $(aug_lag...)
                #         # $(nnaux_linear...)
                #         return [$(solved_vals...),$(nnaux_linear...)]
                #     end)

# println(solved_vals)
                funcs = :(function block(parameters_and_solved_vars::Vector, guess::Vector)
                        # if guess isa Tuple guess = guess[1] end
                        # guess = undo_transformer(guess,lbs,ubs, option = transformer_option) 
                        # println(guess)
                        $(guess...) 
                        $(calib_pars...) # add those variables which were previously solved and are used in the equations
                        $(other_vars...) # take only those that appear in equations - DONE

                        # $(aug_lag...)
                        # $(nnaux...)
                        # $(nnaux_linear...)
                        return [$(solved_vals...),$(nnaux_linear...)]
                    end)

                # push!(solved_vals,:(aux_error))
                # push!(solved_vals,:(bound_violation_penalty))

                #funcs_optim = :(function block(guess::Vector{Float64},transformer_parameters_and_solved_vars::Tuple{Vector{Float64},Int})
                    #guess = undo_transformer(guess,option = transformer_parameters_and_solved_vars[2])
                    #parameters_and_solved_vars = transformer_parameters_and_solved_vars[1]
                #  $(guess...) 
                # $(calib_pars...) # add those variables which were previously solved and are used in the equations
                #   $(other_vars...) # take only those that appear in equations - DONE

                    # $(aug_lag_penalty...)
                    # $(aug_lag...)
                    # $(nnaux...) # not needed because the aux vars are inputs
                    # $(nnaux_error...)
                    #return sum(abs2,[$(solved_vals...),$(nnaux_linear...)])
                #end)
            
                push!(NSSS_solver_cache_init_tmp,fill(0.897,length(sorted_vars)))

                # WARNING: infinite bounds are transformed to 1e12
                lbs = []
                ubs = []
                
                limit_boundaries = 1e12

                for i in sorted_vars
                    if i ‚àà ùìÇ.bounded_vars
                        push!(lbs,ùìÇ.lower_bounds[i .== ùìÇ.bounded_vars][1] == -Inf ? -limit_boundaries+rand() : ùìÇ.lower_bounds[i .== ùìÇ.bounded_vars][1])
                        push!(ubs,ùìÇ.upper_bounds[i .== ùìÇ.bounded_vars][1] ==  Inf ?  limit_boundaries-rand() : ùìÇ.upper_bounds[i .== ùìÇ.bounded_vars][1])
                    else
                        push!(lbs,-limit_boundaries+rand())
                        push!(ubs,limit_boundaries+rand())
                    end
                end
                push!(SS_solve_func,:(lbs = [$(lbs...)]))
                push!(SS_solve_func,:(ubs = [$(ubs...)]))
                # push!(SS_solve_func,:(ùìÇ.SS_init_guess = initial_guess))
                # push!(SS_solve_func,:(f = OptimizationFunction(ùìÇ.ss_solve_blocks_optim[$(n_block)], Optimization.AutoForwardDiff())))
                # push!(SS_solve_func,:(inits = max.(lbs,min.(ubs,ùìÇ.SS_init_guess[$([findfirst(x->x==y,union(ùìÇ.var,ùìÇ.calibration_equations_parameters)) for y in sorted_vars])]))))
                # push!(SS_solve_func,:(closest_solution = ùìÇ.NSSS_solver_cache[findmin([sum(abs2,pars[end] - params_flt) for pars in ùìÇ.NSSS_solver_cache])[2]]))
                # push!(SS_solve_func,:(inits = [transformer(max.(lbs,min.(ubs, closest_solution[$(n_block)] ))),closest_solution[end]]))
                push!(SS_solve_func,:(inits = max.(lbs,min.(ubs, closest_solution[$(n_block)]))))

                # push!(SS_solve_func,:(println([$(calib_pars_input...),$(other_vars_input...)])))

                if VERSION >= v"1.9"
                    push!(SS_solve_func,:(block_solver_AD = ID.ImplicitFunction(block_solver, ùìÇ.ss_solve_blocks[$(n_block)]; linear_solver = ID.DirectLinearSolver(), conditions_backend = AD.ForwardDiffBackend())))
                else
                    push!(SS_solve_func,:(block_solver_AD = ID.ImplicitFunction(block_solver, ùìÇ.ss_solve_blocks[$(n_block)]; linear_solver = ID.DirectLinearSolver())))
                end

                push!(SS_solve_func,:(solution = block_solver_AD([$(calib_pars_input...),$(other_vars_input...)],
                                                                        $(n_block), 
                                                                        ùìÇ.ss_solve_blocks[$(n_block)], 
                                                                        # ùìÇ.ss_solve_blocks_no_transform[$(n_block)], 
                                                                        # f, 
                                                                        inits,
                                                                        lbs, 
                                                                        ubs,
                                                                        solver_parameters,
                                                                        # fail_fast_solvers_only = fail_fast_solvers_only,
                                                                        cold_start,
                                                                        verbose)))
                
                # push!(SS_solve_func,:(solution = block_solver_RD([$(calib_pars_input...),$(other_vars_input...)])))#, 
                        # $(n_block), 
                        # ùìÇ.ss_solve_blocks[$(n_block)], 
                        # # ùìÇ.SS_optimizer, 
                        # f, 
                        # inits,
                        # lbs, 
                        # ubs,
                        # fail_fast_solvers_only = fail_fast_solvers_only,
                        # verbose = verbose)))
                push!(SS_solve_func,:(iters += solution[2][2])) 
                push!(SS_solve_func,:(solution_error += solution[2][1])) 
                push!(SS_solve_func,:(sol = solution[1]))
                # push!(SS_solve_func,:(solution_error += sum(abs2,ùìÇ.ss_solve_blocks[$(n_block)]([$(calib_pars_input...),$(other_vars_input...)],solution))))
                # push!(SS_solve_func,:(sol = solution))

                # push!(SS_solve_func,:(println(sol))) 

                push!(SS_solve_func,:($(result...)))   
                # push!(SS_solve_func,:($(aug_lag_results...))) 

                # push!(SS_solve_func,:(NSSS_solver_cache_tmp = []))
                # push!(SS_solve_func,:(push!(NSSS_solver_cache_tmp, typeof(sol) == Vector{Float64} ? sol : ‚Ñ±.value.(sol))))
                push!(SS_solve_func,:(NSSS_solver_cache_tmp = [NSSS_solver_cache_tmp..., typeof(sol) == Vector{Float64} ? sol : ‚Ñ±.value.(sol)]))

                push!(ùìÇ.ss_solve_blocks,@RuntimeGeneratedFunction(funcs))
                # push!(ùìÇ.ss_solve_blocks_no_transform,@RuntimeGeneratedFunction(funcs_no_transform))
                # push!(ùìÇ.ss_solve_blocks_optim,@RuntimeGeneratedFunction(funcs_optim))
                
                n_block += 1
            end
        end
        n -= 1
    end

    push!(NSSS_solver_cache_init_tmp,fill(Inf,length(ùìÇ.parameters)))
    push!(ùìÇ.NSSS_solver_cache,NSSS_solver_cache_init_tmp)

    unknwns = Symbol.(collect(unknowns))

    parameters_only_in_par_defs = Set()
    # add parameters from parameter definitions
    if length(ùìÇ.calibration_equations_no_var) > 0
		atoms = reduce(union,get_symbols.(ùìÇ.calibration_equations_no_var))
	    [push!(atoms_in_equations, a) for a in atoms]
	    [push!(parameters_only_in_par_defs, a) for a in atoms]
	end
    
    # ùìÇ.par = union(ùìÇ.par,setdiff(parameters_only_in_par_defs,ùìÇ.parameters_as_function_of_parameters))
    
    parameters_in_equations = []

    for (i, parss) in enumerate(ùìÇ.parameters) 
        if parss ‚àà union(atoms_in_equations, relevant_pars_across)
            push!(parameters_in_equations,:($parss = params[$i]))
        end
    end
    
    dependencies = []
    for (i, a) in enumerate(atoms_in_equations_list)
        push!(dependencies,ùìÇ.solved_vars[i] => intersect(a, union(ùìÇ.var,ùìÇ.parameters)))
    end

    push!(dependencies,:SS_relevant_calibration_parameters => intersect(reduce(union,atoms_in_equations_list),ùìÇ.parameters))

    ùìÇ.SS_dependencies = dependencies
    

    
    dyn_exos = []
    for dex in union(ùìÇ.exo_past,ùìÇ.exo_future)
        push!(dyn_exos,:($dex = 0))
    end

    push!(SS_solve_func,:($(dyn_exos...)))
    
    push!(SS_solve_func, min_max_errors...)
    # push!(SS_solve_func,:(push!(NSSS_solver_cache_tmp, params_scaled_flt)))
    push!(SS_solve_func,:(if length(NSSS_solver_cache_tmp) == 0 NSSS_solver_cache_tmp = [params_scaled_flt] else NSSS_solver_cache_tmp = [NSSS_solver_cache_tmp...,params_scaled_flt] end))
    
    push!(SS_solve_func,:(current_best = sqrt(sum(abs2,ùìÇ.NSSS_solver_cache[end][end] - params_flt))))# / max(sum(abs2,ùìÇ.NSSS_solver_cache[end][end]), sum(abs2,params_flt))))

    push!(SS_solve_func,:(for pars in ùìÇ.NSSS_solver_cache
                                latest = sqrt(sum(abs2,pars[end] - params_flt))# / max(sum(abs2,pars[end]), sum(abs,params_flt))
                                if latest <= current_best
                                    current_best = latest
                                end
                            end))

    push!(SS_solve_func,:(if (current_best > 1e-5) && (solution_error < eps(Float64))
                                reverse_diff_friendly_push!(ùìÇ.NSSS_solver_cache, NSSS_solver_cache_tmp)
                                solved_scale = scale
                            end))
    # push!(SS_solve_func,:(if length(ùìÇ.NSSS_solver_cache) > 100 popfirst!(ùìÇ.NSSS_solver_cache) end))
    
    # push!(SS_solve_func,:(SS_init_guess = ([$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...), $(ùìÇ.calibration_equations_parameters...)])))

    # push!(SS_solve_func,:(ùìÇ.SS_init_guess = typeof(SS_init_guess) == Vector{Float64} ? SS_init_guess : ‚Ñ±.value.(SS_init_guess)))

    # push!(SS_solve_func,:(return ComponentVector([$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...), $(ùìÇ.calibration_equations_parameters...)], Axis([sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...]))))


    # fix parameter bounds
    par_bounds = []
    
    for varpar in intersect(ùìÇ.bounded_vars, intersect(ùìÇ.parameters,union(atoms_in_equations, relevant_pars_across)))
        i = indexin([varpar],ùìÇ.bounded_vars)
        push!(par_bounds, :($varpar = min(max($varpar,$(ùìÇ.lower_bounds[i...])),$(ùìÇ.upper_bounds[i...]))))
    end


    solve_exp = :(function solve_SS(parameters::Vector{Real}, 
                                    ùìÇ::‚Ñ≥,
                                    # fail_fast_solvers_only::Bool, 
                                    verbose::Bool, 
                                    cold_start::Union{Bool,Float64},
                                    solver_parameters::solver_parameters)

                    params_flt = typeof(parameters) == Vector{Float64} ? parameters : ‚Ñ±.value.(parameters)
                    current_best = sum(abs2,ùìÇ.NSSS_solver_cache[end][end] - params_flt)
                    closest_solution_init = ùìÇ.NSSS_solver_cache[end]
                    for pars in ùìÇ.NSSS_solver_cache
                        latest = sum(abs2,pars[end] - params_flt)
                        if latest <= current_best
                            current_best = latest
                            closest_solution_init = pars
                        end
                    end
                    solved_scale = 0
                    range_length = [1]#fail_fast_solvers_only ? [1] : [ 1, 2, 4, 8,16,32]
                    for r in range_length
                        rangee = ignore_derivatives(range(0,1,r+1))
                        for scale in rangee[2:end]
                            if scale <= solved_scale continue end
                            current_best = sum(abs2,ùìÇ.NSSS_solver_cache[end][end] - params_flt)
                            closest_solution = ùìÇ.NSSS_solver_cache[end]
                            for pars in ùìÇ.NSSS_solver_cache
                                latest = sum(abs2,pars[end] - params_flt)
                                if latest <= current_best
                                    current_best = latest
                                    closest_solution = pars
                                end
                            end
                            params = all(isfinite.(closest_solution_init[end])) && parameters != closest_solution_init[end] ? scale * parameters + (1 - scale) * closest_solution_init[end] : parameters
                            params_scaled_flt = typeof(params) == Vector{Float64} ? params : ‚Ñ±.value.(params)
                            $(parameters_in_equations...)
                            $(par_bounds...)
                            $(ùìÇ.calibration_equations_no_var...)
                            NSSS_solver_cache_tmp = []
                            solution_error = 0.0
                            iters = 0
                            $(SS_solve_func...)
                            if scale == 1
                                # return ComponentVector([$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...), $(ùìÇ.calibration_equations_parameters...)], Axis([sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...])), solution_error
                                # NSSS_solution = [$(Symbol.(replace.(string.(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))...), $(ùìÇ.calibration_equations_parameters...)]
                                # NSSS_solution[abs.(NSSS_solution) .< 1e-12] .= 0 # doesnt work with Zygote
                                return [$(Symbol.(replace.(string.(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))...), $(ùìÇ.calibration_equations_parameters...)], (solution_error, iters)
                            end
                        end
                    end
                end)

    ùìÇ.SS_solve_func = @RuntimeGeneratedFunction(solve_exp)
    # ùìÇ.SS_solve_func = eval(solve_exp)

    return nothing
end




function solve_steady_state!(ùìÇ::‚Ñ≥; verbose::Bool = false)
    unknowns = union(ùìÇ.vars_in_ss_equations, ùìÇ.calibration_equations_parameters)

    @assert length(unknowns) <= length(ùìÇ.ss_aux_equations) + length(ùìÇ.calibration_equations) "Unable to solve steady state. More unknowns than equations."

    incidence_matrix = fill(0,length(unknowns),length(unknowns))

    eq_list = vcat(union.(union.(ùìÇ.var_list_aux_SS,
                                        ùìÇ.ss_list_aux_SS),
                            ùìÇ.par_list_aux_SS),
                    union.(ùìÇ.ss_calib_list,
                            ùìÇ.par_calib_list))

    for i in 1:length(unknowns)
        for k in 1:length(unknowns)
            incidence_matrix[i,k] = collect(unknowns)[i] ‚àà collect(eq_list)[k]
        end
    end

    Q, P, R, nmatch, n_blocks = BlockTriangularForm.order(sparse(incidence_matrix))
    RÃÇ = []
    for i in 1:n_blocks
        [push!(RÃÇ, n_blocks - i + 1) for ii in R[i]:R[i+1] - 1]
    end
    push!(RÃÇ,1)

    vars = hcat(P, RÃÇ)'
    eqs = hcat(Q, RÃÇ)'

    # @assert all(eqs[1,:] .> 0) "Could not solve system of steady state and calibration equations for: " * repr([collect(Symbol.(unknowns))[vars[1,eqs[1,:] .< 0]]...]) # repr([vcat(ùìÇ.ss_equations,ùìÇ.calibration_equations)[-eqs[1,eqs[1,:].<0]]...])
    @assert all(eqs[1,:] .> 0) "Could not solve system of steady state and calibration equations. Number of redundant euqations: " * repr(sum(eqs[1,:] .< 0)) * ". Try defining some steady state values as parameters (e.g. r[ss] -> rÃÑ). Nonstationary variables are not supported as of now." # repr([vcat(ùìÇ.ss_equations,ùìÇ.calibration_equations)[-eqs[1,eqs[1,:].<0]]...])
    
    n = n_blocks

    ss_equations = vcat(ùìÇ.ss_aux_equations,ùìÇ.calibration_equations)

    SS_solve_func = []

    atoms_in_equations = Set{Symbol}()
    atoms_in_equations_list = []
    relevant_pars_across = []
    NSSS_solver_cache_init_tmp = []

    n_block = 1

    while n > 0
        vars_to_solve = collect(unknowns)[vars[:,vars[2,:] .== n][1,:]]

        eqs_to_solve = ss_equations[eqs[:,eqs[2,:] .== n][1,:]]

        # try symbolically and use numerical if it does not work
        if verbose
            println("Solved: ",string.(eqs_to_solve)," for: ",Symbol.(vars_to_solve), " numerically.")
        end
        
        push!(ùìÇ.solved_vars,Symbol.(vars_to_solve))
        push!(ùìÇ.solved_vals,Meta.parse.(string.(eqs_to_solve)))

        syms_in_eqs = Set()

        for i in eqs_to_solve
            push!(syms_in_eqs, get_symbols(i)...)
        end

        # println(syms_in_eqs)
        push!(atoms_in_equations_list,setdiff(syms_in_eqs, ùìÇ.solved_vars[end]))

        calib_pars = []
        calib_pars_input = []
        relevant_pars = reduce(union,vcat(ùìÇ.par_list_aux_SS,ùìÇ.par_calib_list)[eqs[:,eqs[2,:] .== n][1,:]])
        relevant_pars_across = union(relevant_pars_across,relevant_pars)
        
        iii = 1
        for parss in union(ùìÇ.parameters,ùìÇ.parameters_as_function_of_parameters)
            # valss   = ùìÇ.parameter_values[i]
            if :($parss) ‚àà relevant_pars
                push!(calib_pars,:($parss = parameters_and_solved_vars[$iii]))
                push!(calib_pars_input,:($parss))
                iii += 1
            end
        end


        guess = []
        result = []
        sorted_vars = sort(ùìÇ.solved_vars[end])
        # sorted_vars = sort(setdiff(ùìÇ.solved_vars[end],ùìÇ.‚ûï_vars))
        for (i, parss) in enumerate(sorted_vars) 
            push!(guess,:($parss = guess[$i]))
            # push!(guess,:($parss = undo_transformer(guess[$i])))
            push!(result,:($parss = sol[$i]))
        end

        
        # separate out auxilliary variables (nonnegativity)
        nnaux = []
        nnaux_linear = []
        nnaux_error = []
        push!(nnaux_error, :(aux_error = 0))
        solved_vals = []
        
        eq_idx_in_block_to_solve = eqs[:,eqs[2,:] .== n][1,:]


        other_vrs_eliminated_by_sympy = Set()

        for (i,val) in enumerate(ùìÇ.solved_vals[end])
            if typeof(val) ‚àà [Symbol,Float64,Int]
                push!(solved_vals,val)
            else
                if eq_idx_in_block_to_solve[i] ‚àà ùìÇ.ss_equations_with_aux_variables
                    val = vcat(ùìÇ.ss_aux_equations,ùìÇ.calibration_equations)[eq_idx_in_block_to_solve[i]]
                    push!(nnaux,:($(val.args[2]) = max(eps(),$(val.args[3]))))
                    push!(other_vrs_eliminated_by_sympy, val.args[2])
                    push!(nnaux_linear,:($val))
                    push!(nnaux_error, :(aux_error += min(eps(),$(val.args[3]))))
                else
                    push!(solved_vals,postwalk(x -> x isa Expr ? x.args[1] == :conjugate ? x.args[2] : x : x, val))
                end
            end
        end

        # println(other_vrs_eliminated_by_sympy)
        # sort nnaux vars so that they enter in right order. avoid using a variable before it is declared
        # println(nnaux)
        if length(nnaux) > 1
            all_symbols = map(x->x.args[1],nnaux) #relevant symbols come first in respective equations

            nn_symbols = map(x->intersect(all_symbols,x), get_symbols.(nnaux))
            
            inc_matrix = fill(0,length(all_symbols),length(all_symbols))

            for i in 1:length(all_symbols)
                for k in 1:length(nn_symbols)
                    inc_matrix[i,k] = collect(all_symbols)[i] ‚àà collect(nn_symbols)[k]
                end
            end

            QQ, P, R, nmatch, n_blocks = BlockTriangularForm.order(sparse(inc_matrix))

            nnaux = nnaux[QQ]
            nnaux_linear = nnaux_linear[QQ]
        end


        other_vars = []
        other_vars_input = []
        # other_vars_inverse = []
        other_vrs = intersect( setdiff( union(ùìÇ.var, ùìÇ.calibration_equations_parameters, ùìÇ.‚ûï_vars),
                                            sort(ùìÇ.solved_vars[end]) ),
                                union(syms_in_eqs, other_vrs_eliminated_by_sympy, setdiff(reduce(union, get_symbols.(nnaux), init = []), map(x->x.args[1],nnaux)) ) )
                  
        for var in other_vrs
            # var_idx = findfirst(x -> x == var, union(ùìÇ.var,ùìÇ.calibration_equations_parameters))
            push!(other_vars,:($(var) = parameters_and_solved_vars[$iii]))
            push!(other_vars_input,:($(var)))
            iii += 1
            # push!(other_vars_inverse,:(ùìÇ.SS_init_guess[$var_idx] = $(var)))
        end

        funcs = :(function block(parameters_and_solved_vars::Vector, guess::Vector)
                # if guess isa Tuple guess = guess[1] end
                # guess = undo_transformer(guess,lbs,ubs, option = transformer_option) 
                # println(guess)
                $(guess...) 
                $(calib_pars...) # add those variables which were previously solved and are used in the equations
                $(other_vars...) # take only those that appear in equations - DONE

                # $(aug_lag...)
                # $(nnaux...)
                # $(nnaux_linear...)
                return [$(solved_vals...),$(nnaux_linear...)]
            end)

        push!(NSSS_solver_cache_init_tmp,fill(0.897,length(sorted_vars)))

        # WARNING: infinite bounds are transformed to 1e12
        lbs = []
        ubs = []
        
        limit_boundaries = 1e12

        for i in sorted_vars
            if i ‚àà ùìÇ.bounded_vars
                push!(lbs,ùìÇ.lower_bounds[i .== ùìÇ.bounded_vars][1] == -Inf ? -limit_boundaries+rand() : ùìÇ.lower_bounds[i .== ùìÇ.bounded_vars][1])
                push!(ubs,ùìÇ.upper_bounds[i .== ùìÇ.bounded_vars][1] ==  Inf ?  limit_boundaries-rand() : ùìÇ.upper_bounds[i .== ùìÇ.bounded_vars][1])
            else
                push!(lbs,-limit_boundaries+rand())
                push!(ubs,limit_boundaries+rand())
            end
        end
        push!(SS_solve_func,:(lbs = [$(lbs...)]))
        push!(SS_solve_func,:(ubs = [$(ubs...)]))
        
        push!(SS_solve_func,:(inits = max.(lbs,min.(ubs, closest_solution[$(n_block)]))))

        if VERSION >= v"1.9"
            push!(SS_solve_func,:(block_solver_AD = ID.ImplicitFunction(block_solver, ùìÇ.ss_solve_blocks[$(n_block)]; linear_solver = ID.DirectLinearSolver(), conditions_backend = AD.ForwardDiffBackend())))
        else
            push!(SS_solve_func,:(block_solver_AD = ID.ImplicitFunction(block_solver, ùìÇ.ss_solve_blocks[$(n_block)]; linear_solver = ID.DirectLinearSolver())))
        end

        push!(SS_solve_func,:(solution = block_solver_AD(length([$(calib_pars_input...),$(other_vars_input...)]) == 0 ? [0.0] : [$(calib_pars_input...),$(other_vars_input...)],
                                                                $(n_block), 
                                                                ùìÇ.ss_solve_blocks[$(n_block)], 
                                                                # ùìÇ.ss_solve_blocks_no_transform[$(n_block)], 
                                                                # f, 
                                                                inits,
                                                                lbs, 
                                                                ubs,
                                                                solver_parameters,
                                                                cold_start,
                                                                # fail_fast_solvers_only = fail_fast_solvers_only,
                                                                verbose)))
        
        # push!(SS_solve_func,:(solution = block_solver_RD(length([$(calib_pars_input...),$(other_vars_input...)]) == 0 ? [0.0] : [$(calib_pars_input...),$(other_vars_input...)])))#, 
        
        push!(SS_solve_func,:(iters += solution[2][2])) 
        push!(SS_solve_func,:(solution_error += solution[2][1])) 
        push!(SS_solve_func,:(sol = solution[1]))

        # push!(SS_solve_func,:(solution = block_solver_RD(length([$(calib_pars_input...),$(other_vars_input...)]) == 0 ? [0.0] : [$(calib_pars_input...),$(other_vars_input...)])))#, 
        
        # push!(SS_solve_func,:(solution_error += sum(abs2,ùìÇ.ss_solve_blocks[$(n_block)](length([$(calib_pars_input...),$(other_vars_input...)]) == 0 ? [0.0] : [$(calib_pars_input...),$(other_vars_input...)],solution))))

        push!(SS_solve_func,:($(result...)))   
        
        push!(SS_solve_func,:(NSSS_solver_cache_tmp = [NSSS_solver_cache_tmp..., typeof(sol) == Vector{Float64} ? sol : ‚Ñ±.value.(sol)]))

        push!(ùìÇ.ss_solve_blocks,@RuntimeGeneratedFunction(funcs))
        
        n_block += 1
        
        n -= 1
    end

    push!(NSSS_solver_cache_init_tmp,fill(Inf,length(ùìÇ.parameters)))
    push!(ùìÇ.NSSS_solver_cache,NSSS_solver_cache_init_tmp)

    unknwns = Symbol.(collect(unknowns))

    parameters_only_in_par_defs = Set()
    # add parameters from parameter definitions
    if length(ùìÇ.calibration_equations_no_var) > 0
		atoms = reduce(union,get_symbols.(ùìÇ.calibration_equations_no_var))
	    [push!(atoms_in_equations, a) for a in atoms]
	    [push!(parameters_only_in_par_defs, a) for a in atoms]
	end
    
    # ùìÇ.par = union(ùìÇ.par,setdiff(parameters_only_in_par_defs,ùìÇ.parameters_as_function_of_parameters))
    
    parameters_in_equations = []

    for (i, parss) in enumerate(ùìÇ.parameters) 
        if parss ‚àà union(atoms_in_equations, relevant_pars_across)
            push!(parameters_in_equations,:($parss = params[$i]))
        end
    end
    
    dependencies = []
    for (i, a) in enumerate(atoms_in_equations_list)
        push!(dependencies,ùìÇ.solved_vars[i] => intersect(a, union(ùìÇ.var,ùìÇ.parameters)))
    end

    push!(dependencies,:SS_relevant_calibration_parameters => intersect(reduce(union,atoms_in_equations_list),ùìÇ.parameters))

    ùìÇ.SS_dependencies = dependencies

    
    dyn_exos = []
    for dex in union(ùìÇ.exo_past,ùìÇ.exo_future)
        push!(dyn_exos,:($dex = 0))
    end

    push!(SS_solve_func,:($(dyn_exos...)))

    # push!(SS_solve_func,:(push!(NSSS_solver_cache_tmp, params_scaled_flt)))
    push!(SS_solve_func,:(if length(NSSS_solver_cache_tmp) == 0 NSSS_solver_cache_tmp = [params_scaled_flt] else NSSS_solver_cache_tmp = [NSSS_solver_cache_tmp...,params_scaled_flt] end))
    
    push!(SS_solve_func,:(current_best = sqrt(sum(abs2,ùìÇ.NSSS_solver_cache[end][end] - params_flt))))# / max(sum(abs2,ùìÇ.NSSS_solver_cache[end][end]), sum(abs2,params_flt))))

    push!(SS_solve_func,:(for pars in ùìÇ.NSSS_solver_cache
                                latest = sqrt(sum(abs2,pars[end] - params_flt))# / max(sum(abs2,pars[end]), sum(abs,params_flt))
                                if latest <= current_best
                                    current_best = latest
                                end
                            end))

    push!(SS_solve_func,:(if (current_best > 1e-5) && (solution_error < eps(Float64))
                                reverse_diff_friendly_push!(ùìÇ.NSSS_solver_cache, NSSS_solver_cache_tmp)
                                solved_scale = scale
                            end))

    # fix parameter bounds
    par_bounds = []
    
    for varpar in intersect(ùìÇ.bounded_vars, intersect(ùìÇ.parameters,union(atoms_in_equations, relevant_pars_across)))
        i = indexin([varpar],ùìÇ.bounded_vars)
        push!(par_bounds, :($varpar = min(max($varpar,$(ùìÇ.lower_bounds[i...])),$(ùìÇ.upper_bounds[i...]))))
    end


    solve_exp = :(function solve_SS(parameters::Vector{Real}, 
                                    ùìÇ::‚Ñ≥, 
                                    # fail_fast_solvers_only::Bool, 
                                    verbose::Bool, 
                                    cold_start::Union{Bool,Float64},
                                    solver_parameters::solver_parameters)

                    params_flt = typeof(parameters) == Vector{Float64} ? parameters : ‚Ñ±.value.(parameters)
                    current_best = sum(abs2,ùìÇ.NSSS_solver_cache[end][end] - params_flt)
                    closest_solution_init = ùìÇ.NSSS_solver_cache[end]
                    for pars in ùìÇ.NSSS_solver_cache
                        latest = sum(abs2,pars[end] - params_flt)
                        if latest <= current_best
                            current_best = latest
                            closest_solution_init = pars
                        end
                    end
                    solved_scale = 0
                    range_length = [1]#fail_fast_solvers_only ? [1] : [ 1, 2, 4, 8,16,32]
                    for r in range_length
                        rangee = ignore_derivatives(range(0,1,r+1))
                        for scale in rangee[2:end]
                            if scale <= solved_scale continue end
                            current_best = sum(abs2,ùìÇ.NSSS_solver_cache[end][end] - params_flt)
                            closest_solution = ùìÇ.NSSS_solver_cache[end]
                            for pars in ùìÇ.NSSS_solver_cache
                                latest = sum(abs2,pars[end] - params_flt)
                                if latest <= current_best
                                    current_best = latest
                                    closest_solution = pars
                                end
                            end
                            params = all(isfinite.(closest_solution_init[end])) && parameters != closest_solution_init[end] ? scale * parameters + (1 - scale) * closest_solution_init[end] : parameters
                            params_scaled_flt = typeof(params) == Vector{Float64} ? params : ‚Ñ±.value.(params)
                            $(parameters_in_equations...)
                            $(par_bounds...)
                            $(ùìÇ.calibration_equations_no_var...)
                            NSSS_solver_cache_tmp = []
                            iters = 0
                            solution_error = 0.0
                            $(SS_solve_func...)
                            if scale == 1
                                # return ComponentVector([$(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))...), $(ùìÇ.calibration_equations_parameters...)], Axis([sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...])), solution_error
                                return [$(Symbol.(replace.(string.(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))...), $(ùìÇ.calibration_equations_parameters...)] , (solution_error, iters)
                            end
                        end
                    end
                end)

    ùìÇ.SS_solve_func = @RuntimeGeneratedFunction(solve_exp)
    # ùìÇ.SS_solve_func = eval(solve_exp)

    return nothing
end


function reverse_diff_friendly_push!(x,y)
    @ignore_derivatives push!(x,y)
end


function block_solver(parameters_and_solved_vars::Vector{Float64}, 
                        n_block::Int, 
                        ss_solve_blocks::Function, 
                        # SS_optimizer, 
                        # f::OptimizationFunction, 
                        guess::Vector{Float64}, 
                        lbs::Vector{Float64}, 
                        ubs::Vector{Float64},
                        parameters::solver_parameters,
                        cold_start::Union{Bool,Float64},
                        verbose::Bool;
                        tol::AbstractFloat = eps(),
                        # timeout = 120,
                        starting_points::Vector{Float64} = [0.7688, 0.897, 1.2, .9, .75, 1.5, -.5, 2, .25]
                        # fail_fast_solvers_only = true,
                        # verbose::Bool = false
                        )
    
    if cold_start isa Float64
        sol_values = max.(lbs,min.(ubs, fill(cold_start,length(guess))))
        sol_minimum = 1
    elseif cold_start isa Bool 
        if cold_start
            sol_values = max.(lbs,min.(ubs, fill(0.0,length(guess))))
            sol_minimum  = sum(abs2,ss_solve_blocks(parameters_and_solved_vars,sol_values))
        else
            sol_values = guess
            sol_minimum  = sum(abs2,ss_solve_blocks(parameters_and_solved_vars,sol_values))
            iters = 0

            if verbose && sol_minimum < tol
                println("Block: ",n_block," - Solved using previous solution; maximum residual = ",maximum(abs,ss_solve_blocks(parameters_and_solved_vars, sol_values)))
            end
        end
    end

    # try modified LM to solve hard SS problems
    if (sol_minimum > tol)# | (maximum(abs,ss_solve_blocks(sol_values,parameters_and_solved_vars)) > tol))
        SS_optimizer = levenberg_marquardt

        previous_sol_init = max.(lbs,min.(ubs, sol_values))
        
        sol_new, info = SS_optimizer(
                                        x->ss_solve_blocks(parameters_and_solved_vars, x),
                                        previous_sol_init,
                                        lbs,
                                        ubs,
                                        parameters = parameters
                                    ) # alternatively use .001)#, Œº = Œº, p = p)# catch e end

        sol_minimum = isnan(sum(abs2,info[4])) ? Inf : sum(abs2,info[4])
        sol_values = max.(lbs,min.(ubs, sol_new ))
        iters = info[1]

        if sol_minimum < tol
            if verbose
                println("Block: ",n_block," - Solved using ",string(SS_optimizer)," and previous best non-converged solution; maximum residual = ",maximum(abs,ss_solve_blocks(parameters_and_solved_vars, sol_values)))
            end
        elseif cold_start isa Bool && !cold_start
            # if the previous non-converged best guess as a starting point does not work, try the standard starting points
            for starting_point in starting_points
                if sol_minimum > tol
                    standard_inits = max.(lbs,min.(ubs, fill(starting_point,length(guess))))
                    standard_inits[ubs .<= 1] .= .1 # capture cases where part of values is small

                    sol_new, info = SS_optimizer(
                        x->ss_solve_blocks(parameters_and_solved_vars, x),
                        standard_inits,
                        lbs,
                        ubs,
                        parameters = parameters
                        )# catch e end
                
                    sol_minimum = isnan(sum(abs2,info[4])) ? Inf : sum(abs2,info[4])
                    sol_values = max.(lbs,min.(ubs, sol_new))
                    iters = info[1]

                    if sol_minimum < tol && verbose
                        println("Block: ",n_block," - Solved using ",string(SS_optimizer)," and starting point: ",starting_point,"; maximum residual = ",maximum(abs,ss_solve_blocks(parameters_and_solved_vars, sol_values)))
                    end

                else 
                    break
                end
            end
        end
    end

    return sol_values, (sol_minimum, iters)
end

# needed for Julia 1.8
function block_solver(parameters_and_solved_vars::Vector{‚Ñ±.Dual{Z,S,N}}, 
    n_block::Int, 
    ss_solve_blocks::Function, 
    # SS_optimizer, 
    # f::OptimizationFunction, 
    guess::Vector{Float64}, 
    lbs::Vector{Float64}, 
    ubs::Vector{Float64},
    parameters::solver_parameters,
    cold_start::Union{Bool,Float64},
    verbose::Bool ;
    tol::AbstractFloat = eps(),
    # timeout = 120,
    starting_points::Vector{Float64} = [0.7688, 0.897, 1.2, .9, .75, 1.5, -.5, 2, .25]
    # fail_fast_solvers_only = true,
    # verbose::Bool = false
    ) where {Z,S,N}

    # unpack: AoS -> SoA
    inp = ‚Ñ±.value.(parameters_and_solved_vars)

    # you can play with the dimension here, sometimes it makes sense to transpose
    ps = mapreduce(‚Ñ±.partials, hcat, parameters_and_solved_vars)'

    if verbose println("Solution for derivatives.") end
    # get f(vs)
    val, (min, iter) = block_solver(inp, 
                        n_block, 
                        ss_solve_blocks, 
                        # SS_optimizer, 
                        # f, 
                        guess, 
                        lbs, 
                        ubs,
                        parameters,
                        cold_start,
                        verbose;
                        tol = tol,
                        # timeout = timeout,
                        starting_points = starting_points)

    if min > tol
        jvp = fill(0,length(val),length(inp)) * ps
    else
        # get J(f, vs) * ps (cheating). Write your custom rule here
        B = ‚Ñ±.jacobian(x -> ss_solve_blocks(x,val), inp)
        A = ‚Ñ±.jacobian(x -> ss_solve_blocks(inp,x), val)
        # B = Zygote.jacobian(x -> ss_solve_blocks(x,transformer(val, option = 0),0), inp)[1]
        # A = Zygote.jacobian(x -> ss_solve_blocks(inp,transformer(x, option = 0),0), val)[1]

        AÃÇ = RF.lu(A, check = false)

        if !‚Ñí.issuccess(AÃÇ)
            AÃÇ = ‚Ñí.svd(A)
        end
        
        jvp = -(AÃÇ \ B) * ps
    end

    # pack: SoA -> AoS
    return reshape(map(val, eachrow(jvp)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
    end, size(val)), (min, iter)
end



function second_order_stochastic_steady_state_iterative_solution_forward(ùêí‚ÇÅùêí‚ÇÇ::SparseVector{Float64};  dims::Vector{Tuple{Int,Int}},  ùìÇ::‚Ñ≥, tol::AbstractFloat = eps())
    lenùêí‚ÇÅ = dims[1][1] * dims[1][2]

    ùêí‚ÇÅ = reshape(ùêí‚ÇÅùêí‚ÇÇ[1 : lenùêí‚ÇÅ],dims[1])
    ùêí‚ÇÇ = sparse(reshape(ùêí‚ÇÅùêí‚ÇÇ[lenùêí‚ÇÅ + 1 : end],dims[2]))
        
    state = zeros(ùìÇ.timings.nVars)
    shock = zeros(ùìÇ.timings.nExo)

    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
    1
    shock]

    sol = speedmapping(state; 
                m! = (SSS, sss) -> begin 
                                    aug_state .= [sss[ùìÇ.timings.past_not_future_and_mixed_idx]
                                                1
                                                shock]

                                    SSS .= ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
                end, 
    tol = tol, maps_limit = 10000)
    
    return sol.minimizer, sol.converged
end


function second_order_stochastic_steady_state_iterative_solution_conditions(ùêí‚ÇÅùêí‚ÇÇ::SparseVector, SSS, converged::Bool; dims::Vector{Tuple{Int,Int}}, ùìÇ::‚Ñ≥, tol::AbstractFloat = eps())
    lenùêí‚ÇÅ = dims[1][1] * dims[1][2]

    ùêí‚ÇÅ = reshape(ùêí‚ÇÅùêí‚ÇÇ[1 : lenùêí‚ÇÅ],dims[1])
    ùêí‚ÇÇ = sparse(reshape(ùêí‚ÇÅùêí‚ÇÇ[lenùêí‚ÇÅ + 1 : end],dims[2]))

    shock = zeros(ùìÇ.timings.nExo)

    aug_state = [SSS[ùìÇ.timings.past_not_future_and_mixed_idx]
    1
    shock]

    return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 - SSS
end


function second_order_stochastic_steady_state_iterative_solution_forward(ùêí‚ÇÅùêí‚ÇÇ::SparseVector{‚Ñ±.Dual{Z,S,N}}; dims::Vector{Tuple{Int,Int}}, ùìÇ::‚Ñ≥, tol::AbstractFloat = eps()) where {Z,S,N}
    S‚ÇÅS‚ÇÇ, ps = separate_values_and_partials_from_sparsevec_dual(ùêí‚ÇÅùêí‚ÇÇ)

    # get f(vs)
    val, converged = second_order_stochastic_steady_state_iterative_solution_forward(S‚ÇÅS‚ÇÇ; dims = dims, ùìÇ = ùìÇ, tol = tol)

    if converged
        # get J(f, vs) * ps (cheating). Write your custom rule here
        B = ‚Ñ±.jacobian(x -> second_order_stochastic_steady_state_iterative_solution_conditions(x, val, converged; dims = dims, ùìÇ = ùìÇ, tol = tol), S‚ÇÅS‚ÇÇ)
        A = ‚Ñ±.jacobian(x -> second_order_stochastic_steady_state_iterative_solution_conditions(S‚ÇÅS‚ÇÇ, x, converged; dims = dims, ùìÇ = ùìÇ, tol = tol), val)

        AÃÇ = RF.lu(A, check = false)

        if !‚Ñí.issuccess(AÃÇ)
            AÃÇ = ‚Ñí.svd(A)
        end
        
        jvp = -(AÃÇ \ B) * ps
    else
        jvp = fill(0,length(val),length(ùêí‚ÇÅùêí‚ÇÇ)) * ps
    end

    # lm = LinearMap{Float64}(x -> A * reshape(x, size(B)), length(B))

    # jvp = - sparse(reshape(‚Ñê.gmres(lm, sparsevec(B)), size(B))) * ps
    # jvp *= -ps

    # pack: SoA -> AoS
    return reshape(map(val, eachrow(jvp)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
    end,size(val)), converged
end


second_order_stochastic_steady_state_iterative_solution = ID.ImplicitFunction(second_order_stochastic_steady_state_iterative_solution_forward,
                                                                                    second_order_stochastic_steady_state_iterative_solution_conditions; 
                                                                                    linear_solver = ID.DirectLinearSolver())


function calculate_second_order_stochastic_steady_state(parameters::Vector{M}, ùìÇ::‚Ñ≥; verbose::Bool = false, pruning::Bool = false) where M
    SS_and_pars, (solution_error, iters) = ùìÇ.SS_solve_func(parameters, ùìÇ, verbose, false, ùìÇ.solver_parameters)
    
    ‚àá‚ÇÅ = calculate_jacobian(parameters, SS_and_pars, ùìÇ) |> Matrix
    
<<<<<<< HEAD
    ùêí‚ÇÅ, success = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
=======
    ùêí‚ÇÅ, solved = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    
    ‚àá‚ÇÇ = calculate_hessian(parameters, SS_and_pars, ùìÇ)
    
    ùêí‚ÇÇ, solved2 = calculate_second_order_solution(‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùìÇ.solution.perturbation.second_order_auxilliary_matrices; T = ùìÇ.timings)

    ùêí‚ÇÅ = [ùêí‚ÇÅ[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùêí‚ÇÅ[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]

    if pruning
        aug_state‚ÇÅ = sparse([zeros(ùìÇ.timings.nPast_not_future_and_mixed); 1; zeros(ùìÇ.timings.nExo)])

        SSSstates = (‚Ñí.I - ùêí‚ÇÅ[ùìÇ.timings.past_not_future_and_mixed_idx,1:ùìÇ.timings.nPast_not_future_and_mixed]) \ (ùêí‚ÇÇ * ‚Ñí.kron(aug_state‚ÇÅ, aug_state‚ÇÅ) / 2)[ùìÇ.timings.past_not_future_and_mixed_idx]

        state = ùêí‚ÇÅ[:,1:ùìÇ.timings.nPast_not_future_and_mixed] * SSSstates + ùêí‚ÇÇ * ‚Ñí.kron(aug_state‚ÇÅ, aug_state‚ÇÅ) / 2
        converged = true
    else
        state, converged = second_order_stochastic_steady_state_iterative_solution([sparsevec(ùêí‚ÇÅ); vec(ùêí‚ÇÇ)]; dims = [size(ùêí‚ÇÅ); size(ùêí‚ÇÇ)], ùìÇ = ùìÇ)
    end
    all_SS = expand_steady_state(SS_and_pars,ùìÇ)

    # all_variables = sort(union(ùìÇ.var,ùìÇ.aux,ùìÇ.exo_present))

    # all_variables[indexin(ùìÇ.aux,all_variables)] = map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  ùìÇ.aux)
    
    # NSSS_labels = [sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...]
    
    # all_SS = [SS_and_pars[indexin([s],NSSS_labels)...] for s in all_variables]
    # we need all variables for the stochastic steady state because even leads and lags have different SSS then the non-lead-lag ones (contrary to the no stochastic steady state) and we cannot recover them otherwise

    return all_SS + state, converged, SS_and_pars, solution_error, ‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùêí‚ÇÇ
end



function third_order_stochastic_steady_state_iterative_solution_forward(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ::SparseVector{Float64}; dims::Vector{Tuple{Int,Int}}, ùìÇ::‚Ñ≥, tol::AbstractFloat = eps())
    lenùêí‚ÇÅ = dims[1][1] * dims[1][2]
    lenùêí‚ÇÇ = dims[2][1] * dims[2][2]

    ùêí‚ÇÅ = reshape(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ[1 : lenùêí‚ÇÅ],dims[1])
    ùêí‚ÇÇ = sparse(reshape(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ[lenùêí‚ÇÅ .+ (1 : lenùêí‚ÇÇ)],dims[2]))
    ùêí‚ÇÉ = sparse(reshape(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ[lenùêí‚ÇÅ + lenùêí‚ÇÇ + 1 : end],dims[3]))

    state = zeros(ùìÇ.timings.nVars)
    shock = zeros(ùìÇ.timings.nExo)

    aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
    1
    shock]

    sol = speedmapping(state; 
                m! = (SSS, sss) -> begin 
                                    aug_state .= [sss[ùìÇ.timings.past_not_future_and_mixed_idx]
                                                1
                                                shock]

                                    SSS .= ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6
                end, 
    tol = tol, maps_limit = 10000)

    return sol.minimizer, sol.converged
end


function third_order_stochastic_steady_state_iterative_solution_conditions(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ::SparseVector, SSS, converged::Bool; dims::Vector{Tuple{Int,Int}}, ùìÇ::‚Ñ≥, tol::AbstractFloat = eps())
    lenùêí‚ÇÅ = dims[1][1] * dims[1][2]
    lenùêí‚ÇÇ = dims[2][1] * dims[2][2]

    ùêí‚ÇÅ = reshape(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ[1 : lenùêí‚ÇÅ],dims[1])
    ùêí‚ÇÇ = sparse(reshape(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ[lenùêí‚ÇÅ .+ (1 : lenùêí‚ÇÇ)],dims[2]))
    ùêí‚ÇÉ = sparse(reshape(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ[lenùêí‚ÇÅ + lenùêí‚ÇÇ + 1 : end],dims[3]))

    shock = zeros(ùìÇ.timings.nExo)

    aug_state = [SSS[ùìÇ.timings.past_not_future_and_mixed_idx]
    1
    shock]

    return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6 - SSS
end

third_order_stochastic_steady_state_iterative_solution = ID.ImplicitFunction(third_order_stochastic_steady_state_iterative_solution_forward,
                                                                                third_order_stochastic_steady_state_iterative_solution_conditions; 
                                                                                linear_solver = ID.DirectLinearSolver())

function third_order_stochastic_steady_state_iterative_solution_forward(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ::SparseVector{‚Ñ±.Dual{Z,S,N}}; dims::Vector{Tuple{Int,Int}}, ùìÇ::‚Ñ≥, tol::AbstractFloat = eps()) where {Z,S,N}
    S‚ÇÅS‚ÇÇS‚ÇÉ, ps = separate_values_and_partials_from_sparsevec_dual(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ)

    # get f(vs)
    val, converged = third_order_stochastic_steady_state_iterative_solution_forward(S‚ÇÅS‚ÇÇS‚ÇÉ; dims = dims, ùìÇ = ùìÇ, tol = tol)

    if converged
        # get J(f, vs) * ps (cheating). Write your custom rule here
        B = ‚Ñ±.jacobian(x -> third_order_stochastic_steady_state_iterative_solution_conditions(x, val, converged; dims = dims, ùìÇ = ùìÇ, tol = tol), S‚ÇÅS‚ÇÇS‚ÇÉ)
        A = ‚Ñ±.jacobian(x -> third_order_stochastic_steady_state_iterative_solution_conditions(S‚ÇÅS‚ÇÇS‚ÇÉ, x, converged; dims = dims, ùìÇ = ùìÇ, tol = tol), val)
        
        AÃÇ = RF.lu(A, check = false)
    
        if !‚Ñí.issuccess(AÃÇ)
            AÃÇ = ‚Ñí.svd(A)
        end
        
        jvp = -(AÃÇ \ B) * ps
    else
        jvp = fill(0,length(val),length(ùêí‚ÇÅùêí‚ÇÇùêí‚ÇÉ)) * ps
    end

    # lm = LinearMap{Float64}(x -> A * reshape(x, size(B)), length(B))

    # jvp = - sparse(reshape(‚Ñê.gmres(lm, sparsevec(B)), size(B))) * ps
    # jvp *= -ps

    # pack: SoA -> AoS
    return reshape(map(val, eachrow(jvp)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
    end,size(val)), converged
end


function calculate_third_order_stochastic_steady_state(parameters::Vector{M}, ùìÇ::‚Ñ≥; verbose::Bool = false, pruning::Bool = false, tol::AbstractFloat = eps()) where M
    SS_and_pars, (solution_error, iters) = ùìÇ.SS_solve_func(parameters, ùìÇ, verbose, false, ùìÇ.solver_parameters)
    
    ‚àá‚ÇÅ = calculate_jacobian(parameters, SS_and_pars, ùìÇ) |> Matrix
    
<<<<<<< HEAD
    ùêí‚ÇÅ, success = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
=======
    ùêí‚ÇÅ, solved = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    
    ‚àá‚ÇÇ = calculate_hessian(parameters, SS_and_pars, ùìÇ)
    
    ùêí‚ÇÇ, solved2 = calculate_second_order_solution(‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùìÇ.solution.perturbation.second_order_auxilliary_matrices; T = ùìÇ.timings, tol = tol)

    ‚àá‚ÇÉ = calculate_third_order_derivatives(parameters, SS_and_pars, ùìÇ)
            
    ùêí‚ÇÉ, solved3 = calculate_third_order_solution(‚àá‚ÇÅ, ‚àá‚ÇÇ, ‚àá‚ÇÉ, ùêí‚ÇÅ, ùêí‚ÇÇ, ùìÇ.solution.perturbation.second_order_auxilliary_matrices, ùìÇ.solution.perturbation.third_order_auxilliary_matrices; T = ùìÇ.timings, tol = tol)

    ùêí‚ÇÅ = [ùêí‚ÇÅ[:,1:ùìÇ.timings.nPast_not_future_and_mixed] zeros(ùìÇ.timings.nVars) ùêí‚ÇÅ[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]]

    if pruning
        aug_state‚ÇÅ = sparse([zeros(ùìÇ.timings.nPast_not_future_and_mixed); 1; zeros(ùìÇ.timings.nExo)])
        
        SSSstates = (‚Ñí.I - ùêí‚ÇÅ[ùìÇ.timings.past_not_future_and_mixed_idx,1:ùìÇ.timings.nPast_not_future_and_mixed]) \ (ùêí‚ÇÇ * ‚Ñí.kron(aug_state‚ÇÅ, aug_state‚ÇÅ) / 2)[ùìÇ.timings.past_not_future_and_mixed_idx]

        state = ùêí‚ÇÅ[:,1:ùìÇ.timings.nPast_not_future_and_mixed] * SSSstates + ùêí‚ÇÇ * ‚Ñí.kron(aug_state‚ÇÅ, aug_state‚ÇÅ) / 2
        converged = true
    else
        state, converged = third_order_stochastic_steady_state_iterative_solution([sparsevec(ùêí‚ÇÅ); vec(ùêí‚ÇÇ); vec(ùêí‚ÇÉ)]; dims = [size(ùêí‚ÇÅ); size(ùêí‚ÇÇ); size(ùêí‚ÇÉ)], ùìÇ = ùìÇ)
    end

    all_SS = expand_steady_state(SS_and_pars,ùìÇ)

    # all_variables = sort(union(ùìÇ.var,ùìÇ.aux,ùìÇ.exo_present))

    # all_variables[indexin(ùìÇ.aux,all_variables)] = map(x -> Symbol(replace(string(x), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")),  ùìÇ.aux)
    
    # NSSS_labels = [sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...]
    
    # all_SS = [SS_and_pars[indexin([s],NSSS_labels)...] for s in all_variables]
    # we need all variables for the stochastic steady state because even leads and lags have different SSS then the non-lead-lag ones (contrary to the no stochastic steady state) and we cannot recover them otherwise

    return all_SS + state, converged, SS_and_pars, solution_error, ‚àá‚ÇÅ, ‚àá‚ÇÇ, ‚àá‚ÇÉ, ùêí‚ÇÅ, ùêí‚ÇÇ, ùêí‚ÇÉ
end




function solve!(ùìÇ::‚Ñ≥; 
    parameters = nothing, 
    dynamics::Bool = false, 
    algorithm::Symbol = :riccati, 
    symbolic_SS::Bool = false,
    verbose::Bool = false,
    silent::Bool = false,
    tol::AbstractFloat = eps())

    @assert algorithm ‚àà all_available_algorithms

    if dynamics
        ùìÇ.solution.outdated_algorithms = union(intersect(ùìÇ.solution.algorithms,[algorithm]),ùìÇ.solution.outdated_algorithms)
        ùìÇ.solution.algorithms = union(ùìÇ.solution.algorithms,[algorithm])
    end
    
    write_parameters_input!(ùìÇ, parameters, verbose = verbose)

    if ùìÇ.model_hessian == Function[] && algorithm ‚àà [:second_order, :pruned_second_order]
        start_time = time()
        write_functions_mapping!(ùìÇ, 2)
        if !silent println("Take symbolic derivatives up to second order:\t",round(time() - start_time, digits = 3), " seconds") end
    elseif ùìÇ.model_third_order_derivatives == Function[] && algorithm ‚àà [:third_order, :pruned_third_order]
        start_time = time()
        write_functions_mapping!(ùìÇ, 3)
        if !silent println("Take symbolic derivatives up to third order:\t",round(time() - start_time, digits = 3), " seconds") end
    end

    if dynamics
        if (any([:riccati, :first_order] .‚àà ([algorithm],)) && 
                any([:riccati, :first_order] .‚àà (ùìÇ.solution.outdated_algorithms,))) || 
            (any([:second_order,:pruned_second_order] .‚àà ([algorithm],)) && 
                any([:second_order,:pruned_second_order] .‚àà (ùìÇ.solution.outdated_algorithms,))) || 
            (any([:third_order,:pruned_third_order] .‚àà ([algorithm],)) && 
                any([:third_order,:pruned_third_order] .‚àà (ùìÇ.solution.outdated_algorithms,)))

            SS_and_pars, (solution_error, iters) = ùìÇ.solution.outdated_NSSS ? ùìÇ.SS_solve_func(ùìÇ.parameter_values, ùìÇ, verbose, false, ùìÇ.solver_parameters) : (ùìÇ.solution.non_stochastic_steady_state, (eps(), 0))

            if solution_error > tol
                @warn "Could not find non stochastic steady steady."
            end

            ‚àá‚ÇÅ = calculate_jacobian(ùìÇ.parameter_values, SS_and_pars, ùìÇ) |> Matrix
            
<<<<<<< HEAD
            sol_mat, success = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
=======
            sol_mat, solved = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
            
            @assert solved "Could not find stable first order solution."

            state_update‚ÇÅ = function(state::Vector{T}, shock::Vector{S}) where {T,S} sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
            
            ùìÇ.solution.perturbation.first_order = perturbation_solution(sol_mat, state_update‚ÇÅ)
            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:riccati, :first_order])

            ùìÇ.solution.non_stochastic_steady_state = SS_and_pars
            ùìÇ.solution.outdated_NSSS = solution_error > tol

        end

        if (:second_order == algorithm && 
                :second_order ‚àà ùìÇ.solution.outdated_algorithms) || 
            (any([:third_order] .‚àà ([algorithm],)) && 
                any([:third_order] .‚àà (ùìÇ.solution.outdated_algorithms,)))

            stochastic_steady_state, converged, SS_and_pars, solution_error, ‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùêí‚ÇÇ = calculate_second_order_stochastic_steady_state(ùìÇ.parameter_values, ùìÇ, verbose = verbose)
            
            @assert converged "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

            state_update‚ÇÇ = function(state::Vector{T}, shock::Vector{S}) where {T,S}
                aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                            1
                            shock]
                return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2
            end

            ùìÇ.solution.perturbation.second_order = second_order_perturbation_solution(ùêí‚ÇÇ,stochastic_steady_state,state_update‚ÇÇ)

            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:second_order])
        end
        
        if (:pruned_second_order == algorithm && 
                :pruned_second_order ‚àà ùìÇ.solution.outdated_algorithms) || 
            (any([:third_order,:pruned_third_order] .‚àà ([algorithm],)) && 
                any([:third_order,:pruned_third_order] .‚àà (ùìÇ.solution.outdated_algorithms,)))

            stochastic_steady_state, converged, SS_and_pars, solution_error, ‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùêí‚ÇÇ = calculate_second_order_stochastic_steady_state(ùìÇ.parameter_values, ùìÇ, verbose = verbose, pruning = true)

            @assert converged "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

            state_update‚ÇÇ = function(pruned_states::Vector{Vector{T}}, shock::Vector{S}) where {T,S}
                aug_state‚ÇÅ = [pruned_states[1][ùìÇ.timings.past_not_future_and_mixed_idx]; 1; shock]
                aug_state‚ÇÇ = [pruned_states[2][ùìÇ.timings.past_not_future_and_mixed_idx]; 0; zero(shock)]
                
                pruned_states[1] .= ùêí‚ÇÅ * aug_state‚ÇÅ
                pruned_states[2] .= ùêí‚ÇÅ * aug_state‚ÇÇ + ùêí‚ÇÇ * ‚Ñí.kron(aug_state‚ÇÅ, aug_state‚ÇÅ) / 2

                return pruned_states[1] + pruned_states[2] # strictly following Andreasen et al. (2018)
            end

            ùìÇ.solution.perturbation.pruned_second_order = second_order_perturbation_solution(ùêí‚ÇÇ,stochastic_steady_state,state_update‚ÇÇ)

            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:pruned_second_order])
        end
        
        if :third_order == algorithm && :third_order ‚àà ùìÇ.solution.outdated_algorithms

            stochastic_steady_state, converged, SS_and_pars, solution_error, ‚àá‚ÇÅ, ‚àá‚ÇÇ, ‚àá‚ÇÉ, ùêí‚ÇÅ, ùêí‚ÇÇ, ùêí‚ÇÉ = calculate_third_order_stochastic_steady_state(ùìÇ.parameter_values, ùìÇ, verbose = verbose)

            @assert converged "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

            state_update‚ÇÉ = function(state::Vector{T}, shock::Vector{S}) where {T,S}
                aug_state = [state[ùìÇ.timings.past_not_future_and_mixed_idx]
                                1
                                shock]
                return ùêí‚ÇÅ * aug_state + ùêí‚ÇÇ * ‚Ñí.kron(aug_state, aug_state) / 2 + ùêí‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aug_state,aug_state),aug_state) / 6
            end

            ùìÇ.solution.perturbation.third_order = third_order_perturbation_solution(ùêí‚ÇÉ,stochastic_steady_state,state_update‚ÇÉ)

            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:third_order])
        end
        
        if :pruned_third_order == algorithm && :pruned_third_order ‚àà ùìÇ.solution.outdated_algorithms

            stochastic_steady_state, converged, SS_and_pars, solution_error, ‚àá‚ÇÅ, ‚àá‚ÇÇ, ‚àá‚ÇÉ, ùêí‚ÇÅ, ùêí‚ÇÇ, ùêí‚ÇÉ = calculate_third_order_stochastic_steady_state(ùìÇ.parameter_values, ùìÇ, verbose = verbose, pruning = true)

            @assert converged "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

            state_update‚ÇÉ = function(pruned_states::Vector{Vector{T}}, shock::Vector{S}) where {T,S}
                aug_state‚ÇÅ = [pruned_states[1][ùìÇ.timings.past_not_future_and_mixed_idx]; 1; shock]
                aug_state‚ÇÅÃÇ = [pruned_states[1][ùìÇ.timings.past_not_future_and_mixed_idx]; 0; shock]
                aug_state‚ÇÇ = [pruned_states[2][ùìÇ.timings.past_not_future_and_mixed_idx]; 0; zero(shock)]
                aug_state‚ÇÉ = [pruned_states[3][ùìÇ.timings.past_not_future_and_mixed_idx]; 0; zero(shock)]
                
                kron_aug_state‚ÇÅ = ‚Ñí.kron(aug_state‚ÇÅ, aug_state‚ÇÅ)
                
                pruned_states[1] .= ùêí‚ÇÅ * aug_state‚ÇÅ
                pruned_states[2] .= ùêí‚ÇÅ * aug_state‚ÇÇ + ùêí‚ÇÇ * kron_aug_state‚ÇÅ / 2
                pruned_states[3] .= ùêí‚ÇÅ * aug_state‚ÇÉ + ùêí‚ÇÇ * ‚Ñí.kron(aug_state‚ÇÅÃÇ, aug_state‚ÇÇ) + ùêí‚ÇÉ * ‚Ñí.kron(kron_aug_state‚ÇÅ,aug_state‚ÇÅ) / 6

                return pruned_states[1] + pruned_states[2] + pruned_states[3]
            end

            ùìÇ.solution.perturbation.pruned_third_order = third_order_perturbation_solution(ùêí‚ÇÉ,stochastic_steady_state,state_update‚ÇÉ)

            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:pruned_third_order])
        end
        
        if any([:quadratic_iteration, :binder_pesaran] .‚àà ([algorithm],)) && any([:quadratic_iteration, :binder_pesaran] .‚àà (ùìÇ.solution.outdated_algorithms,))
            
            SS_and_pars, (solution_error, iters) = ùìÇ.solution.outdated_NSSS ? ùìÇ.SS_solve_func(ùìÇ.parameter_values, ùìÇ, verbose, false, ùìÇ.solver_parameters) : (ùìÇ.solution.non_stochastic_steady_state, (eps(), 0))

            if solution_error > tol
                @warn "Could not find non stochastic steady steady."
            end

            ‚àá‚ÇÅ = calculate_jacobian(ùìÇ.parameter_values, SS_and_pars, ùìÇ) |> Matrix
            
            sol_mat, converged = calculate_quadratic_iteration_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
            
            state_update‚ÇÅ‚Çú = function(state::Vector{T}, shock::Vector{S}) where {T,S} sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
            
            ùìÇ.solution.perturbation.quadratic_iteration = perturbation_solution(sol_mat, state_update‚ÇÅ‚Çú)
            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:quadratic_iteration, :binder_pesaran])

            ùìÇ.solution.non_stochastic_steady_state = SS_and_pars
            ùìÇ.solution.outdated_NSSS = solution_error > tol
            
        end

        if :linear_time_iteration == algorithm && :linear_time_iteration ‚àà ùìÇ.solution.outdated_algorithms
            SS_and_pars, (solution_error, iters) = ùìÇ.solution.outdated_NSSS ? ùìÇ.SS_solve_func(ùìÇ.parameter_values, ùìÇ, verbose, false, ùìÇ.solver_parameters) : (ùìÇ.solution.non_stochastic_steady_state, (eps(), 0))

            if solution_error > tol
                @warn "Could not find non stochastic steady steady."
            end

            ‚àá‚ÇÅ = calculate_jacobian(ùìÇ.parameter_values, SS_and_pars, ùìÇ) |> Matrix
            
            sol_mat = calculate_linear_time_iteration_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
            
            state_update‚ÇÅ‚Çú = function(state::Vector{T}, shock::Vector{S}) where {T,S} sol_mat * [state[ùìÇ.timings.past_not_future_and_mixed_idx]; shock] end
            
            ùìÇ.solution.perturbation.linear_time_iteration = perturbation_solution(sol_mat, state_update‚ÇÅ‚Çú)
            ùìÇ.solution.outdated_algorithms = setdiff(ùìÇ.solution.outdated_algorithms,[:linear_time_iteration])

            ùìÇ.solution.non_stochastic_steady_state = SS_and_pars
            ùìÇ.solution.outdated_NSSS = solution_error > tol
        end
    end
    
    return nothing
end




function create_second_order_auxilliary_matrices(T::timings)
    # Indices and number of variables
    n‚Çã = T.nPast_not_future_and_mixed
    n‚Çë = T.nExo

    # setup compression matrices for hessian matrix
    n‚Çë‚Çã = T.nPast_not_future_and_mixed + T.nVars + T.nFuture_not_past_and_mixed + T.nExo
    colls2 = [n‚Çë‚Çã * (i-1) + k for i in 1:n‚Çë‚Çã for k in 1:i]
    ùêÇ‚àá‚ÇÇ = sparse(colls2, 1:length(colls2), 1)
    ùêî‚àá‚ÇÇ = ùêÇ‚àá‚ÇÇ' * sparse([i <= k ? (k - 1) * n‚Çë‚Çã + i : (i - 1) * n‚Çë‚Çã + k for k in 1:n‚Çë‚Çã for i in 1:n‚Çë‚Çã], 1:n‚Çë‚Çã^2, 1)

    # set up vector to capture volatility effect
    n‚Çë‚Çã = n‚Çã + 1 + n‚Çë
    redu = sparsevec(n‚Çë‚Çã - n‚Çë + 1:n‚Çë‚Çã, 1)
    redu_idxs = findnz(‚Ñí.kron(redu, redu))[1]
    ùõî = @views sparse(redu_idxs[Int.(range(1,n‚Çë^2,n‚Çë))], fill(n‚Çã * (n‚Çë‚Çã + 1) + 1, n‚Çë), 1, n‚Çë‚Çã^2, n‚Çë‚Çã^2)
    
    # setup compression matrices for transition matrix
    colls2 = [n‚Çë‚Çã * (i-1) + k for i in 1:n‚Çë‚Çã for k in 1:i]
    ùêÇ‚ÇÇ = sparse(colls2, 1:length(colls2), 1)
    ùêî‚ÇÇ = ùêÇ‚ÇÇ' * sparse([i <= k ? (k - 1) * n‚Çë‚Çã + i : (i - 1) * n‚Çë‚Çã + k for k in 1:n‚Çë‚Çã for i in 1:n‚Çë‚Çã], 1:n‚Çë‚Çã^2, 1)

    return second_order_auxilliary_matrices(ùõî, ùêÇ‚ÇÇ, ùêî‚ÇÇ, ùêî‚àá‚ÇÇ)
end




function create_third_order_auxilliary_matrices(T::timings, ‚àá‚ÇÉ_col_indices::Vector{Int})    
    # Indices and number of variables
    n‚Çã = T.nPast_not_future_and_mixed
    n‚Çä = T.nFuture_not_past_and_mixed
    n = T.nVars
    n‚Çë = T.nExo

    nÃÑ = n‚Çã + n + n‚Çä + n‚Çë

    # compression matrices for third order derivatives matrix
    n‚Çë‚Çã = T.nPast_not_future_and_mixed + T.nVars + T.nFuture_not_past_and_mixed + T.nExo
    colls3 = [n‚Çë‚Çã^2 * (i-1) + n‚Çë‚Çã * (k-1) + l for i in 1:n‚Çë‚Çã for k in 1:i for l in 1:k]
    ùêÇ‚àá‚ÇÉ = sparse(colls3, 1:length(colls3) , 1.0)
    
    idxs = []
    for k in 1:n‚Çë‚Çã
        for j in 1:n‚Çë‚Çã
            for i in 1:n‚Çë‚Çã
                sorted_ids = sort([k,j,i])
                push!(idxs, (sorted_ids[3] - 1) * n‚Çë‚Çã ^ 2 + (sorted_ids[2] - 1) * n‚Çë‚Çã + sorted_ids[1])
            end
        end
    end
    
    ùêî‚àá‚ÇÉ = ùêÇ‚àá‚ÇÉ' * sparse(idxs,1:n‚Çë‚Çã ^ 3, 1)

    # compression matrices for third order transition matrix
    n‚Çë‚Çã = n‚Çã + 1 + n‚Çë
    colls3 = [n‚Çë‚Çã^2 * (i-1) + n‚Çë‚Çã * (k-1) + l for i in 1:n‚Çë‚Çã for k in 1:i for l in 1:k]
    ùêÇ‚ÇÉ = sparse(colls3, 1:length(colls3) , 1.0)
    
    idxs = []
    for k in 1:n‚Çë‚Çã
        for j in 1:n‚Çë‚Çã
            for i in 1:n‚Çë‚Çã
                sorted_ids = sort([k,j,i])
                push!(idxs, (sorted_ids[3] - 1) * n‚Çë‚Çã ^ 2 + (sorted_ids[2] - 1) * n‚Çë‚Çã + sorted_ids[1])
            end
        end
    end
    
    ùêî‚ÇÉ = ùêÇ‚ÇÉ' * sparse(idxs,1:n‚Çë‚Çã ^ 3, 1)
    
    # permutation matrices
    M = reshape(1:n‚Çë‚Çã^3,1,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã)
    ùêè = @views sparse(reshape(spdiagm(ones(n‚Çë‚Çã^3))[:,PermutedDimsArray(M,[1, 4, 2, 3])],n‚Çë‚Çã^3,n‚Çë‚Çã^3)
                        + reshape(spdiagm(ones(n‚Çë‚Çã^3))[:,PermutedDimsArray(M,[1, 2, 4, 3])],n‚Çë‚Çã^3,n‚Çë‚Çã^3)
                        + reshape(spdiagm(ones(n‚Çë‚Çã^3))[:,PermutedDimsArray(M,[1, 2, 3, 4])],n‚Çë‚Çã^3,n‚Çë‚Çã^3))

    ùêè‚ÇÅ‚Çó = sparse(spdiagm(ones(n‚Çë‚Çã^3))[vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(2,1,3))),:])
    ùêè‚ÇÅ·µ£ = sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(2,1,3)))])

    ùêè‚ÇÅ‚ÇóÃÇ  = @views sparse(spdiagm(ones(nÃÑ^3))[vec(permutedims(reshape(1:nÃÑ^3,nÃÑ,nÃÑ,nÃÑ),(1,3,2))),:])
    ùêè‚ÇÇ‚ÇóÃÇ  = @views sparse(spdiagm(ones(nÃÑ^3))[vec(permutedims(reshape(1:nÃÑ^3,nÃÑ,nÃÑ,nÃÑ),(3,1,2))),:])

    ùêè‚ÇÅ‚ÇóÃÑ = @views sparse(spdiagm(ones(n‚Çë‚Çã^3))[vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(1,3,2))),:])
    ùêè‚ÇÇ‚ÇóÃÑ = @views sparse(spdiagm(ones(n‚Çë‚Çã^3))[vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(3,1,2))),:])


    ùêè‚ÇÅ·µ£ÃÉ = @views sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(1,3,2)))])
    ùêè‚ÇÇ·µ£ÃÉ = @views sparse(spdiagm(ones(n‚Çë‚Çã^3))[:,vec(permutedims(reshape(1:n‚Çë‚Çã^3,n‚Çë‚Çã,n‚Çë‚Çã,n‚Çë‚Çã),(3,1,2)))])

    ‚àá‚ÇÉ_col_indices_extended = findnz(sparse(ones(Int,length(‚àá‚ÇÉ_col_indices)),‚àá‚ÇÉ_col_indices,ones(Int,length(‚àá‚ÇÉ_col_indices)),1,size(ùêî‚àá‚ÇÉ,1)) * ùêî‚àá‚ÇÉ)[2]

    nonnull_columns = Set()
    for i in 1:nÃÑ 
        for j in i:nÃÑ 
            for k in j:nÃÑ 
                if nÃÑ^2 * (i - 1)  + nÃÑ * (j - 1) + k in ‚àá‚ÇÉ_col_indices_extended
                    push!(nonnull_columns,i)
                    push!(nonnull_columns,j)
                    push!(nonnull_columns,k)
                end
            end
        end
    end
            
    ùêíùêè = sparse(collect(nonnull_columns), collect(nonnull_columns), 1, nÃÑ, nÃÑ)

    return third_order_auxilliary_matrices(ùêÇ‚ÇÉ, ùêî‚ÇÉ, ùêî‚àá‚ÇÉ, ùêè, ùêè‚ÇÅ‚Çó, ùêè‚ÇÅ·µ£, ùêè‚ÇÅ‚ÇóÃÇ, ùêè‚ÇÇ‚ÇóÃÇ, ùêè‚ÇÅ‚ÇóÃÑ, ùêè‚ÇÇ‚ÇóÃÑ, ùêè‚ÇÅ·µ£ÃÉ, ùêè‚ÇÇ·µ£ÃÉ, ùêíùêè)
end

function write_functions_mapping!(ùìÇ::‚Ñ≥, max_perturbation_order::Int)
    future_varss  = collect(reduce(union,match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚ÇÅ‚Çé$")))
    present_varss = collect(reduce(union,match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚ÇÄ‚Çé$")))
    past_varss    = collect(reduce(union,match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚Çã‚ÇÅ‚Çé$")))
    shock_varss   = collect(reduce(union,match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚Çì‚Çé$")))
    ss_varss      = collect(reduce(union,match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚Çõ‚Çõ‚Çé$")))

    sort!(future_varss  ,by = x->replace(string(x),r"‚Çç‚ÇÅ‚Çé$"=>"")) #sort by name without time index because otherwise eps_z·¥∏‚ÅΩ‚Åª¬π‚Åæ‚Çç‚Çã‚ÇÅ‚Çé comes before eps_z‚Çç‚Çã‚ÇÅ‚Çé
    sort!(present_varss ,by = x->replace(string(x),r"‚Çç‚ÇÄ‚Çé$"=>""))
    sort!(past_varss    ,by = x->replace(string(x),r"‚Çç‚Çã‚ÇÅ‚Çé$"=>""))
    sort!(shock_varss   ,by = x->replace(string(x),r"‚Çç‚Çì‚Çé$"=>""))
    sort!(ss_varss      ,by = x->replace(string(x),r"‚Çç‚Çõ‚Çõ‚Çé$"=>""))

    steady_state = []
    for (i, var) in enumerate(ss_varss)
        push!(steady_state,:($var = XÃÑ[$i]))
        # ii += 1
    end

    ii = 1

    alll = []
    for var in future_varss
        push!(alll,:($var = X[$ii]))
        ii += 1
    end

    for var in present_varss
        push!(alll,:($var = X[$ii]))
        ii += 1
    end

    for var in past_varss
        push!(alll,:($var = X[$ii]))
        ii += 1
    end

    for var in shock_varss
        push!(alll,:($var = X[$ii]))
        ii += 1
    end


    # paras = []
    # push!(paras,:((;$(vcat(ùìÇ.parameters,ùìÇ.calibration_equations_parameters)...)) = params))

    paras = []
    for (i, parss) in enumerate(vcat(ùìÇ.parameters,ùìÇ.calibration_equations_parameters))
        push!(paras,:($parss = params[$i]))
    end

    # # watch out with naming of parameters in model and functions
    # mod_func2 = :(function model_function_uni_redux(X::Vector, params::Vector{Number}, XÃÑ::Vector)
    #     $(alll...)
    #     $(paras...)
	# 	$(ùìÇ.calibration_equations_no_var...)
    #     $(steady_state...)
    #     [$(ùìÇ.dyn_equations...)]
    # end)


    # ùìÇ.model_function = @RuntimeGeneratedFunction(mod_func2)
    # ùìÇ.model_function = eval(mod_func2)

    dyn_future_list = collect(reduce(union, ùìÇ.dyn_future_list))
    dyn_present_list = collect(reduce(union, ùìÇ.dyn_present_list))
    dyn_past_list = collect(reduce(union, ùìÇ.dyn_past_list))
    dyn_exo_list = collect(reduce(union,ùìÇ.dyn_exo_list))
    
    future = map(x -> Symbol(replace(string(x), r"‚Çç‚ÇÅ‚Çé" => "")),string.(dyn_future_list))
    present = map(x -> Symbol(replace(string(x), r"‚Çç‚ÇÄ‚Çé" => "")),string.(dyn_present_list))
    past = map(x -> Symbol(replace(string(x), r"‚Çç‚Çã‚ÇÅ‚Çé" => "")),string.(dyn_past_list))
    exo = map(x -> Symbol(replace(string(x), r"‚Çç‚Çì‚Çé" => "")),string.(dyn_exo_list))
    
    vars_raw = [dyn_future_list[indexin(sort(future),future)]...,
            dyn_present_list[indexin(sort(present),present)]...,
            dyn_past_list[indexin(sort(past),past)]...,
            dyn_exo_list[indexin(sort(exo),exo)]...]

    # overwrite SymPyCall names
    eval(:(Symbolics.@variables $(reduce(union,get_symbols.(ùìÇ.dyn_equations))...)))

    vars = eval(:(Symbolics.@variables $(vars_raw...)))

    eqs = Symbolics.parse_expr_to_symbolic.(ùìÇ.dyn_equations,(@__MODULE__,))

    if max_perturbation_order >= 2 
        nk = length(vars_raw)
        second_order_idxs = [nk * (i-1) + k for i in 1:nk for k in 1:i]
        if max_perturbation_order == 3
            third_order_idxs = [nk^2 * (i-1) + nk * (k-1) + l for i in 1:nk for k in 1:i for l in 1:k]
        end
    end

    first_order = []
    second_order = []
    third_order = []
    row1 = Int[]
    row2 = Int[]
    row3 = Int[]
    column1 = Int[]
    column2 = Int[]
    column3 = Int[]
    # column3ext = Int[]
    i1 = 1
    i2 = 1
    i3 = 1
    
    for (c1,var1) in enumerate(vars)
        for (r,eq) in enumerate(eqs)
            if Symbol(var1) ‚àà Symbol.(Symbolics.get_variables(eq))
                deriv_first = Symbolics.derivative(eq,var1)
                # if deriv_first != 0 
                #     deriv_expr = Meta.parse(string(deriv_first.subs(SPyPyC.PI,SPyPyC.N(SPyPyC.PI))))
                #     push!(first_order, :($(postwalk(x -> x isa Expr ? x.args[1] == :conjugate ? x.args[2] : x : x, deriv_expr))))
                    push!(first_order, Symbolics.toexpr(deriv_first))
                    push!(row1,r)
                    push!(column1,c1)
                    i1 += 1
                    if max_perturbation_order >= 2 
                        for (c2,var2) in enumerate(vars)
                            # if Symbol(var2) ‚àà Symbol.(Symbolics.get_variables(deriv_first))
                            if (((c1 - 1) * length(vars) + c2) ‚àà second_order_idxs) && (Symbol(var2) ‚àà Symbol.(Symbolics.get_variables(deriv_first)))
                                deriv_second = Symbolics.derivative(deriv_first,var2)
                                # if deriv_second != 0 
                                #     deriv_expr = Meta.parse(string(deriv_second.subs(SPyPyC.PI,SPyPyC.N(SPyPyC.PI))))
                                #     push!(second_order, :($(postwalk(x -> x isa Expr ? x.args[1] == :conjugate ? x.args[2] : x : x, deriv_expr))))
                                    push!(second_order,Symbolics.toexpr(deriv_second))
                                    push!(row2,r)
                                    # push!(column2,(c1 - 1) * length(vars) + c2)
                                    push!(column2, Int.(indexin([(c1 - 1) * length(vars) + c2], second_order_idxs))...)
                                    i2 += 1
                                    if max_perturbation_order == 3
                                        for (c3,var3) in enumerate(vars)
                                            # if Symbol(var3) ‚àà Symbol.(Symbolics.get_variables(deriv_second))
                                                # push!(column3ext,(c1 - 1) * length(vars)^2 + (c2 - 1) * length(vars) + c3)
                                                if (((c1 - 1) * length(vars)^2 + (c2 - 1) * length(vars) + c3) ‚àà third_order_idxs) && (Symbol(var3) ‚àà Symbol.(Symbolics.get_variables(deriv_second)))
                                                    deriv_third = Symbolics.derivative(deriv_second,var3)
                                                    # if deriv_third != 0 
                                                    #     deriv_expr = Meta.parse(string(deriv_third.subs(SPyPyC.PI,SPyPyC.N(SPyPyC.PI))))
                                                    #     push!(third_order, :($(postwalk(x -> x isa Expr ? x.args[1] == :conjugate ? x.args[2] : x : x, deriv_expr))))
                                                        push!(third_order,Symbolics.toexpr(deriv_third))
                                                        push!(row3,r)
                                                        # push!(column3,(c1 - 1) * length(vars)^2 + (c2 - 1) * length(vars) + c3)
                                                        push!(column3, Int.(indexin([(c1 - 1) * length(vars)^2 + (c2 - 1) * length(vars) + c3], third_order_idxs))...)
                                                        i3 += 1
                                                    # end
                                                end
                                            # end
                                        end
                                    end
                                # end
                            end
                        end
                    end
                # end
            end
        end
    end


    mod_func3 = :(function model_jacobian(X::Vector, params::Vector{Real}, XÃÑ::Vector)
        $(alll...)
        $(paras...)
        $(ùìÇ.calibration_equations_no_var...)
        $(steady_state...)
        sparse([$(row1...)], [$(column1...)], [$(first_order...)], $(length(eqs)), $(length(vars)))
    end)

    ùìÇ.model_jacobian = @RuntimeGeneratedFunction(mod_func3)
    # ùìÇ.model_jacobian = FWrap{Tuple{Vector{Float64}, Vector{Number}, Vector{Float64}}, SparseMatrixCSC{Float64}}(@RuntimeGeneratedFunction(mod_func3))

    # ùìÇ.model_jacobian = eval(mod_func3)


    if max_perturbation_order >= 2 && ùìÇ.model_hessian == Function[]
        # if length(row2) == 0 
        #     out = :(spzeros($(length(eqs)), $(length(second_order_idxs))))
        # else 
        #     out = :(sparse([$(row2...)], [$(column2...)], [$(second_order...)], $(length(eqs)), $(length(second_order_idxs))))
        # end

        # mod_func4 = :(function model_hessian(X::Vector, params::Vector{Real}, XÃÑ::Vector)
        #     $(alll...)
        #     $(paras...)
        #     $(ùìÇ.calibration_equations_no_var...)
        #     $(steady_state...)
        #     $out
        # end)

        for (l,second) in enumerate(second_order)
            exx = :(function(X::Vector, params::Vector{Real}, XÃÑ::Vector)
            $(alll...)
            $(paras...)
            $(ùìÇ.calibration_equations_no_var...)
            $(steady_state...)
            return $second, $(row2[l]), $(column2[l])
            end)
            push!(ùìÇ.model_hessian,@RuntimeGeneratedFunction(exx))
        end

        ùìÇ.solution.perturbation.second_order_auxilliary_matrices = create_second_order_auxilliary_matrices(ùìÇ.timings)


        # ùìÇ.model_hessian = @RuntimeGeneratedFunction(mod_func4)
        # ùìÇ.model_hessian = eval(mod_func4)
    end

    if max_perturbation_order == 3 && ùìÇ.model_third_order_derivatives == Function[]
        # if length(row3) == 0 
        #     out = :(spzeros($(length(eqs)), $(length(third_order_idxs))))
        # else 
        #     out = :(sparse([$(row3...)], [$(column3...)], [$(third_order...)], $(length(eqs)), $(length(third_order_idxs))))
        # end

        # mod_func5 = :(function model_hessian(X::Vector, params::Vector{Real}, XÃÑ::Vector)
        #     $(alll...)
        #     $(paras...)
        #     $(ùìÇ.calibration_equations_no_var...)
        #     $(steady_state...)
        #     $out
        # end)

        for (l,third) in enumerate(third_order)
            exx = :(function(X::Vector, params::Vector{Real}, XÃÑ::Vector)
            $(alll...)
            $(paras...)
            $(ùìÇ.calibration_equations_no_var...)
            $(steady_state...)
            return $third, $(row3[l]), $(column3[l])
            end)
            push!(ùìÇ.model_third_order_derivatives,@RuntimeGeneratedFunction(exx))
        end

        ùìÇ.solution.perturbation.third_order_auxilliary_matrices = create_third_order_auxilliary_matrices(ùìÇ.timings, unique(column3))

    end


    # write indices in auxiliary objects
    dyn_var_future_list  = map(x->Set{Symbol}(map(x->Symbol(replace(string(x),"‚Çç‚ÇÅ‚Çé" => "")),x)),collect.(match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚ÇÅ‚Çé")))
    dyn_var_present_list = map(x->Set{Symbol}(map(x->Symbol(replace(string(x),"‚Çç‚ÇÄ‚Çé" => "")),x)),collect.(match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚ÇÄ‚Çé")))
    dyn_var_past_list    = map(x->Set{Symbol}(map(x->Symbol(replace(string(x),"‚Çç‚Çã‚ÇÅ‚Çé" => "")),x)),collect.(match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚Çã‚ÇÅ‚Çé")))
    dyn_exo_list         = map(x->Set{Symbol}(map(x->Symbol(replace(string(x),"‚Çç‚Çì‚Çé" => "")),x)),collect.(match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚Çì‚Çé")))
    dyn_ss_list          = map(x->Set{Symbol}(map(x->Symbol(replace(string(x),"‚Çç‚Çõ‚Çõ‚Çé" => "")),x)),collect.(match_pattern.(get_symbols.(ùìÇ.dyn_equations),r"‚Çç‚Çõ‚Çõ‚Çé")))

    dyn_var_future  = Symbol.(replace.(string.(sort(collect(reduce(union,dyn_var_future_list)))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))
    dyn_var_present = Symbol.(replace.(string.(sort(collect(reduce(union,dyn_var_present_list)))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))
    dyn_var_past    = Symbol.(replace.(string.(sort(collect(reduce(union,dyn_var_past_list)))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))
    dyn_exo         = Symbol.(replace.(string.(sort(collect(reduce(union,dyn_exo_list)))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))
    dyn_ss          = Symbol.(replace.(string.(sort(collect(reduce(union,dyn_ss_list)))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => ""))

    SS_and_pars_names = vcat(Symbol.(replace.(string.(sort(union(ùìÇ.var,ùìÇ.exo_past,ùìÇ.exo_future))), r"·¥∏‚ÅΩ‚Åª?[‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ]+‚Åæ" => "")), ùìÇ.calibration_equations_parameters)


    dyn_var_future_idx  = indexin(dyn_var_future    , SS_and_pars_names)
    dyn_var_present_idx = indexin(dyn_var_present   , SS_and_pars_names)
    dyn_var_past_idx    = indexin(dyn_var_past      , SS_and_pars_names)
    dyn_ss_idx          = indexin(dyn_ss            , SS_and_pars_names)

    shocks_ss = zeros(length(dyn_exo))

    ùìÇ.solution.perturbation.auxilliary_indices = auxilliary_indices(dyn_var_future_idx, dyn_var_present_idx, dyn_var_past_idx, dyn_ss_idx, shocks_ss)


    # ùìÇ.model_third_order_derivatives = @RuntimeGeneratedFunction(mod_func5)
    # ùìÇ.model_third_order_derivatives = eval(mod_func5)


    # calib_eqs = []
    # for (i, eqs) in enumerate(ùìÇ.solved_vals) 
    #     varss = ùìÇ.solved_vars[i]
    #     push!(calib_eqs,:($varss = $eqs))
    # end

    # for varss in ùìÇ.exo
    #     push!(calib_eqs,:($varss = 0))
    # end

    # calib_pars = []
    # for (i, parss) in enumerate(ùìÇ.parameters)
    #     push!(calib_pars,:($parss = parameters[$i]))
    # end

    # var_out = []
    # ii =  1
    # for var in ùìÇ.var
    #     push!(var_out,:($var = SS[$ii]))
    #     ii += 1
    # end

    # par_out = []
    # for cal in ùìÇ.calibration_equations_parameters
    #     push!(par_out,:($cal = SS[$ii]))
    #     ii += 1
    # end

    # calib_pars = []
    # for (i, parss) in enumerate(ùìÇ.parameters)
    #     push!(calib_pars,:($parss = parameters[$i]))
    # end

    # test_func = :(function test_SS(parameters::Vector{Float64}, SS::Vector{Float64})
    #     $(calib_pars...) 
    #     $(var_out...)
    #     $(par_out...)
    #     [$(ùìÇ.ss_equations...),$(ùìÇ.calibration_equations...)]
    # end)

    # ùìÇ.solution.valid_steady_state_solution = @RuntimeGeneratedFunction(test_func)

    # ùìÇ.solution.outdated_algorithms = Set([:linear_time_iteration, :riccati, :quadratic_iteration, :first_order, :second_order, :third_order])
    return nothing
end



write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Nothing; verbose::Bool = true) = return parameters
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{Symbol,Float64}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{String,Float64}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters[1] |> Meta.parse |> replace_indices => parameters[2]), verbose = verbose)



write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{Symbol,Float64},Vararg{Pair{Symbol,Float64}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters), verbose = verbose)
# write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{Union{Symbol,String},Union{Float64,Int}},Vararg{Pair{Union{Symbol,String},Union{Float64,Int}}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters), verbose = verbose)
# write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{Symbol,Int},Vararg{Pair{String,Float64}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{String,Float64},Vararg{Pair{String,Float64}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict([i[1] |> Meta.parse |> replace_indices => i[2] for i in parameters])
, verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Pair{Symbol, Float64}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Pair{String, Float64}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict([i[1] |> Meta.parse |> replace_indices => i[2] for i in parameters]), verbose = verbose)


write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{Symbol,Int}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{String,Int}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}((parameters[1] |> Meta.parse |> replace_indices) => parameters[2]), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{Symbol,Int},Vararg{Pair{Symbol,Int}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{String,Int},Vararg{Pair{String,Int}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}([i[1] |> Meta.parse |> replace_indices => i[2] for i in parameters]), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Pair{Symbol, Int}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Pair{String, Int}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}([i[1] |> Meta.parse |> replace_indices => i[2] for i in parameters]), verbose = verbose)


write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{Symbol,Real}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Pair{String,Real}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}((parameters[1] |> Meta.parse |> replace_indices) => parameters[2]), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{Symbol,Real},Vararg{Pair{Symbol,Float64}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Pair{String,Real},Vararg{Pair{String,Float64}}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}([i[1] |> Meta.parse |> replace_indices => i[2] for i in parameters]), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Pair{Symbol, Real}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}(parameters), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Pair{String, Real}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Dict{Symbol,Float64}([i[1] |> Meta.parse |> replace_indices => i[2] for i in parameters]), verbose = verbose)



function write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Dict{Symbol,Float64}; verbose::Bool = true)
    if length(setdiff(collect(keys(parameters)),ùìÇ.parameters))>0
        println("Parameters not part of the model: ",setdiff(collect(keys(parameters)),ùìÇ.parameters))
        for kk in setdiff(collect(keys(parameters)),ùìÇ.parameters)
            delete!(parameters,kk)
        end
    end

    bounds_broken = false

    for i in 1:length(parameters)
        bnd_idx = findfirst(x->x==collect(keys(parameters))[i],ùìÇ.bounded_vars)
        if !isnothing(bnd_idx)
            if collect(values(parameters))[i] > ùìÇ.upper_bounds[bnd_idx]
                # println("Calibration is out of bounds for ",collect(keys(parameters))[i],":\t",collect(values(parameters))[i]," > ",ùìÇ.upper_bounds[bnd_idx] + eps())
                println("Bounds error for ",collect(keys(parameters))[i]," < ",ùìÇ.upper_bounds[bnd_idx] + eps(),"\tparameter value: ",collect(values(parameters))[i])
                bounds_broken = true
                continue
            end
            if collect(values(parameters))[i] < ùìÇ.lower_bounds[bnd_idx]
                # println("Calibration is out of bounds for ",collect(keys(parameters))[i],":\t",collect(values(parameters))[i]," < ",ùìÇ.lower_bounds[bnd_idx] - eps())
                println("Bounds error for ",collect(keys(parameters))[i]," > ",ùìÇ.lower_bounds[bnd_idx] + eps(),"\tparameter value: ",collect(values(parameters))[i])
                bounds_broken = true
                continue
            end
        end
    end

    if bounds_broken
        println("Parameters unchanged.")
    else
        ntrsct_idx = map(x-> getindex(1:length(ùìÇ.parameter_values),ùìÇ.parameters .== x)[1],collect(keys(parameters)))
        

        
        if !all(ùìÇ.parameter_values[ntrsct_idx] .== collect(values(parameters)))
            if verbose println("Parameter changes: ") end
            ùìÇ.solution.outdated_algorithms = Set(all_available_algorithms)
        end
            
        for i in 1:length(parameters)
            if ùìÇ.parameter_values[ntrsct_idx[i]] != collect(values(parameters))[i]
                if collect(keys(parameters))[i] ‚àà ùìÇ.SS_dependencies[end][2] && ùìÇ.solution.outdated_NSSS == false
                    ùìÇ.solution.outdated_NSSS = true
                end
                
                if verbose println("\t",ùìÇ.parameters[ntrsct_idx[i]],"\tfrom ",ùìÇ.parameter_values[ntrsct_idx[i]],"\tto ",collect(values(parameters))[i]) end

                ùìÇ.parameter_values[ntrsct_idx[i]] = collect(values(parameters))[i]
            end
        end
    end

    if ùìÇ.solution.outdated_NSSS == true && verbose println("New parameters changed the steady state.") end
end


write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Int,Vararg{Int}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Float64.(vec(collect(parameters))), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Matrix{Int}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Float64.(vec(collect(parameters))), verbose = verbose)

write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Float64,Vararg{Float64}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, vec(collect(parameters)), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Matrix{Float64}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, vec(collect(parameters)), verbose = verbose)

write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Tuple{Real,Vararg{Real}}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Float64.(vec(collect(parameters))), verbose = verbose)
write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Matrix{Real}; verbose::Bool = true) = write_parameters_input!(ùìÇ::‚Ñ≥, Float64.(vec(collect(parameters))), verbose = verbose)



function write_parameters_input!(ùìÇ::‚Ñ≥, parameters::Vector{Float64}; verbose::Bool = true)
    if length(parameters) > length(ùìÇ.parameter_values)
        println("Model has "*string(length(ùìÇ.parameter_values))*" parameters. "*string(length(parameters))*" were provided. The following will be ignored: "*string(parameters[length(ùìÇ.parameter_values)+1:end]...))

        parameters = parameters[1:length(ùìÇ.parameter_values)]
    end

    bounds_broken = false

    for i in 1:length(parameters)
        bnd_idx = findfirst(x -> x == ùìÇ.parameters[i], ùìÇ.bounded_vars)
        if !isnothing(bnd_idx)
            if collect(values(parameters))[i] > ùìÇ.upper_bounds[bnd_idx]
                println("Bounds error for ",ùìÇ.parameters[i]," < ",ùìÇ.upper_bounds[bnd_idx] + eps(),"\tparameter value: ",ùìÇ.parameter_values[i])
                bounds_broken = true
                continue
            end
            if collect(values(parameters))[i] < ùìÇ.lower_bounds[bnd_idx]
                println("Bounds error for ",ùìÇ.parameters[i]," > ",ùìÇ.lower_bounds[bnd_idx] + eps(),"\tparameter value: ",ùìÇ.parameter_values[i])
                bounds_broken = true
                continue
            end
        end
    end

    if bounds_broken
        println("Parameters unchanged.")
    else
        if !all(parameters .== ùìÇ.parameter_values[1:length(parameters)])
            ùìÇ.solution.outdated_algorithms = Set(all_available_algorithms)

            match_idx = []
            for (i, v) in enumerate(parameters)
                if v != ùìÇ.parameter_values[i]
                    push!(match_idx,i)
                end
            end
            
            changed_vals = parameters[match_idx]
            changed_pars = ùìÇ.parameters[match_idx]

            # for p in changes_pars
            #     if p ‚àà ùìÇ.SS_dependencies[end][2] && ùìÇ.solution.outdated_NSSS == false
                    ùìÇ.solution.outdated_NSSS = true # fix the SS_dependencies
                    # println("SS outdated.")
            #     end
            # end

            if verbose 
                println("Parameter changes: ")
                for (i,m) in enumerate(match_idx)
                    println("\t",changed_pars[i],"\tfrom ",ùìÇ.parameter_values[m],"\tto ",changed_vals[i])
                end
            end

            ùìÇ.parameter_values[match_idx] = parameters[match_idx]
        end
    end
    if ùìÇ.solution.outdated_NSSS == true && verbose println("New parameters changed the steady state.") end
end


# helper for get functions
function SSS_third_order_parameter_derivatives(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, parameters_idx, ùìÇ::‚Ñ≥; verbose::Bool = false, pruning::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    SSS = calculate_third_order_stochastic_steady_state(params, ùìÇ, verbose = verbose, pruning = pruning)

    @assert SSS[2] "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

    return SSS
end


# helper for get functions
function SSS_third_order_parameter_derivatives(parameters::‚Ñ±.Dual{Z,S,N}, parameters_idx::Int, ùìÇ::‚Ñ≥; verbose::Bool = false, pruning::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    SSS = calculate_third_order_stochastic_steady_state(params, ùìÇ, verbose = verbose, pruning = pruning)

    @assert SSS[2] "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

    return SSS
end


# helper for get functions
function SSS_second_order_parameter_derivatives(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, parameters_idx, ùìÇ::‚Ñ≥; verbose::Bool = false, pruning::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    SSS = calculate_second_order_stochastic_steady_state(params, ùìÇ, verbose = verbose, pruning = pruning)

    @assert SSS[2] "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

    return SSS
end


# helper for get functions
function SSS_second_order_parameter_derivatives(parameters::‚Ñ±.Dual{Z,S,N}, parameters_idx::Int, ùìÇ::‚Ñ≥; verbose::Bool = false, pruning::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    SSS = calculate_second_order_stochastic_steady_state(params, ùìÇ, verbose = verbose, pruning = pruning)

    @assert SSS[2] "Solution does not have a stochastic steady state. Try reducing shock sizes by multiplying them with a number < 1."

    return SSS
end


# helper for get functions
function SS_parameter_derivatives(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, parameters_idx, ùìÇ::‚Ñ≥; verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    ùìÇ.SS_solve_func(params, ùìÇ, verbose, false, ùìÇ.solver_parameters)
end


# helper for get functions
function SS_parameter_derivatives(parameters::‚Ñ±.Dual{Z,S,N}, parameters_idx::Int, ùìÇ::‚Ñ≥; verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    ùìÇ.SS_solve_func(params, ùìÇ, verbose, false, ùìÇ.solver_parameters)
end


# helper for get functions
function covariance_parameter_derivatives(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, parameters_idx, ùìÇ::‚Ñ≥; verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}},max.(‚Ñí.diag(calculate_covariance(params, ùìÇ, verbose = verbose)[1]),eps(Float64)))
end


# helper for get functions
function covariance_parameter_derivatives(parameters::‚Ñ±.Dual{Z,S,N}, parameters_idx::Int, ùìÇ::‚Ñ≥; verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}},max.(‚Ñí.diag(calculate_covariance(params, ùìÇ, verbose = verbose)[1]),eps(Float64)))
end




# helper for get functions
function covariance_parameter_derivatives_second_order(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, parameters_idx, ùìÇ::‚Ñ≥; verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}},max.(‚Ñí.diag(calculate_second_order_moments(params, ùìÇ, verbose = verbose)[1]),eps(Float64)))
end


# helper for get functions
function covariance_parameter_derivatives_second_order(parameters::‚Ñ±.Dual{Z,S,N}, parameters_idx::Int, ùìÇ::‚Ñ≥; verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}},max.(‚Ñí.diag(calculate_second_order_moments(params, ùìÇ, verbose = verbose)[1]),eps(Float64)))
end


# helper for get functions
function covariance_parameter_derivatives_third_order(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, 
                                                        variables::Union{Symbol_input,String_input}, 
                                                        parameters_idx, 
                                                        ùìÇ::‚Ñ≥;
                                                        dependencies_tol::AbstractFloat = 1e-12,
                                                        verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}},max.(‚Ñí.diag(calculate_third_order_moments(params, variables, ùìÇ, dependencies_tol = dependencies_tol, verbose = verbose)[1]),eps(Float64)))
end


# helper for get functions
function covariance_parameter_derivatives_third_order(parameters::‚Ñ±.Dual{Z,S,N}, 
                                                        variables::Union{Symbol_input,String_input}, 
                                                        parameters_idx::Int, 
                                                        ùìÇ::‚Ñ≥; 
                                                        dependencies_tol::AbstractFloat = 1e-12,
                                                        verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}},max.(‚Ñí.diag(calculate_third_order_moments(params, variables, ùìÇ, dependencies_tol = dependencies_tol, verbose = verbose)[1]),eps(Float64)))
end


# helper for get functions
function mean_parameter_derivatives(parameters::Vector{‚Ñ±.Dual{Z,S,N}}, parameters_idx, ùìÇ::‚Ñ≥; algorithm::Symbol = :pruned_second_order, verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}}, calculate_mean(params, ùìÇ, algorithm = algorithm, verbose = verbose)[1])
end


# helper for get functions
function mean_parameter_derivatives(parameters::‚Ñ±.Dual{Z,S,N}, parameters_idx::Int, ùìÇ::‚Ñ≥; algorithm::Symbol = :pruned_second_order, verbose::Bool = false) where {Z,S,N}
    params = copy(ùìÇ.parameter_values)
    params = convert(Vector{‚Ñ±.Dual{Z,S,N}},params)
    params[parameters_idx] = parameters
    convert(Vector{‚Ñ±.Dual{Z,S,N}}, calculate_mean(params, ùìÇ, algorithm = algorithm, verbose = verbose)[1])
end



function calculate_jacobian(parameters::Vector{M}, SS_and_pars::AbstractArray{N}, ùìÇ::‚Ñ≥) where {M,N}
    SS = SS_and_pars[1:end - length(ùìÇ.calibration_equations)]
    calibrated_parameters = SS_and_pars[(end - length(ùìÇ.calibration_equations)+1):end]
    # par = ComponentVector(vcat(parameters,calibrated_parameters),Axis(vcat(ùìÇ.parameters,ùìÇ.calibration_equations_parameters)))
    par = vcat(parameters,calibrated_parameters)
    
    dyn_var_future_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_future_idx
    dyn_var_present_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_present_idx
    dyn_var_past_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_past_idx
    dyn_ss_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_ss_idx

    shocks_ss = ùìÇ.solution.perturbation.auxilliary_indices.shocks_ss

    # return ‚Ñ±.jacobian(x -> ùìÇ.model_function(x, par, SS), [SS_future; SS_present; SS_past; shocks_ss])#, SS_and_pars
    # return Matrix(ùìÇ.model_jacobian(([SS[[dyn_var_future_idx; dyn_var_present_idx; dyn_var_past_idx]]; shocks_ss], par, SS[dyn_ss_idx])))
    return ùìÇ.model_jacobian([SS[[dyn_var_future_idx; dyn_var_present_idx; dyn_var_past_idx]]; shocks_ss], par, SS[dyn_ss_idx])
end



function calculate_hessian(parameters::Vector{M}, SS_and_pars::Vector{N}, ùìÇ::‚Ñ≥) where {M,N}
    SS = SS_and_pars[1:end - length(ùìÇ.calibration_equations)]
    calibrated_parameters = SS_and_pars[(end - length(ùìÇ.calibration_equations)+1):end]
    
    par = vcat(parameters,calibrated_parameters)

    dyn_var_future_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_future_idx
    dyn_var_present_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_present_idx
    dyn_var_past_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_past_idx
    dyn_ss_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_ss_idx

    shocks_ss = ùìÇ.solution.perturbation.auxilliary_indices.shocks_ss

    # nk = ùìÇ.timings.nPast_not_future_and_mixed + ùìÇ.timings.nVars + ùìÇ.timings.nFuture_not_past_and_mixed + length(ùìÇ.exo)
        
    # return sparse(reshape(‚Ñ±.jacobian(x -> ‚Ñ±.jacobian(x -> (ùìÇ.model_function(x, par, SS)), x), [SS_future; SS_present; SS_past; shocks_ss] ), ùìÇ.timings.nVars, nk^2))#, SS_and_pars
    # return ùìÇ.model_hessian([SS[[dyn_var_future_idx; dyn_var_present_idx; dyn_var_past_idx]]; shocks_ss], par, SS[dyn_ss_idx])

    second_out =  [f([SS[[dyn_var_future_idx; dyn_var_present_idx; dyn_var_past_idx]]; shocks_ss], par, SS[dyn_ss_idx]) for f in ùìÇ.model_hessian]
    
    vals = [i[1] for i in second_out]
    rows = [i[2] for i in second_out]
    cols = [i[3] for i in second_out]

    vals = convert(Vector{M}, vals)

    # nk = ùìÇ.timings.nPast_not_future_and_mixed + ùìÇ.timings.nVars + ùìÇ.timings.nFuture_not_past_and_mixed + length(ùìÇ.exo)
    # sparse(rows, cols, vals, length(ùìÇ.dyn_equations), nk^2)
    sparse(rows, cols, vals, length(ùìÇ.dyn_equations), size(ùìÇ.solution.perturbation.second_order_auxilliary_matrices.ùêî‚àá‚ÇÇ,1)) * ùìÇ.solution.perturbation.second_order_auxilliary_matrices.ùêî‚àá‚ÇÇ
end



function calculate_third_order_derivatives(parameters::Vector{M}, SS_and_pars::Vector{N}, ùìÇ::‚Ñ≥) where {M,N}
    
    SS = SS_and_pars[1:end - length(ùìÇ.calibration_equations)]
    calibrated_parameters = SS_and_pars[(end - length(ùìÇ.calibration_equations)+1):end]
    
    par = vcat(parameters,calibrated_parameters)

    dyn_var_future_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_future_idx
    dyn_var_present_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_present_idx
    dyn_var_past_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_var_past_idx
    dyn_ss_idx = ùìÇ.solution.perturbation.auxilliary_indices.dyn_ss_idx

    shocks_ss = ùìÇ.solution.perturbation.auxilliary_indices.shocks_ss

    # return sparse(reshape(‚Ñ±.jacobian(x -> ‚Ñ±.jacobian(x -> ‚Ñ±.jacobian(x -> ùìÇ.model_function(x, par, SS), x), x), [SS_future; SS_present; SS_past; shocks_ss] ), ùìÇ.timings.nVars, nk^3))#, SS_and_pars
    # return ùìÇ.model_third_order_derivatives([SS[[dyn_var_future_idx; dyn_var_present_idx; dyn_var_past_idx]]; shocks_ss], par, SS[dyn_ss_idx])
    
    
    third_out =  [f([SS[[dyn_var_future_idx; dyn_var_present_idx; dyn_var_past_idx]]; shocks_ss], par, SS[dyn_ss_idx]) for f in ùìÇ.model_third_order_derivatives]
    
    vals = [i[1] for i in third_out]
    rows = [i[2] for i in third_out]
    cols = [i[3] for i in third_out]

    vals = convert(Vector{M}, vals)

    # nk = ùìÇ.timings.nPast_not_future_and_mixed + ùìÇ.timings.nVars + ùìÇ.timings.nFuture_not_past_and_mixed + length(ùìÇ.exo)
    # sparse(rows, cols, vals, length(ùìÇ.dyn_equations), nk^3)
    sparse(rows, cols, vals, length(ùìÇ.dyn_equations), size(ùìÇ.solution.perturbation.third_order_auxilliary_matrices.ùêî‚àá‚ÇÉ,1)) * ùìÇ.solution.perturbation.third_order_auxilliary_matrices.ùêî‚àá‚ÇÉ
end



function calculate_linear_time_iteration_solution(‚àá‚ÇÅ::AbstractMatrix{Float64}; T::timings, tol::AbstractFloat = eps())
    expand = @views [‚Ñí.diagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:],
            ‚Ñí.diagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]] 

    ‚àá‚Çä = @views ‚àá‚ÇÅ[:,1:T.nFuture_not_past_and_mixed] * expand[1]
    ‚àá‚ÇÄ = @views ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    ‚àá‚Çã = @views ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1,T.nPast_not_future_and_mixed)] * expand[2]
    ‚àá‚Çë = @views ‚àá‚ÇÅ[:,(T.nFuture_not_past_and_mixed + T.nVars + T.nPast_not_future_and_mixed + 1):end]

    maxiter = 1000

    F = zero(‚àá‚Çã)
    S = zero(‚àá‚Çã)
    # F = randn(size(‚àá‚Çã))
    # S = randn(size(‚àá‚Çã))
    
    error = one(tol) + tol
    iter = 0

    while error > tol && iter <= maxiter
        FÃÇ = -(‚àá‚Çä * F + ‚àá‚ÇÄ) \ ‚àá‚Çã
        SÃÇ = -(‚àá‚Çã * S + ‚àá‚ÇÄ) \ ‚àá‚Çä
        
        error = maximum(‚àá‚Çä * FÃÇ * FÃÇ + ‚àá‚ÇÄ * FÃÇ + ‚àá‚Çã)
        
        F = FÃÇ
        S = SÃÇ
        
        iter += 1
    end

    if iter == maxiter
        outmessage = "Convergence Failed. Max Iterations Reached. Error: $error"
    elseif maximum(abs,‚Ñí.eigen(F).values) > 1.0
        outmessage = "No Stable Solution Exists!"
    elseif maximum(abs,‚Ñí.eigen(S).values) > 1.0
        outmessage = "Multiple Solutions Exist!"
    end

    Q = -(‚àá‚Çä * F + ‚àá‚ÇÄ) \ ‚àá‚Çë

    @views hcat(F[:,T.past_not_future_and_mixed_idx],Q)
end



function calculate_quadratic_iteration_solution(‚àá‚ÇÅ::AbstractMatrix{Float64}; T::timings, tol::AbstractFloat = eps())
    # see Binder and Pesaran (1997) for more details on this approach
    expand = @views [‚Ñí.diagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:],
            ‚Ñí.diagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]] 

    ‚àá‚Çä = @views ‚àá‚ÇÅ[:,1:T.nFuture_not_past_and_mixed] * expand[1]
    ‚àá‚ÇÄ = @views ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    ‚àá‚Çã = @views ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1,T.nPast_not_future_and_mixed)] * expand[2]
    ‚àá‚Çë = @views ‚àá‚ÇÅ[:,(T.nFuture_not_past_and_mixed + T.nVars + T.nPast_not_future_and_mixed + 1):end]
    
    ‚àáÃÇ‚ÇÄ =  RF.lu(‚àá‚ÇÄ)
    
    A = ‚àáÃÇ‚ÇÄ \ ‚àá‚Çã
    B = ‚àáÃÇ‚ÇÄ \ ‚àá‚Çä

    C = similar(A)
    CÃÑ = similar(A)

    sol = speedmapping(zero(A); m! = (CÃÑ, C) -> CÃÑ .=  A + B * C^2, tol = tol, maps_limit = 10000)

    C = -sol.minimizer

    D = -(‚àá‚Çä * C + ‚àá‚ÇÄ) \ ‚àá‚Çë

    @views hcat(C[:,T.past_not_future_and_mixed_idx],D), sol.converged
end



<<<<<<< HEAD
function riccati_forward(‚àá‚ÇÅ::Matrix{Float64}; T::timings, explosive::Bool = false)
=======
function riccati_forward(‚àá‚ÇÅ::Matrix{Float64}; T::timings, explosive::Bool = false)::Tuple{Matrix{Float64},Bool}
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    ‚àá‚Çä = @view ‚àá‚ÇÅ[:,1:T.nFuture_not_past_and_mixed]
    ‚àá‚ÇÄ = @view ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed .+ range(1, T.nVars)]
    ‚àá‚Çã = @view ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1, T.nPast_not_future_and_mixed)]

    Q    = ‚Ñí.qr(collect(‚àá‚ÇÄ[:,T.present_only_idx]))
    Qinv = Q.Q'

    A‚Çä = Qinv * ‚àá‚Çä
    A‚ÇÄ = Qinv * ‚àá‚ÇÄ
    A‚Çã = Qinv * ‚àá‚Çã

    dynIndex = T.nPresent_only+1:T.nVars

    AÃÉ‚Çä  = @view A‚Çä[dynIndex,:]
    AÃÉ‚Çã  = @view A‚Çã[dynIndex,:]
    AÃÉ‚ÇÄ‚Çä = @view A‚ÇÄ[dynIndex, T.future_not_past_and_mixed_idx]
    AÃÉ‚ÇÄ‚Çã = @views A‚ÇÄ[dynIndex, T.past_not_future_idx] * ‚Ñí.diagm(ones(T.nPast_not_future_and_mixed))[T.not_mixed_in_past_idx,:]
    
    Z‚Çä = zeros(T.nMixed,T.nFuture_not_past_and_mixed)
    I‚Çä = @view ‚Ñí.diagm(ones(T.nFuture_not_past_and_mixed))[T.mixed_in_future_idx,:]

    Z‚Çã = zeros(T.nMixed,T.nPast_not_future_and_mixed)
    I‚Çã = @view ‚Ñí.diagm(ones(T.nPast_not_future_and_mixed))[T.mixed_in_past_idx,:]

    D = vcat(hcat(AÃÉ‚ÇÄ‚Çã, AÃÉ‚Çä), hcat(I‚Çã, Z‚Çä))
    E = vcat(hcat(-AÃÉ‚Çã,-AÃÉ‚ÇÄ‚Çä), hcat(Z‚Çã, I‚Çä))
    # this is the companion form and by itself the linearisation of the matrix polynomial used in the linear time iteration method. see: https://opus4.kobv.de/opus4-matheon/files/209/240.pdf
    schdcmp = ‚Ñí.schur(D,E)

    if explosive # returns false for NaN gen. eigenvalue which is correct here bc they are > 1
        eigenselect = abs.(schdcmp.Œ≤ ./ schdcmp.Œ±) .>= 1

        ‚Ñí.ordschur!(schdcmp, eigenselect)

        Z‚ÇÇ‚ÇÅ = @view schdcmp.Z[T.nPast_not_future_and_mixed+1:end, 1:T.nPast_not_future_and_mixed]
        Z‚ÇÅ‚ÇÅ = @view schdcmp.Z[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        S‚ÇÅ‚ÇÅ    = @view schdcmp.S[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]
        T‚ÇÅ‚ÇÅ    = @view schdcmp.T[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        ZÃÇ‚ÇÅ‚ÇÅ = RF.lu(Z‚ÇÅ‚ÇÅ, check = false)

        if !‚Ñí.issuccess(ZÃÇ‚ÇÅ‚ÇÅ)
<<<<<<< HEAD
            return zeros(T.nVars,T.nPast_not_future_and_mixed), ‚Ñí.issuccess(ZÃÇ‚ÇÅ‚ÇÅ)
        end

=======
            ZÃÇ‚ÇÅ‚ÇÅ = ‚Ñí.svd(Z‚ÇÅ‚ÇÅ, check = false)
        end

        if !‚Ñí.issuccess(ZÃÇ‚ÇÅ‚ÇÅ)
            return zeros(T.nVars,T.nPast_not_future_and_mixed), false
        end
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    else
        eigenselect = abs.(schdcmp.Œ≤ ./ schdcmp.Œ±) .< 1

        ‚Ñí.ordschur!(schdcmp, eigenselect)

        Z‚ÇÇ‚ÇÅ = @view schdcmp.Z[T.nPast_not_future_and_mixed+1:end, 1:T.nPast_not_future_and_mixed]
        Z‚ÇÅ‚ÇÅ = @view schdcmp.Z[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

        S‚ÇÅ‚ÇÅ    = @view schdcmp.S[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]
        T‚ÇÅ‚ÇÅ    = @view schdcmp.T[1:T.nPast_not_future_and_mixed, 1:T.nPast_not_future_and_mixed]

<<<<<<< HEAD
        ZÃÇ‚ÇÅ‚ÇÅ = RF.lu(Z‚ÇÅ‚ÇÅ, check = false)

        if !‚Ñí.issuccess(ZÃÇ‚ÇÅ‚ÇÅ)
            return zeros(T.nVars,T.nPast_not_future_and_mixed), ‚Ñí.issuccess(ZÃÇ‚ÇÅ‚ÇÅ)
        end
    end

    SÃÇ‚ÇÅ‚ÇÅ = RF.lu(S‚ÇÅ‚ÇÅ, check = false)

    if !‚Ñí.issuccess(SÃÇ‚ÇÅ‚ÇÅ)
        return zeros(T.nVars,T.nPast_not_future_and_mixed), ‚Ñí.issuccess(SÃÇ‚ÇÅ‚ÇÅ)
    end

=======

        ZÃÇ‚ÇÅ‚ÇÅ = RF.lu(Z‚ÇÅ‚ÇÅ, check = false)

        if !‚Ñí.issuccess(ZÃÇ‚ÇÅ‚ÇÅ)
            return zeros(T.nVars,T.nPast_not_future_and_mixed), false
        end
    end
    
    SÃÇ‚ÇÅ‚ÇÅ = RF.lu(S‚ÇÅ‚ÇÅ, check = false)

    if !‚Ñí.issuccess(SÃÇ‚ÇÅ‚ÇÅ)
        return zeros(T.nVars,T.nPast_not_future_and_mixed), false
    end
    
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    D      = Z‚ÇÇ‚ÇÅ / ZÃÇ‚ÇÅ‚ÇÅ
    L      = Z‚ÇÅ‚ÇÅ * (SÃÇ‚ÇÅ‚ÇÅ \ T‚ÇÅ‚ÇÅ) / ZÃÇ‚ÇÅ‚ÇÅ

    sol = @views vcat(L[T.not_mixed_in_past_idx,:], D)

    AÃÑ‚ÇÄ·µ§  = @view A‚ÇÄ[1:T.nPresent_only, T.present_only_idx]
    A‚Çä·µ§  = @view A‚Çä[1:T.nPresent_only,:]
    AÃÉ‚ÇÄ·µ§  = @view A‚ÇÄ[1:T.nPresent_only, T.present_but_not_only_idx]
    A‚Çã·µ§  = @view A‚Çã[1:T.nPresent_only,:]
<<<<<<< HEAD
    
    AÃÑÃÇ‚ÇÄ·µ§ = RF.lu(AÃÑ‚ÇÄ·µ§, check = false)

    if !‚Ñí.issuccess(AÃÑÃÇ‚ÇÄ·µ§)
        return zeros(T.nVars,T.nPast_not_future_and_mixed), ‚Ñí.issuccess(AÃÑÃÇ‚ÇÄ·µ§)
    end

    A    = @views vcat(-(AÃÑÃÇ‚ÇÄ·µ§ \ (A‚Çä·µ§ * D * L + AÃÉ‚ÇÄ·µ§ * sol[T.dynamic_order,:] + A‚Çã·µ§)), sol)
    
=======

    AÃÑÃÇ‚ÇÄ·µ§ = RF.lu(AÃÑ‚ÇÄ·µ§, check = false)

    if !‚Ñí.issuccess(AÃÑÃÇ‚ÇÄ·µ§)
        AÃÑÃÇ‚ÇÄ·µ§ = ‚Ñí.svd(collect(AÃÑ‚ÇÄ·µ§))
    end

    A    = @views vcat(-(AÃÑÃÇ‚ÇÄ·µ§ \ (A‚Çä·µ§ * D * L + AÃÉ‚ÇÄ·µ§ * sol[T.dynamic_order,:] + A‚Çã·µ§)), sol)
    
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    return @view(A[T.reorder,:]), true
end

function riccati_conditions(‚àá‚ÇÅ::AbstractMatrix{<: Real}, sol_d::AbstractMatrix{<: Real}, solved::Bool; T::timings, explosive::Bool = false) 
    expand = @ignore_derivatives @views [‚Ñí.diagm(ones(T.nVars))[T.future_not_past_and_mixed_idx,:], ‚Ñí.diagm(ones(T.nVars))[T.past_not_future_and_mixed_idx,:]] 

    A = @views ‚àá‚ÇÅ[:,1:T.nFuture_not_past_and_mixed] * expand[1]
    B = @views ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    C = @views ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed + T.nVars .+ range(1,T.nPast_not_future_and_mixed)] * expand[2]

    sol_buf = sol_d * expand[2]

    err1 = A * sol_buf * sol_buf + B * sol_buf + C

    @view err1[:,T.past_not_future_and_mixed_idx]
end


function riccati_forward(‚àá‚ÇÅ::Matrix{‚Ñ±.Dual{Z,S,N}}; T::timings, explosive::Bool = false) where {Z,S,N}
    # unpack: AoS -> SoA
    ‚àáÃÇ‚ÇÅ = ‚Ñ±.value.(‚àá‚ÇÅ)
    # you can play with the dimension here, sometimes it makes sense to transpose
    ps = mapreduce(‚Ñ±.partials, hcat, ‚àá‚ÇÅ)'

<<<<<<< HEAD
    # get f(vs)
    val, success = riccati_forward(‚àáÃÇ‚ÇÅ;T = T, explosive = explosive)

    if success
        # get J(f, vs) * ps (cheating). Write your custom rule here
        B = ‚Ñ±.jacobian(x -> riccati_conditions(x, val; T = T), ‚àáÃÇ‚ÇÅ)
        A = ‚Ñ±.jacobian(x -> riccati_conditions(‚àáÃÇ‚ÇÅ, x; T = T), val)
        # B = Zygote.jacobian(x -> riccati_conditions(x, val; T = T), ‚àáÃÇ‚ÇÅ)[1]
        # A = Zygote.jacobian(x -> riccati_conditions(‚àáÃÇ‚ÇÅ, x; T = T), val)[1]
    
        AÃÇ = RF.lu(A, check = false)
    
=======
    val, solved = riccati_forward(‚àáÃÇ‚ÇÅ;T = T, explosive = explosive)

    if solved
        # get J(f, vs) * ps (cheating). Write your custom rule here
        B = ‚Ñ±.jacobian(x -> riccati_conditions(x, val, solved; T = T), ‚àáÃÇ‚ÇÅ)
        A = ‚Ñ±.jacobian(x -> riccati_conditions(‚àáÃÇ‚ÇÅ, x, solved; T = T), val)


        AÃÇ = RF.lu(A, check = false)

>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
        if !‚Ñí.issuccess(AÃÇ)
            AÃÇ = ‚Ñí.svd(A)
        end
        
        jvp = -(AÃÇ \ B) * ps
    else
<<<<<<< HEAD
        jvp = fill(0,length(val),length(‚àá‚ÇÅ)) * ps
=======
        jvp = fill(0,length(val),length(‚àáÃÇ‚ÇÅ)) * ps
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
    end

    # pack: SoA -> AoS
    return reshape(map(val, eachrow(jvp)) do v, p
        ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
<<<<<<< HEAD
    end,size(val)), success
=======
    end,size(val)), solved
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
end


riccati_AD_direct = ID.ImplicitFunction(riccati_forward, 
                                    riccati_conditions; 
                                    linear_solver = ID.DirectLinearSolver())

<<<<<<< HEAD
function calculate_first_order_solution(‚àá‚ÇÅ::Matrix{S}; T::timings, explosive::Bool = false) where S <: Real
    # A = riccati_AD(‚àá‚ÇÅ, T = T, explosive = explosive)
    riccati = riccati_(‚àá‚ÇÅ, T = T, explosive = explosive)
    A, success = riccati(‚àá‚ÇÅ)
    # A = riccati_forward(‚àá‚ÇÅ, T = T, explosive = explosive)
=======
riccati_AD = ID.ImplicitFunction(riccati_forward, riccati_conditions) # doesnt converge!?


function calculate_first_order_solution(‚àá‚ÇÅ::Matrix{S}; T::timings, explosive::Bool = false)::Tuple{Matrix{S},Bool} where S <: Real
    A, solved = riccati_AD(‚àá‚ÇÅ; T = T, explosive = explosive)

    if !solved
        return hcat(A, zeros(size(A,1),T.nExo)), solved
    end
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806

    if !success
        return hcat(A, zeros(T.nVars,T.nExo)), success
    end

    Jm = @view(‚Ñí.diagm(ones(S,T.nVars))[T.past_not_future_and_mixed_idx,:])
    
    ‚àá‚Çä = @views ‚àá‚ÇÅ[:,1:T.nFuture_not_past_and_mixed] * ‚Ñí.diagm(ones(S,T.nVars))[T.future_not_past_and_mixed_idx,:]
    ‚àá‚ÇÄ = @view ‚àá‚ÇÅ[:,T.nFuture_not_past_and_mixed .+ range(1,T.nVars)]
    ‚àá‚Çë = @view ‚àá‚ÇÅ[:,(T.nFuture_not_past_and_mixed + T.nVars + T.nPast_not_future_and_mixed + 1):end]

    B = -((‚àá‚Çä * A * Jm + ‚àá‚ÇÄ) \ ‚àá‚Çë)

<<<<<<< HEAD
    return hcat(A, B), success
=======
    return hcat(A, B), solved
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806
end


function separate_values_and_partials_from_sparsevec_dual(V::SparseVector{‚Ñ±.Dual{Z,S,N}}; tol::AbstractFloat = eps()) where {Z,S,N}
    nrows = length(V)
    ncols = length(V.nzval[1].partials)

    rows = Int[]
    cols = Int[]

    prtls = Float64[]

    for (i,v) in enumerate(V.nzind)
        for (k,w) in enumerate(V.nzval[i].partials)
            if abs(w) > tol
                push!(rows,v)
                push!(cols,k)
                push!(prtls,w)
            end
        end
    end

    vvals = sparsevec(V.nzind,[i.value for i in V.nzval],nrows)
    ps = sparse(rows,cols,prtls,nrows,ncols)

    return vvals, ps
end


function calculate_second_order_solution(‚àá‚ÇÅ::AbstractMatrix{<: Real}, #first order derivatives
                                            ‚àá‚ÇÇ::SparseMatrixCSC{<: Real}, #second order derivatives
                                            ùë∫‚ÇÅ::AbstractMatrix{<: Real},#first order solution
                                            M‚ÇÇ::second_order_auxilliary_matrices;  # aux matrices
                                            T::timings,
                                            tol::AbstractFloat = eps())
    # inspired by Levintal

    # Indices and number of variables
    i‚Çä = T.future_not_past_and_mixed_idx;
    i‚Çã = T.past_not_future_and_mixed_idx;

    n‚Çã = T.nPast_not_future_and_mixed
    n‚Çä = T.nFuture_not_past_and_mixed
    n‚Çë = T.nExo;
    n  = T.nVars
    n‚Çë‚Çã = n‚Çã + 1 + n‚Çë

    # 1st order solution
    ùêí‚ÇÅ = @views [ùë∫‚ÇÅ[:,1:n‚Çã] zeros(n) ùë∫‚ÇÅ[:,n‚Çã+1:end]] |> sparse
    droptol!(ùêí‚ÇÅ,tol)

    ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë = @views [ùêí‚ÇÅ[i‚Çã,:]; zeros(n‚Çë + 1, n‚Çã) spdiagm(ones(n‚Çë + 1))[1,:] zeros(n‚Çë + 1, n‚Çë)];
    
    ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã = @views [(ùêí‚ÇÅ * ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)[i‚Çä,:]
                                ùêí‚ÇÅ
                                spdiagm(ones(n‚Çë‚Çã))[[range(1,n‚Çã)...,n‚Çã + 1 .+ range(1,n‚Çë)...],:]];

    ùêí‚ÇÅ‚Çä‚ï±ùüé = @views [ùêí‚ÇÅ[i‚Çä,:]
                    zeros(n‚Çã + n + n‚Çë, n‚Çë‚Çã)];


    ‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ = @views -‚àá‚ÇÅ[:,1:n‚Çä] * ùêí‚ÇÅ[i‚Çä,1:n‚Çã] * ‚Ñí.diagm(ones(n))[i‚Çã,:] - ‚àá‚ÇÅ[:,range(1,n) .+ n‚Çä]

    spinv = sparse(inv(‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ))
    droptol!(spinv,tol)

    # ‚àá‚ÇÇ‚é∏k‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã‚ûïùõîkùêí‚ÇÅ‚Çä‚ï±ùüé‚éπ = - ‚àá‚ÇÇ * sparse(‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã) + ‚Ñí.kron(ùêí‚ÇÅ‚Çä‚ï±ùüé, ùêí‚ÇÅ‚Çä‚ï±ùüé) * M‚ÇÇ.ùõî) * M‚ÇÇ.ùêÇ‚ÇÇ 
    ‚àá‚ÇÇ‚é∏k‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã‚ûïùõîkùêí‚ÇÅ‚Çä‚ï±ùüé‚éπ = -(mat_mult_kron(‚àá‚ÇÇ, ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã) + mat_mult_kron(‚àá‚ÇÇ, ùêí‚ÇÅ‚Çä‚ï±ùüé, ùêí‚ÇÅ‚Çä‚ï±ùüé) * M‚ÇÇ.ùõî) * M‚ÇÇ.ùêÇ‚ÇÇ 

    X = spinv * ‚àá‚ÇÇ‚é∏k‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã‚ûïùõîkùêí‚ÇÅ‚Çä‚ï±ùüé‚éπ
    droptol!(X,tol)

    ‚àá‚ÇÅ‚Çä = @views sparse(‚àá‚ÇÅ[:,1:n‚Çä] * spdiagm(ones(n))[i‚Çä,:])

    B = spinv * ‚àá‚ÇÅ‚Çä
    droptol!(B,tol)

    C = (M‚ÇÇ.ùêî‚ÇÇ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë, ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë) + M‚ÇÇ.ùêî‚ÇÇ * M‚ÇÇ.ùõî) * M‚ÇÇ.ùêÇ‚ÇÇ
    droptol!(C,tol)

    r1,c1,v1 = findnz(B)
    r2,c2,v2 = findnz(C)
    r3,c3,v3 = findnz(X)

    coordinates = Tuple{Vector{Int}, Vector{Int}}[]
    push!(coordinates,(r1,c1))
    push!(coordinates,(r2,c2))
    push!(coordinates,(r3,c3))
    
    values = vcat(v1, v2, v3)

    dimensions = Tuple{Int, Int}[]
    push!(dimensions,size(B))
    push!(dimensions,size(C))
    push!(dimensions,size(X))

    solver = length(X.nzval) / length(X) < .1 ? :sylvester : :gmres

    ùêí‚ÇÇ, solved = solve_matrix_equation_forward(values, coords = coordinates, dims = dimensions, solver = solver, sparse_output = true)

    ùêí‚ÇÇ *= M‚ÇÇ.ùêî‚ÇÇ

    return ùêí‚ÇÇ, solved
end



function calculate_third_order_solution(‚àá‚ÇÅ::AbstractMatrix{<: Real}, #first order derivatives
                                            ‚àá‚ÇÇ::SparseMatrixCSC{<: Real}, #second order derivatives
                                            ‚àá‚ÇÉ::SparseMatrixCSC{<: Real}, #third order derivatives
                                            ùë∫‚ÇÅ::AbstractMatrix{<: Real}, #first order solution
                                            ùêí‚ÇÇ::SparseMatrixCSC{<: Real}, #second order solution
                                            M‚ÇÇ::second_order_auxilliary_matrices,  # aux matrices second order
                                            M‚ÇÉ::third_order_auxilliary_matrices;  # aux matrices third order
                                            T::timings,
                                            tol::AbstractFloat = eps())
    # inspired by Levintal

    # Indices and number of variables
    i‚Çä = T.future_not_past_and_mixed_idx;
    i‚Çã = T.past_not_future_and_mixed_idx;

    n‚Çã = T.nPast_not_future_and_mixed
    n‚Çä = T.nFuture_not_past_and_mixed
    n‚Çë = T.nExo;
    n = T.nVars
    n‚Çë‚Çã = n‚Çã + 1 + n‚Çë

    # 1st order solution
    ùêí‚ÇÅ = @views [ùë∫‚ÇÅ[:,1:n‚Çã] zeros(n) ùë∫‚ÇÅ[:,n‚Çã+1:end]] |> sparse
    droptol!(ùêí‚ÇÅ,tol)

    ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë = @views [ùêí‚ÇÅ[i‚Çã,:]; zeros(n‚Çë + 1, n‚Çã) spdiagm(ones(n‚Çë + 1))[1,:] zeros(n‚Çë + 1, n‚Çë)];

    ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã = @views [(ùêí‚ÇÅ * ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)[i‚Çä,:]
                                ùêí‚ÇÅ
                                spdiagm(ones(n‚Çë‚Çã))[[range(1,n‚Çã)...,n‚Çã + 1 .+ range(1,n‚Çë)...],:]];

    ùêí‚ÇÅ‚Çä‚ï±ùüé = @views [ùêí‚ÇÅ[i‚Çä,:]
                    zeros(n‚Çã + n + n‚Çë, n‚Çë‚Çã)];

    ‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ = @views -‚àá‚ÇÅ[:,1:n‚Çä] * ùêí‚ÇÅ[i‚Çä,1:n‚Çã] * ‚Ñí.diagm(ones(n))[i‚Çã,:] - ‚àá‚ÇÅ[:,range(1,n) .+ n‚Çä]


    ‚àá‚ÇÅ‚Çä = @views sparse(‚àá‚ÇÅ[:,1:n‚Çä] * spdiagm(ones(n))[i‚Çä,:])

    spinv = sparse(inv(‚àá‚ÇÅ‚Çäùêí‚ÇÅ‚ûï‚àá‚ÇÅ‚ÇÄ))
    droptol!(spinv,tol)

    B = spinv * ‚àá‚ÇÅ‚Çä
    droptol!(B,tol)

    ‚é∏ùêí‚ÇÇkùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚ûïùêí‚ÇÅùêí‚ÇÇ‚Çã‚éπ‚ï±ùêí‚ÇÇ‚ï±ùüé = @views [(ùêí‚ÇÇ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë, ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë) + ùêí‚ÇÅ * [ùêí‚ÇÇ[i‚Çã,:] ; zeros(n‚Çë + 1, n‚Çë‚Çã^2)])[i‚Çä,:]
            ùêí‚ÇÇ
            zeros(n‚Çã + n‚Çë, n‚Çë‚Çã^2)];
        
    ùêí‚ÇÇ‚Çä‚ï±ùüé = @views [ùêí‚ÇÇ[i‚Çä,:] 
            zeros(n‚Çã + n + n‚Çë, n‚Çë‚Çã^2)];

    aux = M‚ÇÉ.ùêíùêè * ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã

    # ùêó‚ÇÉ = -‚àá‚ÇÉ * ‚Ñí.kron(‚Ñí.kron(aux, aux), aux)
    ùêó‚ÇÉ = -A_mult_kron_power_3_B(‚àá‚ÇÉ, aux)

    tmpkron = ‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ‚Ñí.kron(ùêí‚ÇÅ‚Çä‚ï±ùüé, ùêí‚ÇÅ‚Çä‚ï±ùüé) * M‚ÇÇ.ùõî)
    out = - ‚àá‚ÇÉ * tmpkron - ‚àá‚ÇÉ * M‚ÇÉ.ùêè‚ÇÅ‚ÇóÃÇ * tmpkron * M‚ÇÉ.ùêè‚ÇÅ·µ£ÃÉ - ‚àá‚ÇÉ * M‚ÇÉ.ùêè‚ÇÇ‚ÇóÃÇ * tmpkron * M‚ÇÉ.ùêè‚ÇÇ·µ£ÃÉ
    ùêó‚ÇÉ += out
    
    # tmpùêó‚ÇÉ = -‚àá‚ÇÇ * ‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã,‚é∏ùêí‚ÇÇkùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚ûïùêí‚ÇÅùêí‚ÇÇ‚Çã‚éπ‚ï±ùêí‚ÇÇ‚ï±ùüé)
    tmpùêó‚ÇÉ = -mat_mult_kron(‚àá‚ÇÇ, ‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã,‚é∏ùêí‚ÇÇkùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚ûïùêí‚ÇÅùêí‚ÇÇ‚Çã‚éπ‚ï±ùêí‚ÇÇ‚ï±ùüé)

    tmpkron1 = -‚àá‚ÇÇ *  ‚Ñí.kron(ùêí‚ÇÅ‚Çä‚ï±ùüé,ùêí‚ÇÇ‚Çä‚ï±ùüé)
    tmpkron2 = ‚Ñí.kron(M‚ÇÇ.ùõî,ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)
    out2 = tmpkron1 * tmpkron2 +  tmpkron1 * M‚ÇÉ.ùêè‚ÇÅ‚Çó * tmpkron2 * M‚ÇÉ.ùêè‚ÇÅ·µ£
    
    ùêó‚ÇÉ += (tmpùêó‚ÇÉ + out2 + -‚àá‚ÇÇ * ‚Ñí.kron(‚é∏ùêí‚ÇÅùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë‚éπ‚ï±ùêí‚ÇÅ‚ï±ùüè‚Çë‚Çã, ùêí‚ÇÇ‚Çä‚ï±ùüé * M‚ÇÇ.ùõî)) * M‚ÇÉ.ùêè# |> findnz
    
    ùêó‚ÇÉ += @views -‚àá‚ÇÅ‚Çä * ùêí‚ÇÇ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë, [ùêí‚ÇÇ[i‚Çã,:] ; zeros(size(ùêí‚ÇÅ)[2] - n‚Çã, n‚Çë‚Çã^2)]) * M‚ÇÉ.ùêè
    droptol!(ùêó‚ÇÉ,tol)
    
    X = spinv * ùêó‚ÇÉ * M‚ÇÉ.ùêÇ‚ÇÉ
    droptol!(X,tol)
    
    tmpkron = ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë,M‚ÇÇ.ùõî)
    
    C = M‚ÇÉ.ùêî‚ÇÉ * tmpkron + M‚ÇÉ.ùêî‚ÇÉ * M‚ÇÉ.ùêè‚ÇÅ‚ÇóÃÑ * tmpkron * M‚ÇÉ.ùêè‚ÇÅ·µ£ÃÉ + M‚ÇÉ.ùêî‚ÇÉ * M‚ÇÉ.ùêè‚ÇÇ‚ÇóÃÑ * tmpkron * M‚ÇÉ.ùêè‚ÇÇ·µ£ÃÉ
    C += M‚ÇÉ.ùêî‚ÇÉ * ‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë,‚Ñí.kron(ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë,ùêí‚ÇÅ‚Çã‚ï±ùüè‚Çë)) # no speed up here from A_mult_kron_power_3_B
    C *= M‚ÇÉ.ùêÇ‚ÇÉ
    droptol!(C,tol)

    r1,c1,v1 = findnz(B)
    r2,c2,v2 = findnz(C)
    r3,c3,v3 = findnz(X)

    coordinates = Tuple{Vector{Int}, Vector{Int}}[]
    push!(coordinates,(r1,c1))
    push!(coordinates,(r2,c2))
    push!(coordinates,(r3,c3))
    
    values = vcat(v1, v2, v3)

    dimensions = Tuple{Int, Int}[]
    push!(dimensions,size(B))
    push!(dimensions,size(C))
    push!(dimensions,size(X))

    ùêí‚ÇÉ, solved = solve_matrix_equation_forward(values, coords = coordinates, dims = dimensions, solver = :gmres, sparse_output = true)

    ùêí‚ÇÉ *= M‚ÇÉ.ùêî‚ÇÉ

    return ùêí‚ÇÉ, solved
end




function irf(state_update::Function, 
    obc_state_update::Function,
    model::JuMP.Model,
    x::Vector{JuMP.VariableRef},
    initial_state::Vector{Float64}, 
    level::Vector{Float64},
    pruning::Bool, 
    unspecified_initial_state::Bool,
    T::timings; 
    algorithm::Symbol = :first_order,
    periods::Int = 40, 
    shocks::Union{Symbol_input,String_input,Matrix{Float64},KeyedArray{Float64}} = :all, 
    variables::Union{Symbol_input,String_input} = :all, 
    negative_shock::Bool = false)

    shocks = shocks isa KeyedArray ? axiskeys(shocks,1) isa Vector{String} ? rekey(shocks, 1 => axiskeys(shocks,1) .|> Meta.parse .|> replace_indices) : shocks : shocks

    shocks = shocks isa String_input ? shocks .|> Meta.parse .|> replace_indices : shocks

    if shocks isa Matrix{Float64}
        @assert size(shocks)[1] == T.nExo "Number of rows of provided shock matrix does not correspond to number of shocks. Please provide matrix with as many rows as there are shocks in the model."

        periods += size(shocks)[2]

        shock_history = zeros(T.nExo, periods)

        shock_history[:,1:size(shocks)[2]] = shocks

        shock_idx = 1
    elseif shocks isa KeyedArray{Float64}
        shock_input = map(x->Symbol(replace(string(x),"‚Çç‚Çì‚Çé" => "")),axiskeys(shocks)[1])

        periods += size(shocks)[2]

        @assert length(setdiff(shock_input, T.exo)) == 0 "Provided shocks which are not part of the model."
        
        shock_history = zeros(T.nExo, periods)

        shock_history[indexin(shock_input,T.exo),1:size(shocks)[2]] = shocks

        shock_idx = 1
    else
        shock_idx = parse_shocks_input_to_index(shocks,T)
    end

    var_idx = parse_variables_input_to_index(variables, T)

    axis1 = T.var[var_idx]
        
    if any(x -> contains(string(x), "‚óñ"), axis1)
        axis1_decomposed = decompose_name.(axis1)
        axis1 = [length(a) > 1 ? string(a[1]) * "{" * join(a[2],"}{") * "}" * (a[end] isa Symbol ? string(a[end]) : "") : string(a[1]) for a in axis1_decomposed]
    end

    if shocks == :simulate
        shock_history = randn(T.nExo,periods)

        shock_history[contains.(string.(T.exo),"·µí·µá·∂ú"),:] .= 0

        Y = zeros(T.nVars,periods,1)

        if pruning
            if algorithm == :pruned_second_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤], shock_history[:,t])
                end
            elseif algorithm == :pruned_third_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)
                pruned_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤, pruned_state¬≥], shock_history[:,t])
                end
            end
        else
            past_states = initial_state
            always_solved = true
            
            for t in 1:periods
                past_states, past_shocks, solved, model, x  = obc_state_update(past_states, shock_history[:,t], state_update, algorithm, model, x)

                if !solved @warn "No solution at iteration $t" end

                always_solved = always_solved && solved

                if !always_solved break end

                Y[:,t,1] = past_states
                shock_history[:,t] = past_shocks
            end
        end

        return KeyedArray(Y[var_idx,:,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = [:simulate])
    elseif shocks == :none
        Y = zeros(T.nVars,periods,1)

        shck = T.nExo == 0 ? Vector{Float64}(undef, 0) : zeros(T.nExo)
        
        if pruning
            if algorithm == :pruned_second_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤], shck)
                end
            elseif algorithm == :pruned_third_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)
                pruned_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤, pruned_state¬≥], shck)
                end
            end
        else 
            past_states = initial_state
            always_solved = true
            
            for t in 1:periods
                past_states, _, solved, model, x  = obc_state_update(past_states, shck, state_update, algorithm, model, x)

                if !solved @warn "No solution at iteration $t" end

                always_solved = always_solved && solved

                if !always_solved break end

                Y[:,t,1] = past_states
            end
        end

        return KeyedArray(Y[var_idx,:,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = [:none])
    else
        Y = zeros(T.nVars,periods,length(shock_idx))

        for (i,ii) in enumerate(shock_idx)
            if shocks != :simulate && shocks isa Union{Symbol_input,String_input}
                shock_history = zeros(T.nExo,periods)
                shock_history[ii,1] = negative_shock ? -1 : 1
            end

            if pruning
                if algorithm == :pruned_second_order
                    pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                    pruned_state¬≤ = copy(initial_state)
    
                    for t in 1:periods
                        Y[:,t,i] = state_update([pruned_state¬π, pruned_state¬≤], shock_history[:,t])
                    end
                elseif algorithm == :pruned_third_order
                    pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                    pruned_state¬≤ = copy(initial_state)
                    pruned_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
    
                    for t in 1:periods
                        Y[:,t,i] = state_update([pruned_state¬π, pruned_state¬≤, pruned_state¬≥], shock_history[:,t])
                    end
                end
            else
                past_states = initial_state
                always_solved = true
                
                for t in 1:periods
                    past_states, past_shocks, solved, model, x  = obc_state_update(past_states, shock_history[:,t], state_update, algorithm, model, x)
    
                    if !solved @warn "No solution at iteration $t" end
    
                    always_solved = always_solved && solved
    
                    if !always_solved break end
    
                    Y[:,t,1] = past_states
                    shock_history[:,t] = past_shocks
                end
            end
        end

        axis2 = shocks isa Union{Symbol_input,String_input} ? [T.exo[shock_idx]...] : [:Shock_matrix]
        
        if any(x -> contains(string(x), "‚óñ"), axis2)
            axis2_decomposed = decompose_name.(axis2)
            axis2 = [length(a) > 1 ? string(a[1]) * "{" * join(a[2],"}{") * "}" * (a[end] isa Symbol ? string(a[end]) : "") : string(a[1]) for a in axis2_decomposed]
        end
    
        return KeyedArray(Y[var_idx,:,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = axis2)
    end
end




function irf(state_update::Function, 
    initial_state::Vector{Float64}, 
    level::Vector{Float64},
    pruning::Bool, 
    unspecified_initial_state::Bool,
    T::timings; 
    algorithm::Symbol = :first_order,
    periods::Int = 40, 
    shocks::Union{Symbol_input,String_input,Matrix{Float64},KeyedArray{Float64}} = :all, 
    variables::Union{Symbol_input,String_input} = :all, 
    negative_shock::Bool = false)

    shocks = shocks isa KeyedArray ? axiskeys(shocks,1) isa Vector{String} ? rekey(shocks, 1 => axiskeys(shocks,1) .|> Meta.parse .|> replace_indices) : shocks : shocks

    shocks = shocks isa String_input ? shocks .|> Meta.parse .|> replace_indices : shocks

    if shocks isa Matrix{Float64}
        @assert size(shocks)[1] == T.nExo "Number of rows of provided shock matrix does not correspond to number of shocks. Please provide matrix with as many rows as there are shocks in the model."

        periods += size(shocks)[2]

        shock_history = zeros(T.nExo, periods)

        shock_history[:,1:size(shocks)[2]] = shocks

        shock_idx = 1
    elseif shocks isa KeyedArray{Float64}
        shock_input = map(x->Symbol(replace(string(x),"‚Çç‚Çì‚Çé" => "")),axiskeys(shocks)[1])

        periods += size(shocks)[2]

        @assert length(setdiff(shock_input, T.exo)) == 0 "Provided shocks which are not part of the model."
        
        shock_history = zeros(T.nExo, periods)

        shock_history[indexin(shock_input,T.exo),1:size(shocks)[2]] = shocks

        shock_idx = 1
    else
        shock_idx = parse_shocks_input_to_index(shocks,T)
    end

    var_idx = parse_variables_input_to_index(variables, T)

    axis1 = T.var[var_idx]
        
    if any(x -> contains(string(x), "‚óñ"), axis1)
        axis1_decomposed = decompose_name.(axis1)
        axis1 = [length(a) > 1 ? string(a[1]) * "{" * join(a[2],"}{") * "}" * (a[end] isa Symbol ? string(a[end]) : "") : string(a[1]) for a in axis1_decomposed]
    end

    if shocks == :simulate
        shock_history = randn(T.nExo,periods)

        shock_history[contains.(string.(T.exo),"·µí·µá·∂ú"),:] .= 0

        Y = zeros(T.nVars,periods,1)

        if pruning
            if algorithm == :pruned_second_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤], shock_history[:,t])
                end
            elseif algorithm == :pruned_third_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)
                pruned_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤, pruned_state¬≥], shock_history[:,t])
                end
            end
        else
            Y[:,1,1] = state_update(initial_state,shock_history[:,1])

            for t in 1:periods-1
                Y[:,t+1,1] = state_update(Y[:,t,1],shock_history[:,t+1])
            end
        end

        return KeyedArray(Y[var_idx,:,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = [:simulate])
    elseif shocks == :none
        Y = zeros(T.nVars,periods,1)

        shck = T.nExo == 0 ? Vector{Float64}(undef, 0) : zeros(T.nExo)
        
        if pruning
            if algorithm == :pruned_second_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤], shck)
                end
            elseif algorithm == :pruned_third_order
                pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                pruned_state¬≤ = copy(initial_state)
                pruned_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)

                for t in 1:periods
                    Y[:,t,1] = state_update([pruned_state¬π, pruned_state¬≤, pruned_state¬≥], shck)
                end
            end
        else 
            Y[:,1,1] = state_update(initial_state,shck)
    
            for t in 1:periods-1
                Y[:,t+1,1] = state_update(Y[:,t,1],shck)
            end
        end

        return KeyedArray(Y[var_idx,:,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = [:none])
    else
        Y = zeros(T.nVars,periods,length(shock_idx))

        for (i,ii) in enumerate(shock_idx)
            if shocks != :simulate && shocks isa Union{Symbol_input,String_input}
                shock_history = zeros(T.nExo,periods)
                shock_history[ii,1] = negative_shock ? -1 : 1
            end

            if pruning
                if algorithm == :pruned_second_order
                    pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                    pruned_state¬≤ = copy(initial_state)
    
                    for t in 1:periods
                        Y[:,t,i] = state_update([pruned_state¬π, pruned_state¬≤], shock_history[:,t])
                    end
                elseif algorithm == :pruned_third_order
                    pruned_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
                    pruned_state¬≤ = copy(initial_state)
                    pruned_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
    
                    for t in 1:periods
                        Y[:,t,i] = state_update([pruned_state¬π, pruned_state¬≤, pruned_state¬≥], shock_history[:,t])
                    end
                end
            else
                Y[:,1,i] = state_update(initial_state,shock_history[:,1])

                for t in 1:periods-1
                    Y[:,t+1,i] = state_update(Y[:,t,i],shock_history[:,t+1])
                end
            end
        end

        axis2 = shocks isa Union{Symbol_input,String_input} ? [T.exo[shock_idx]...] : [:Shock_matrix]
        
        if any(x -> contains(string(x), "‚óñ"), axis2)
            axis2_decomposed = decompose_name.(axis2)
            axis2 = [length(a) > 1 ? string(a[1]) * "{" * join(a[2],"}{") * "}" * (a[end] isa Symbol ? string(a[end]) : "") : string(a[1]) for a in axis2_decomposed]
        end
    
        return KeyedArray(Y[var_idx,:,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = axis2)
    end
end



function girf(state_update::Function, 
    initial_state::Vector{Float64}, 
    level::Vector{Float64}, 
    pruning::Bool, 
    unspecified_initial_state::Bool,
    T::timings; 
    algorithm::Symbol = :first_order,
    periods::Int = 40, 
    shocks::Union{Symbol_input,String_input,Matrix{Float64},KeyedArray{Float64}} = :all, 
    variables::Union{Symbol_input,String_input} = :all, 
    negative_shock::Bool = false, 
    warmup_periods::Int = 100, 
    draws::Int = 50)

    shocks = shocks isa KeyedArray ? axiskeys(shocks,1) isa Vector{String} ? rekey(shocks, 1 => axiskeys(shocks,1) .|> Meta.parse .|> replace_indices) : shocks : shocks

    shocks = shocks isa String_input ? shocks .|> Meta.parse .|> replace_indices : shocks

    if shocks isa Matrix{Float64}
        @assert size(shocks)[1] == T.nExo "Number of rows of provided shock matrix does not correspond to number of shocks. Please provide matrix with as many rows as there are shocks in the model."

        periods += size(shocks)[2]

        shock_history = zeros(T.nExo, periods)

        shock_history[:,1:size(shocks)[2]] = shocks

        shock_idx = 1
    elseif shocks isa KeyedArray{Float64}
        shock_input = map(x->Symbol(replace(string(x),"‚Çç‚Çì‚Çé" => "")),axiskeys(shocks)[1])

        periods += size(shocks)[2]

        @assert length(setdiff(shock_input, T.exo)) == 0 "Provided shocks which are not part of the model."

        shock_history = zeros(T.nExo, periods + 1)

        shock_history[indexin(shock_input,T.exo),1:size(shocks)[2]] = shocks

        shock_idx = 1
    else
        shock_idx = parse_shocks_input_to_index(shocks,T)
    end

    var_idx = parse_variables_input_to_index(variables, T)

    Y = zeros(T.nVars, periods + 1, length(shock_idx))

    pruned_initial_state¬π = unspecified_initial_state ? zero(initial_state) : copy(initial_state)
    pruned_initial_state¬≤ = copy(initial_state)
    pruned_initial_state¬≥ = unspecified_initial_state ? zero(initial_state) : copy(initial_state)

    for (i,ii) in enumerate(shock_idx)
        for draw in 1:draws
            for i in 1:warmup_periods
                if pruning
                    if algorithm == :pruned_second_order
                        initial_state = state_update([pruned_initial_state¬π, pruned_initial_state¬≤], randn(T.nExo))
                    elseif algorithm == :pruned_third_order
                        initial_state = state_update([pruned_initial_state¬π, pruned_initial_state¬≤, pruned_initial_state¬≥], randn(T.nExo))
                    end
                else
                    initial_state = state_update(initial_state, randn(T.nExo))
                end
            end

            Y1 = zeros(T.nVars, periods + 1)
            Y2 = zeros(T.nVars, periods + 1)

            baseline_noise = randn(T.nExo)

            if shocks != :simulate && shocks isa Union{Symbol_input,String_input}
                shock_history = zeros(T.nExo,periods)
                shock_history[ii,1] = negative_shock ? -1 : 1
            end

            if pruning
                if algorithm == :pruned_second_order
                    Y1[:,1] = state_update([pruned_initial_state¬π, pruned_initial_state¬≤], baseline_noise)
                    Y2[:,1] = state_update([pruned_initial_state¬π, pruned_initial_state¬≤], baseline_noise)

                    pruned_initial_state¬π‚ÇÅ = copy(pruned_initial_state¬π)
                    pruned_initial_state¬π‚ÇÇ = copy(pruned_initial_state¬π)
                    pruned_initial_state¬≤‚ÇÅ = copy(pruned_initial_state¬≤)
                    pruned_initial_state¬≤‚ÇÇ = copy(pruned_initial_state¬≤)
                elseif algorithm == :pruned_third_order
                    Y1[:,1] = state_update([pruned_initial_state¬π, pruned_initial_state¬≤, pruned_initial_state¬≥], baseline_noise)
                    Y2[:,1] = state_update([pruned_initial_state¬π, pruned_initial_state¬≤, pruned_initial_state¬≥], baseline_noise)

                    pruned_initial_state¬π‚ÇÅ = copy(pruned_initial_state¬π)
                    pruned_initial_state¬π‚ÇÇ = copy(pruned_initial_state¬π)
                    pruned_initial_state¬≤‚ÇÅ = copy(pruned_initial_state¬≤)
                    pruned_initial_state¬≤‚ÇÇ = copy(pruned_initial_state¬≤)
                    pruned_initial_state¬≥‚ÇÅ = copy(pruned_initial_state¬≥)
                    pruned_initial_state¬≥‚ÇÇ = copy(pruned_initial_state¬≥)
                end
            else
                Y1[:,1] = state_update(initial_state, baseline_noise)
                Y2[:,1] = state_update(initial_state, baseline_noise)
            end

            for t in 1:periods
                baseline_noise = randn(T.nExo)

                if pruning
                    if algorithm == :pruned_second_order
                        Y1[:,t+1] = state_update([pruned_initial_state¬π‚ÇÅ, pruned_initial_state¬≤‚ÇÅ], baseline_noise)
                        Y2[:,t+1] = state_update([pruned_initial_state¬π‚ÇÇ, pruned_initial_state¬≤‚ÇÇ], baseline_noise + shock_history[:,t])
                    elseif algorithm == :pruned_third_order
                        Y1[:,t+1] = state_update([pruned_initial_state¬π‚ÇÅ, pruned_initial_state¬≤‚ÇÅ, pruned_initial_state¬≥‚ÇÅ], baseline_noise)
                        Y2[:,t+1] = state_update([pruned_initial_state¬π‚ÇÇ, pruned_initial_state¬≤‚ÇÇ, pruned_initial_state¬≥‚ÇÇ], baseline_noise + shock_history[:,t])
                    end
                else
                    Y1[:,t+1] = state_update(Y1[:,t],baseline_noise)
                    Y2[:,t+1] = state_update(Y2[:,t],baseline_noise + shock_history[:,t])
                end
            end

            Y[:,:,i] += Y2 - Y1
        end
        Y[:,:,i] /= draws
    end
    
    axis1 = T.var[var_idx]
        
    if any(x -> contains(string(x), "‚óñ"), axis1)
        axis1_decomposed = decompose_name.(axis1)
        axis1 = [length(a) > 1 ? string(a[1]) * "{" * join(a[2],"}{") * "}" * (a[end] isa Symbol ? string(a[end]) : "") : string(a[1]) for a in axis1_decomposed]
    end

    axis2 = shocks isa Union{Symbol_input,String_input} ? [T.exo[shock_idx]...] : [:Shock_matrix]
        
    if any(x -> contains(string(x), "‚óñ"), axis2)
        axis2_decomposed = decompose_name.(axis2)
        axis2 = [length(a) > 1 ? string(a[1]) * "{" * join(a[2],"}{") * "}" * (a[end] isa Symbol ? string(a[end]) : "") : string(a[1]) for a in axis2_decomposed]
    end

    return KeyedArray(Y[var_idx,2:end,:] .+ level[var_idx];  Variables = axis1, Periods = 1:periods, Shocks = axis2)
end


function parse_variables_input_to_index(variables::Union{Symbol_input,String_input}, T::timings)
    
    variables = variables isa String_input ? variables .|> Meta.parse .|> replace_indices : variables

    if variables == :all_excluding_auxilliary_and_obc
        return indexin(setdiff(T.var[.!contains.(string.(T.var),"·µí·µá·∂ú")],T.aux),sort(union(T.var,T.aux,T.exo_present)))
        # return indexin(setdiff(setdiff(T.var,T.exo_present),T.aux),sort(union(T.var,T.aux,T.exo_present)))
    elseif variables == :all_excluding_obc
        return indexin(T.var[.!contains.(string.(T.var),"·µí·µá·∂ú")],sort(union(T.var,T.aux,T.exo_present)))
    elseif variables == :all
        return 1:length(union(T.var,T.aux,T.exo_present))
    elseif variables isa Matrix{Symbol}
        if length(setdiff(variables,T.var)) > 0
            return @warn "Following variables are not part of the model: " * join(string.(setdiff(variables,T.var)),", ")
        end
        return getindex(1:length(T.var),convert(Vector{Bool},vec(sum(variables .== T.var,dims= 2))))
    elseif variables isa Vector{Symbol}
        if length(setdiff(variables,T.var)) > 0
            return @warn "Following variables are not part of the model: " * join(string.(setdiff(variables,T.var)),", ")
        end
        return getindex(1:length(T.var),convert(Vector{Bool},vec(sum(reshape(variables,1,length(variables)) .== T.var,dims= 2))))
    elseif variables isa Tuple{Symbol,Vararg{Symbol}}
        if length(setdiff(variables,T.var)) > 0
            return @warn "Following variables are not part of the model: " * join(string.(setdiff(Symbol.(collect(variables)),T.var)), ", ")
        end
        return getindex(1:length(T.var),convert(Vector{Bool},vec(sum(reshape(collect(variables),1,length(variables)) .== T.var,dims= 2))))
    elseif variables isa Symbol
        if length(setdiff([variables],T.var)) > 0
            return @warn "Following variable is not part of the model: " * join(string(setdiff([variables],T.var)[1]),", ")
        end
        return getindex(1:length(T.var),variables .== T.var)
    else
        return @warn "Invalid argument in variables"
    end
end


function parse_shocks_input_to_index(shocks::Union{Symbol_input,String_input}, T::timings)
    shocks = shocks isa String_input ? shocks .|> Meta.parse .|> replace_indices : shocks

    if shocks == :all
        shock_idx = 1:T.nExo
    elseif shocks == :all_excluding_obc
        shock_idx = findall(.!contains.(string.(T.exo),"·µí·µá·∂ú"))
    elseif shocks == :none
        shock_idx = 1
    elseif shocks == :simulate
        shock_idx = 1
    elseif shocks isa Matrix{Symbol}
        if length(setdiff(shocks,T.exo)) > 0
            return @warn "Following shocks are not part of the model: " * join(string.(setdiff(shocks,T.exo)),", ")
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(shocks .== T.exo,dims= 2))))
    elseif shocks isa Vector{Symbol}
        if length(setdiff(shocks,T.exo)) > 0
            return @warn "Following shocks are not part of the model: " * join(string.(setdiff(shocks,T.exo)),", ")
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(reshape(shocks,1,length(shocks)) .== T.exo, dims= 2))))
    elseif shocks isa Tuple{Symbol, Vararg{Symbol}}
        if length(setdiff(shocks,T.exo)) > 0
            return @warn "Following shocks are not part of the model: " * join(string.(setdiff(Symbol.(collect(shocks)),T.exo)),", ")
        end
        shock_idx = getindex(1:T.nExo,convert(Vector{Bool},vec(sum(reshape(collect(shocks),1,length(shocks)) .== T.exo,dims= 2))))
    elseif shocks isa Symbol
        if length(setdiff([shocks],T.exo)) > 0
            return @warn "Following shock is not part of the model: " * join(string(setdiff([shocks],T.exo)[1]),", ")
        end
        shock_idx = getindex(1:T.nExo,shocks .== T.exo)
    else
        return @warn "Invalid argument in shocks"
    end
end






function parse_algorithm_to_state_update(algorithm::Symbol, ùìÇ::‚Ñ≥)
    if :linear_time_iteration == algorithm
        state_update = ùìÇ.solution.perturbation.linear_time_iteration.state_update
        pruning = false
    elseif algorithm ‚àà [:riccati, :first_order]
        state_update = ùìÇ.solution.perturbation.first_order.state_update
        pruning = false
    elseif :second_order == algorithm
        state_update = ùìÇ.solution.perturbation.second_order.state_update
        pruning = false
    elseif :pruned_second_order == algorithm
        state_update = ùìÇ.solution.perturbation.pruned_second_order.state_update
        pruning = true
    elseif :third_order == algorithm
        state_update = ùìÇ.solution.perturbation.third_order.state_update
        pruning = false
    elseif :pruned_third_order == algorithm
        state_update = ùìÇ.solution.perturbation.pruned_third_order.state_update
        pruning = true
    end

    return state_update, pruning
end



function calculate_covariance(parameters::Vector{<: Real}, ùìÇ::‚Ñ≥; verbose::Bool = false)
    SS_and_pars, (solution_error, iters) = ùìÇ.SS_solve_func(parameters, ùìÇ, verbose, false, ùìÇ.solver_parameters, 0)
    
	‚àá‚ÇÅ = calculate_jacobian(parameters, SS_and_pars, ùìÇ) 

<<<<<<< HEAD
    sol, success = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
=======
    sol, solved = calculate_first_order_solution(Matrix(‚àá‚ÇÅ); T = ùìÇ.timings)
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806

    # covar_raw, solved_cov = calculate_covariance_AD(sol, T = ùìÇ.timings, subset_indices = collect(1:ùìÇ.timings.nVars))

    A = @views sol[:, 1:ùìÇ.timings.nPast_not_future_and_mixed] * ‚Ñí.diagm(ones(ùìÇ.timings.nVars))[ùìÇ.timings.past_not_future_and_mixed_idx,:]

    
    C = @views sol[:, ùìÇ.timings.nPast_not_future_and_mixed+1:end]
    
    CC = C * C'

    coordinates = Tuple{Vector{Int}, Vector{Int}}[]
    
    dimensions = Tuple{Int, Int}[]
    push!(dimensions,size(A))
    push!(dimensions,size(CC))
    
    values = vcat(vec(A), vec(collect(-CC)))

    covar_raw, _ = solve_matrix_equation_AD(values, coords = coordinates, dims = dimensions, solver = :doubling)

    return covar_raw, sol , ‚àá‚ÇÅ, SS_and_pars
end




function calculate_mean(parameters::Vector{T}, ùìÇ::‚Ñ≥; verbose::Bool = false, algorithm = :pruned_second_order, tol::Float64 = eps()) where T <: Real
    # Theoretical mean identical for 2nd and 3rd order pruned solution.
    @assert algorithm ‚àà [:linear_time_iteration, :riccati, :first_order, :quadratic_iteration, :binder_pesaran, :pruned_second_order, :pruned_third_order] "Theoretical mean only available for first order, pruned second and third order perturbation solutions."

    SS_and_pars, (solution_error, iters) = ùìÇ.SS_solve_func(parameters, ùìÇ, verbose, false, ùìÇ.solver_parameters)
    
    if algorithm ‚àà [:linear_time_iteration, :riccati, :first_order, :quadratic_iteration, :binder_pesaran]
        return SS_and_pars[1:ùìÇ.timings.nVars], solution_error
    end

    ‚àá‚ÇÅ = calculate_jacobian(parameters, SS_and_pars, ùìÇ) |> Matrix
    
    ùêí‚ÇÅ, solved = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
    
    ‚àá‚ÇÇ = calculate_hessian(parameters, SS_and_pars, ùìÇ)
    
    ùêí‚ÇÇ, solved2 = calculate_second_order_solution(‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùìÇ.solution.perturbation.second_order_auxilliary_matrices; T = ùìÇ.timings, tol = tol)

    n·µâ = ùìÇ.timings.nExo
    nÀ¢ = ùìÇ.timings.nPast_not_future_and_mixed

    s_in_s‚Å∫ = BitVector(vcat(ones(Bool, nÀ¢), zeros(Bool, n·µâ + 1)))
    e_in_s‚Å∫ = BitVector(vcat(zeros(Bool, nÀ¢ + 1), ones(Bool, n·µâ)))
    v_in_s‚Å∫ = BitVector(vcat(zeros(Bool, nÀ¢), 1, zeros(Bool, n·µâ)))
    
    kron_states     = ‚Ñí.kron(s_in_s‚Å∫, s_in_s‚Å∫)
    kron_shocks     = ‚Ñí.kron(e_in_s‚Å∫, e_in_s‚Å∫)
    kron_volatility = ‚Ñí.kron(v_in_s‚Å∫, v_in_s‚Å∫)

    # first order
    states_to_variables¬π = sparse(ùêí‚ÇÅ[:,1:ùìÇ.timings.nPast_not_future_and_mixed])

    states_to_states¬π = ùêí‚ÇÅ[ùìÇ.timings.past_not_future_and_mixed_idx, 1:ùìÇ.timings.nPast_not_future_and_mixed]
    shocks_to_states¬π = ùêí‚ÇÅ[ùìÇ.timings.past_not_future_and_mixed_idx, (ùìÇ.timings.nPast_not_future_and_mixed + 1):end]

    # second order
    states_to_variables¬≤        = ùêí‚ÇÇ[:, kron_states]
    shocks_to_variables¬≤        = ùêí‚ÇÇ[:, kron_shocks]
    volatility_to_variables¬≤    = ùêí‚ÇÇ[:, kron_volatility]

    states_to_states¬≤       = ùêí‚ÇÇ[ùìÇ.timings.past_not_future_and_mixed_idx, kron_states] |> collect
    shocks_to_states¬≤       = ùêí‚ÇÇ[ùìÇ.timings.past_not_future_and_mixed_idx, kron_shocks]
    volatility_to_states¬≤   = ùêí‚ÇÇ[ùìÇ.timings.past_not_future_and_mixed_idx, kron_volatility]

    kron_states_to_states¬π = ‚Ñí.kron(states_to_states¬π, states_to_states¬π) |> collect
    kron_shocks_to_states¬π = ‚Ñí.kron(shocks_to_states¬π, shocks_to_states¬π)

    n_sts = ùìÇ.timings.nPast_not_future_and_mixed

    # Set up in pruned state transition matrices
    pruned_states_to_pruned_states = [  states_to_states¬π       zeros(T,n_sts, n_sts)   zeros(T,n_sts, n_sts^2)
                                        zeros(T,n_sts, n_sts)   states_to_states¬π       states_to_states¬≤ / 2
                                        zeros(T,n_sts^2, 2 * n_sts)                     kron_states_to_states¬π   ]

    pruned_states_to_variables = [states_to_variables¬π  states_to_variables¬π  states_to_variables¬≤ / 2]

    pruned_states_vol_and_shock_effect = [  zeros(T,n_sts) 
                                            vec(volatility_to_states¬≤) / 2 + shocks_to_states¬≤ / 2 * vec(‚Ñí.I(ùìÇ.timings.nExo))
                                            kron_shocks_to_states¬π * vec(‚Ñí.I(ùìÇ.timings.nExo))]

    variables_vol_and_shock_effect = (vec(volatility_to_variables¬≤) + shocks_to_variables¬≤ * vec(‚Ñí.I(ùìÇ.timings.nExo))) / 2

    ## First-order moments, ie mean of variables
    mean_of_pruned_states   = (‚Ñí.I - pruned_states_to_pruned_states) \ pruned_states_vol_and_shock_effect
    mean_of_variables   = SS_and_pars[1:ùìÇ.timings.nVars] + pruned_states_to_variables * mean_of_pruned_states + variables_vol_and_shock_effect
    
    return mean_of_variables, ùêí‚ÇÅ, ‚àá‚ÇÅ, ùêí‚ÇÇ, ‚àá‚ÇÇ
end




function solve_matrix_equation_forward(ABC::Vector{Float64};
    coords::Vector{Tuple{Vector{Int}, Vector{Int}}},
    dims::Vector{Tuple{Int,Int}},
    sparse_output::Bool = false,
    solver::Symbol = :doubling)

    if length(coords) == 1
        lengthA = length(coords[1][1])
        vA = ABC[1:lengthA]
        A = sparse(coords[1]...,vA,dims[1]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        C = reshape(ABC[lengthA+1:end],dims[2]...)
        if solver != :doubling
            B = A'
        end
    elseif length(coords) == 3
        lengthA = length(coords[1][1])
        lengthB = length(coords[2][1])

        vA = ABC[1:lengthA]
        vB = ABC[lengthA .+ (1:lengthB)]
        vC = ABC[lengthA + lengthB + 1:end]

        A = sparse(coords[1]...,vA,dims[1]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        B = sparse(coords[2]...,vB,dims[2]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        C = sparse(coords[3]...,vC,dims[3]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
    else
        lengthA = dims[1][1] * dims[1][2]
        A = reshape(ABC[1:lengthA],dims[1]...)
        C = reshape(ABC[lengthA+1:end],dims[2]...)
        if solver != :doubling
            B = A'
        end
    end
    

    if solver ‚àà [:gmres, :bicgstab]
        function sylvester!(sol,ùê±)
            ùêó = reshape(ùê±, size(C))
            sol .= vec(A * ùêó * B - ùêó)
            return sol
        end
        
        sylvester = LinearOperators.LinearOperator(Float64, length(C), length(C), true, true, sylvester!)

        if solver == :gmres
            ùêÇ, info = Krylov.gmres(sylvester, [vec(C);])
        elseif solver == :bicgstab
            ùêÇ, info = Krylov.bicgstab(sylvester, [vec(C);])
        end
        solved = info.solved
    elseif solver == :iterative
        iter = 1
        change = 1
        ùêÇ  = C
        ùêÇ¬π = C
        while change > eps(Float32) && iter < 10000
            ùêÇ¬π = A * ùêÇ * B - C
            if !(ùêÇ¬π isa DenseMatrix)
                droptol!(ùêÇ¬π, eps())
            end
            if iter > 500
                change = maximum(abs, ùêÇ¬π - ùêÇ)
            end
            ùêÇ = ùêÇ¬π
            iter += 1
        end
        solved = change < eps(Float32)
    elseif solver == :doubling
        iter = 1
        change = 1
        ùêÇ  = -C
        ùêÇ¬π = -C
        while change > eps(Float32) && iter < 500
            ùêÇ¬π = A * ùêÇ * A' + ùêÇ
            A *= A
            if !(A isa DenseMatrix)
                droptol!(A, eps())
            end
            if iter > 10
                change = maximum(abs, ùêÇ¬π - ùêÇ)
            end
            ùêÇ = ùêÇ¬π
            iter += 1
        end
        solved = change < eps(Float32)
    elseif solver == :sylvester
        ùêÇ = MatrixEquations.sylvd(collect(-A),collect(B),-C)
        solved = isapprox(ùêÇ, A * ùêÇ * B - C, rtol = eps(Float32))
    elseif solver == :lyapunov
        ùêÇ = MatrixEquations.lyapd(collect(A),-C)
        solved = isapprox(ùêÇ, A * ùêÇ * A' - C, rtol = eps(Float32))
    elseif solver == :speedmapping
        soll = speedmapping(collect(-C); m! = (X, x) -> X .= A * x * B - C, stabilize = true)

        ùêÇ = soll.minimizer

        solved = soll.converged
    end

    return sparse_output ? sparse(reshape(ùêÇ, size(C))) : reshape(ùêÇ, size(C)), solved # return info on convergence
end



function solve_matrix_equation_conditions(ABC::Vector{<: Real},
    X::AbstractMatrix{<: Real}, 
    solved::Bool;
    coords::Vector{Tuple{Vector{Int}, Vector{Int}}},
    dims::Vector{Tuple{Int,Int}},
    sparse_output::Bool = false,
    solver::Symbol = :doubling)

    solver = :gmres # ensure the AXB works always

    if length(coords) == 1
        lengthA = length(coords[1][1])
        vA = ABC[1:lengthA]
        A = sparse(coords[1]...,vA,dims[1]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        C = reshape(ABC[lengthA+1:end],dims[2]...)
        if solver != :doubling
            B = A' |> sparse# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        end
    elseif length(coords) == 3
        lengthA = length(coords[1][1])
        lengthB = length(coords[2][1])
        
        vA = ABC[1:lengthA]
        vB = ABC[lengthA .+ (1:lengthB)]
        vC = ABC[lengthA + lengthB + 1:end]

        A = sparse(coords[1]...,vA,dims[1]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        B = sparse(coords[2]...,vB,dims[2]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        C = sparse(coords[3]...,vC,dims[3]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
    else
        lengthA = dims[1][1] * dims[1][2]
        A = reshape(ABC[1:lengthA],dims[1]...)
        C = reshape(ABC[lengthA+1:end],dims[2]...)
        if solver != :doubling
            B = A'
        end
    end

    A * X * B - C - X
end



function solve_matrix_equation_forward(abc::Vector{‚Ñ±.Dual{Z,S,N}};
    coords::Vector{Tuple{Vector{Int}, Vector{Int}}},
    dims::Vector{Tuple{Int,Int}},
    sparse_output::Bool = false,
    solver::Symbol = :doubling) where {Z,S,N}

    # unpack: AoS -> SoA
    ABC = ‚Ñ±.value.(abc)

    # you can play with the dimension here, sometimes it makes sense to transpose
    partial_values = zeros(length(abc), N)
    for i in 1:N
        partial_values[:,i] = ‚Ñ±.partials.(abc, i)
    end

    # get f(vs)
    val, solved = solve_matrix_equation_forward(ABC, coords = coords, dims = dims, sparse_output = sparse_output, solver = solver)

    if length(coords) == 1
        lengthA = length(coords[1][1])

        vA = ABC[1:lengthA]
        A = sparse(coords[1]...,vA,dims[1]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        # C = reshape(ABC[lengthA+1:end],dims[2]...)
        droptol!(A,eps())

        B = sparse(A')# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC

        partials = zeros(dims[1][1] * dims[1][2] + dims[2][1] * dims[2][2], size(partial_values,2))
        partials[vcat(coords[1][1] + (coords[1][2] .- 1) * dims[1][1], dims[1][1] * dims[1][2] + 1:end),:] = partial_values

        reshape_matmul_b = LinearOperators.LinearOperator(Float64, length(val) * size(partials,2), 2*size(A,1)^2 * size(partials,2), false, false, 
        (sol,ùê±) -> begin 
            ùêó = reshape(ùê±, (2* size(A,1)^2,size(partials,2))) |> sparse

            b = hcat(jacobian_wrt_A(A, val), -‚Ñí.I(length(val)))
            droptol!(b,eps())

            sol .= vec(b * ùêó)
            return sol
        end)
    elseif length(coords) == 3
        lengthA = length(coords[1][1])
        lengthB = length(coords[2][1])

        vA = ABC[1:lengthA]
        vB = ABC[lengthA .+ (1:lengthB)]
        # vC = ABC[lengthA + lengthB + 1:end]

        A = sparse(coords[1]...,vA,dims[1]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        B = sparse(coords[2]...,vB,dims[2]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC
        # C = sparse(coords[3]...,vC,dims[3]...)# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC

        partials = spzeros(dims[1][1] * dims[1][2] + dims[2][1] * dims[2][2] + dims[3][1] * dims[3][2], size(partial_values,2))
        partials[vcat(
            coords[1][1] + (coords[1][2] .- 1) * dims[1][1], 
            coords[2][1] + (coords[2][2] .- 1) * dims[2][1] .+ dims[1][1] * dims[1][2], 
            coords[3][1] + (coords[3][2] .- 1) * dims[3][1] .+ dims[1][1] * dims[1][2] .+ dims[2][1] * dims[2][2]),:] = partial_values
        
        reshape_matmul_b = LinearOperators.LinearOperator(Float64, length(val) * size(partials,2), (length(A) + length(B) + length(val)) * size(partials,2), false, false, 
            (sol,ùê±) -> begin 
                ùêó = reshape(ùê±, (length(A) + length(B) + length(val), size(partials,2))) |> sparse

                jacobian_A = ‚Ñí.kron(val * B, ‚Ñí.I(size(A,1)))
                jacobian_B = ‚Ñí.kron(‚Ñí.I(size(B,1)), A * val)

                b = hcat(jacobian_A', jacobian_B, -‚Ñí.I(length(val)))
                droptol!(b,eps())

                sol .= vec(b * ùêó)
                return sol
        end)
    else
        lengthA = dims[1][1] * dims[1][2]
        A = reshape(ABC[1:lengthA],dims[1]...) |> sparse
        droptol!(A, eps())
        # C = reshape(ABC[lengthA+1:end],dims[2]...)
        B = sparse(A')# |> ThreadedSparseArrays.ThreadedSparseMatrixCSC

        partials = partial_values

        reshape_matmul_b = LinearOperators.LinearOperator(Float64, length(val) * size(partials,2), 2*size(A,1)^2 * size(partials,2), false, false, 
        (sol,ùê±) -> begin 
            ùêó = reshape(ùê±, (2* size(A,1)^2,size(partials,2))) |> sparse

            b = hcat(jacobian_wrt_A(A, val), -‚Ñí.I(length(val)))
            droptol!(b,eps())

            sol .= vec(b * ùêó)
            return sol
        end)
    end
    
    # get J(f, vs) * ps (cheating). Write your custom rule here. This used to be the conditions but here they are analytically derived.
    reshape_matmul_a = LinearOperators.LinearOperator(Float64, length(val) * size(partials,2), length(val) * size(partials,2), false, false, 
        (sol,ùê±) -> begin 
        ùêó = reshape(ùê±, (length(val),size(partials,2))) |> sparse

        a = jacobian_wrt_values(A, B)
        droptol!(a,eps())

        sol .= vec(a * ùêó)
        return sol
    end)

    X, info = Krylov.gmres(reshape_matmul_a, vec(reshape_matmul_b * vec(partials)))#, atol = tol)

    jvp = reshape(X, (length(val), size(partials,2)))

    out = reshape(map(val, eachrow(jvp)) do v, p
            ‚Ñ±.Dual{Z}(v, p...) # Z is the tag
        end,size(val))

    # pack: SoA -> AoS
    return sparse_output ? sparse(out) : out, solved
end


solve_matrix_equation_AD = ID.ImplicitFunction(solve_matrix_equation_forward, 
                                                solve_matrix_equation_conditions)

solve_matrix_equation_AD_direct = ID.ImplicitFunction(solve_matrix_equation_forward, 
                                                solve_matrix_equation_conditions; 
                                                linear_solver = ID.DirectLinearSolver())



function calculate_second_order_moments(
    parameters::Vector{<: Real}, 
    ùìÇ::‚Ñ≥; 
    covariance::Bool = true,
    verbose::Bool = false, 
    tol::AbstractFloat = eps())

    Œ£ ∏‚ÇÅ, ùêí‚ÇÅ, ‚àá‚ÇÅ, SS_and_pars = calculate_covariance(parameters, ùìÇ, verbose = verbose)

    n·µâ = ùìÇ.timings.nExo

    nÀ¢ = ùìÇ.timings.nPast_not_future_and_mixed

    iÀ¢ = ùìÇ.timings.past_not_future_and_mixed_idx

    Œ£·∂ª‚ÇÅ = Œ£ ∏‚ÇÅ[iÀ¢, iÀ¢]

    # precalc second order
    ## mean
    I_plus_s_s = sparse(reshape(‚Ñí.kron(vec(‚Ñí.I(nÀ¢)), ‚Ñí.I(nÀ¢)), nÀ¢^2, nÀ¢^2) + ‚Ñí.I)

    ## covariance
    E_e‚Å¥ = zeros(n·µâ * (n·µâ + 1)√∑2 * (n·µâ + 2)√∑3 * (n·µâ + 3)√∑4)

    quadrup = multiplicate(n·µâ, 4)

    comb‚Å¥ = reduce(vcat, generateSumVectors(n·µâ, 4))

    comb‚Å¥ = comb‚Å¥ isa Int64 ? reshape([comb‚Å¥],1,1) : comb‚Å¥

    for j = 1:size(comb‚Å¥,1)
        E_e‚Å¥[j] = product_moments(‚Ñí.I(n·µâ), 1:n·µâ, comb‚Å¥[j,:])
    end

    e‚Å¥ = quadrup * E_e‚Å¥

    # second order
    ‚àá‚ÇÇ = calculate_hessian(parameters, SS_and_pars, ùìÇ)

    ùêí‚ÇÇ, solved2 = calculate_second_order_solution(‚àá‚ÇÅ, ‚àá‚ÇÇ, ùêí‚ÇÅ, ùìÇ.solution.perturbation.second_order_auxilliary_matrices; T = ùìÇ.timings, tol = tol)

    s_in_s‚Å∫ = BitVector(vcat(ones(Bool, nÀ¢), zeros(Bool, n·µâ + 1)))
    e_in_s‚Å∫ = BitVector(vcat(zeros(Bool, nÀ¢ + 1), ones(Bool, n·µâ)))
    v_in_s‚Å∫ = BitVector(vcat(zeros(Bool, nÀ¢), 1, zeros(Bool, n·µâ)))

    kron_s_s = ‚Ñí.kron(s_in_s‚Å∫, s_in_s‚Å∫)
    kron_e_e = ‚Ñí.kron(e_in_s‚Å∫, e_in_s‚Å∫)
    kron_v_v = ‚Ñí.kron(v_in_s‚Å∫, v_in_s‚Å∫)
    kron_s_e = ‚Ñí.kron(s_in_s‚Å∫, e_in_s‚Å∫)

    # first order
    s_to_y‚ÇÅ = ùêí‚ÇÅ[:, 1:nÀ¢]
    e_to_y‚ÇÅ = ùêí‚ÇÅ[:, (nÀ¢ + 1):end]
    
    s_to_s‚ÇÅ = ùêí‚ÇÅ[iÀ¢, 1:nÀ¢]
    e_to_s‚ÇÅ = ùêí‚ÇÅ[iÀ¢, (nÀ¢ + 1):end]


    # second order
    s_s_to_y‚ÇÇ = ùêí‚ÇÇ[:, kron_s_s]
    e_e_to_y‚ÇÇ = ùêí‚ÇÇ[:, kron_e_e]
    v_v_to_y‚ÇÇ = ùêí‚ÇÇ[:, kron_v_v]
    s_e_to_y‚ÇÇ = ùêí‚ÇÇ[:, kron_s_e]

    s_s_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_s_s] |> collect
    e_e_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_e_e]
    v_v_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_v_v] |> collect
    s_e_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_s_e]

    s_to_s‚ÇÅ_by_s_to_s‚ÇÅ = ‚Ñí.kron(s_to_s‚ÇÅ, s_to_s‚ÇÅ) |> collect
    e_to_s‚ÇÅ_by_e_to_s‚ÇÅ = ‚Ñí.kron(e_to_s‚ÇÅ, e_to_s‚ÇÅ)
    s_to_s‚ÇÅ_by_e_to_s‚ÇÅ = ‚Ñí.kron(s_to_s‚ÇÅ, e_to_s‚ÇÅ)

    # # Set up in pruned state transition matrices
    sÃÇ_to_sÃÇ‚ÇÇ = [ s_to_s‚ÇÅ             zeros(nÀ¢, nÀ¢ + nÀ¢^2)
                zeros(nÀ¢, nÀ¢)       s_to_s‚ÇÅ             s_s_to_s‚ÇÇ / 2
                zeros(nÀ¢^2, 2*nÀ¢)   s_to_s‚ÇÅ_by_s_to_s‚ÇÅ                  ]

    eÃÇ_to_sÃÇ‚ÇÇ = [ e_to_s‚ÇÅ         zeros(nÀ¢, n·µâ^2 + n·µâ * nÀ¢)
                zeros(nÀ¢,n·µâ)    e_e_to_s‚ÇÇ / 2       s_e_to_s‚ÇÇ
                zeros(nÀ¢^2,n·µâ)  e_to_s‚ÇÅ_by_e_to_s‚ÇÅ  I_plus_s_s * s_to_s‚ÇÅ_by_e_to_s‚ÇÅ]

    sÃÇ_to_y‚ÇÇ = [s_to_y‚ÇÅ  s_to_y‚ÇÅ         s_s_to_y‚ÇÇ / 2]

    eÃÇ_to_y‚ÇÇ = [e_to_y‚ÇÅ  e_e_to_y‚ÇÇ / 2   s_e_to_y‚ÇÇ]

    sÃÇv‚ÇÇ = [ zeros(nÀ¢) 
            vec(v_v_to_s‚ÇÇ) / 2 + e_e_to_s‚ÇÇ / 2 * vec(‚Ñí.I(n·µâ))
            e_to_s‚ÇÅ_by_e_to_s‚ÇÅ * vec(‚Ñí.I(n·µâ))]

    yv‚ÇÇ = (vec(v_v_to_y‚ÇÇ) + e_e_to_y‚ÇÇ * vec(‚Ñí.I(n·µâ))) / 2

    ## Mean
    ŒºÀ¢‚Å∫‚ÇÇ = (‚Ñí.I - sÃÇ_to_sÃÇ‚ÇÇ) \ sÃÇv‚ÇÇ
    ŒîŒºÀ¢‚ÇÇ = vec((‚Ñí.I - s_to_s‚ÇÅ) \ (s_s_to_s‚ÇÇ * vec(Œ£·∂ª‚ÇÅ) / 2 + (v_v_to_s‚ÇÇ + e_e_to_s‚ÇÇ * vec(‚Ñí.I(n·µâ))) / 2))
    Œº ∏‚ÇÇ  = SS_and_pars[1:ùìÇ.timings.nVars] + sÃÇ_to_y‚ÇÇ * ŒºÀ¢‚Å∫‚ÇÇ + yv‚ÇÇ

    if !covariance
        return Œº ∏‚ÇÇ, ŒîŒºÀ¢‚ÇÇ, Œ£ ∏‚ÇÅ, Œ£·∂ª‚ÇÅ, SS_and_pars, ùêí‚ÇÅ, ‚àá‚ÇÅ, ùêí‚ÇÇ, ‚àá‚ÇÇ
    end

    # Covariance
    Œì‚ÇÇ = [ ‚Ñí.I(n·µâ)             zeros(n·µâ, n·µâ^2 + n·µâ * nÀ¢)
            zeros(n·µâ^2, n·µâ)    reshape(e‚Å¥, n·µâ^2, n·µâ^2) - vec(‚Ñí.I(n·µâ)) * vec(‚Ñí.I(n·µâ))'     zeros(n·µâ^2, n·µâ * nÀ¢)
            zeros(nÀ¢ * n·µâ, n·µâ + n·µâ^2)    ‚Ñí.kron(Œ£·∂ª‚ÇÅ, ‚Ñí.I(n·µâ))]

    C = eÃÇ_to_sÃÇ‚ÇÇ * Œì‚ÇÇ * eÃÇ_to_sÃÇ‚ÇÇ'

    r1,c1,v1 = findnz(sparse(sÃÇ_to_sÃÇ‚ÇÇ))

    coordinates = Tuple{Vector{Int}, Vector{Int}}[]
    push!(coordinates,(r1,c1))

    dimensions = Tuple{Int, Int}[]
    push!(dimensions,size(sÃÇ_to_sÃÇ‚ÇÇ))
    push!(dimensions,size(C))
    
    values = vcat(v1, vec(collect(-C)))

    Œ£·∂ª‚ÇÇ, info = solve_matrix_equation_AD(values, coords = coordinates, dims = dimensions, solver = :doubling)
    
    Œ£ ∏‚ÇÇ = sÃÇ_to_y‚ÇÇ * Œ£·∂ª‚ÇÇ * sÃÇ_to_y‚ÇÇ' + eÃÇ_to_y‚ÇÇ * Œì‚ÇÇ * eÃÇ_to_y‚ÇÇ'

    autocorr_tmp = sÃÇ_to_sÃÇ‚ÇÇ * Œ£·∂ª‚ÇÇ * sÃÇ_to_y‚ÇÇ' + eÃÇ_to_sÃÇ‚ÇÇ * Œì‚ÇÇ * eÃÇ_to_y‚ÇÇ'

    return Œ£ ∏‚ÇÇ, Œ£·∂ª‚ÇÇ, Œº ∏‚ÇÇ, ŒîŒºÀ¢‚ÇÇ, autocorr_tmp, sÃÇ_to_sÃÇ‚ÇÇ, sÃÇ_to_y‚ÇÇ, Œ£ ∏‚ÇÅ, Œ£·∂ª‚ÇÅ, SS_and_pars, ùêí‚ÇÅ, ‚àá‚ÇÅ, ùêí‚ÇÇ, ‚àá‚ÇÇ
end






function calculate_third_order_moments(parameters::Vector{T}, 
                                            observables::Union{Symbol_input,String_input},
                                            ùìÇ::‚Ñ≥; 
                                            covariance::Bool = true,
                                            autocorrelation::Bool = false,
                                            autocorrelation_periods::U = 1:5,
                                            verbose::Bool = false, 
                                            dependencies_tol::AbstractFloat = 1e-12, 
                                            tol::AbstractFloat = eps()) where {U, T <: Real}

    Œ£ ∏‚ÇÇ, Œ£·∂ª‚ÇÇ, Œº ∏‚ÇÇ, ŒîŒºÀ¢‚ÇÇ, autocorr_tmp, sÃÇ_to_sÃÇ‚ÇÇ, sÃÇ_to_y‚ÇÇ, Œ£ ∏‚ÇÅ, Œ£·∂ª‚ÇÅ, SS_and_pars, ùêí‚ÇÅ, ‚àá‚ÇÅ, ùêí‚ÇÇ, ‚àá‚ÇÇ = calculate_second_order_moments(parameters, ùìÇ, verbose = verbose)

    if !covariance && !autocorrelation
        return Œº ∏‚ÇÇ, ŒîŒºÀ¢‚ÇÇ, Œ£ ∏‚ÇÅ, Œ£·∂ª‚ÇÅ, SS_and_pars, ùêí‚ÇÅ, ‚àá‚ÇÅ, ùêí‚ÇÇ, ‚àá‚ÇÇ
    end

    ‚àá‚ÇÉ = calculate_third_order_derivatives(parameters, SS_and_pars, ùìÇ)

    ùêí‚ÇÉ, solved3 = calculate_third_order_solution(‚àá‚ÇÅ, ‚àá‚ÇÇ, ‚àá‚ÇÉ, ùêí‚ÇÅ, ùêí‚ÇÇ, 
                                                ùìÇ.solution.perturbation.second_order_auxilliary_matrices, 
                                                ùìÇ.solution.perturbation.third_order_auxilliary_matrices; T = ùìÇ.timings, tol = tol)

    orders = determine_efficient_order(ùêí‚ÇÅ, ùìÇ.timings, observables, tol = dependencies_tol)

    n·µâ = ùìÇ.timings.nExo

    # precalc second order
    ## covariance
    E_e‚Å¥ = zeros(n·µâ * (n·µâ + 1)√∑2 * (n·µâ + 2)√∑3 * (n·µâ + 3)√∑4)

    quadrup = multiplicate(n·µâ, 4)

    comb‚Å¥ = reduce(vcat, generateSumVectors(n·µâ, 4))

    comb‚Å¥ = comb‚Å¥ isa Int64 ? reshape([comb‚Å¥],1,1) : comb‚Å¥

    for j = 1:size(comb‚Å¥,1)
        E_e‚Å¥[j] = product_moments(‚Ñí.I(n·µâ), 1:n·µâ, comb‚Å¥[j,:])
    end

    e‚Å¥ = quadrup * E_e‚Å¥

    # precalc third order
    sextup = multiplicate(n·µâ, 6)
    E_e‚Å∂ = zeros(n·µâ * (n·µâ + 1)√∑2 * (n·µâ + 2)√∑3 * (n·µâ + 3)√∑4 * (n·µâ + 4)√∑5 * (n·µâ + 5)√∑6)

    comb‚Å∂   = reduce(vcat, generateSumVectors(n·µâ, 6))

    comb‚Å∂ = comb‚Å∂ isa Int64 ? reshape([comb‚Å∂],1,1) : comb‚Å∂

    for j = 1:size(comb‚Å∂,1)
        E_e‚Å∂[j] = product_moments(‚Ñí.I(n·µâ), 1:n·µâ, comb‚Å∂[j,:])
    end

    e‚Å∂ = sextup * E_e‚Å∂

    Œ£ ∏‚ÇÉ = zeros(T, size(Œ£ ∏‚ÇÇ))

    if autocorrelation
        autocorr = zeros(T, size(Œ£ ∏‚ÇÇ,1), length(autocorrelation_periods))
    end

    # Threads.@threads for ords in orders 
    for ords in orders 
        variance_observable, dependencies_all_vars = ords

        sort!(variance_observable)

        sort!(dependencies_all_vars)

        dependencies = intersect(ùìÇ.timings.past_not_future_and_mixed, dependencies_all_vars)

        obs_in_y = indexin(variance_observable, ùìÇ.timings.var)

        dependencies_in_states_idx = indexin(dependencies, ùìÇ.timings.past_not_future_and_mixed)

        dependencies_in_var_idx = Int.(indexin(dependencies, ùìÇ.timings.var))

        nÀ¢ = length(dependencies)

        iÀ¢ = dependencies_in_var_idx

        Œ£ÃÇ·∂ª‚ÇÅ = Œ£ ∏‚ÇÅ[iÀ¢, iÀ¢]

        dependencies_extended_idx = vcat(dependencies_in_states_idx, 
                dependencies_in_states_idx .+ ùìÇ.timings.nPast_not_future_and_mixed, 
                findall(‚Ñí.kron(ùìÇ.timings.past_not_future_and_mixed .‚àà (intersect(ùìÇ.timings.past_not_future_and_mixed,dependencies),), ùìÇ.timings.past_not_future_and_mixed .‚àà (intersect(ùìÇ.timings.past_not_future_and_mixed,dependencies),))) .+ 2*ùìÇ.timings.nPast_not_future_and_mixed)
        
        Œ£ÃÇ·∂ª‚ÇÇ = Œ£·∂ª‚ÇÇ[dependencies_extended_idx, dependencies_extended_idx]
        
        ŒîÃÇŒºÀ¢‚ÇÇ = ŒîŒºÀ¢‚ÇÇ[dependencies_in_states_idx]

        s_in_s‚Å∫ = BitVector(vcat(ùìÇ.timings.past_not_future_and_mixed .‚àà (dependencies,), zeros(Bool, n·µâ + 1)))
        e_in_s‚Å∫ = BitVector(vcat(zeros(Bool, ùìÇ.timings.nPast_not_future_and_mixed + 1), ones(Bool, n·µâ)))
        v_in_s‚Å∫ = BitVector(vcat(zeros(Bool, ùìÇ.timings.nPast_not_future_and_mixed), 1, zeros(Bool, n·µâ)))

        # precalc second order
        ## mean
        I_plus_s_s = sparse(reshape(‚Ñí.kron(vec(‚Ñí.I(nÀ¢)), ‚Ñí.I(nÀ¢)), nÀ¢^2, nÀ¢^2) + ‚Ñí.I)

        e_es = sparse(reshape(‚Ñí.kron(vec(‚Ñí.I(n·µâ)), ‚Ñí.I(n·µâ*nÀ¢)), nÀ¢*n·µâ^2, nÀ¢*n·µâ^2))
        e_ss = sparse(reshape(‚Ñí.kron(vec(‚Ñí.I(n·µâ)), ‚Ñí.I(nÀ¢^2)), n·µâ*nÀ¢^2, n·µâ*nÀ¢^2))
        ss_s = sparse(reshape(‚Ñí.kron(vec(‚Ñí.I(nÀ¢^2)), ‚Ñí.I(nÀ¢)), nÀ¢^3, nÀ¢^3))
        s_s  = sparse(reshape(‚Ñí.kron(vec(‚Ñí.I(nÀ¢)), ‚Ñí.I(nÀ¢)), nÀ¢^2, nÀ¢^2))

        # first order
        s_to_y‚ÇÅ = ùêí‚ÇÅ[obs_in_y,:][:,dependencies_in_states_idx]
        e_to_y‚ÇÅ = ùêí‚ÇÅ[obs_in_y,:][:, (ùìÇ.timings.nPast_not_future_and_mixed + 1):end]
        
        s_to_s‚ÇÅ = ùêí‚ÇÅ[iÀ¢, dependencies_in_states_idx]
        e_to_s‚ÇÅ = ùêí‚ÇÅ[iÀ¢, (ùìÇ.timings.nPast_not_future_and_mixed + 1):end]

        # second order
        kron_s_s = ‚Ñí.kron(s_in_s‚Å∫, s_in_s‚Å∫)
        kron_e_e = ‚Ñí.kron(e_in_s‚Å∫, e_in_s‚Å∫)
        kron_v_v = ‚Ñí.kron(v_in_s‚Å∫, v_in_s‚Å∫)
        kron_s_e = ‚Ñí.kron(s_in_s‚Å∫, e_in_s‚Å∫)

        s_s_to_y‚ÇÇ = ùêí‚ÇÇ[obs_in_y,:][:, kron_s_s]
        e_e_to_y‚ÇÇ = ùêí‚ÇÇ[obs_in_y,:][:, kron_e_e]
        s_e_to_y‚ÇÇ = ùêí‚ÇÇ[obs_in_y,:][:, kron_s_e]

        s_s_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_s_s] |> collect
        e_e_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_e_e]
        v_v_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_v_v] |> collect
        s_e_to_s‚ÇÇ = ùêí‚ÇÇ[iÀ¢, kron_s_e]

        s_to_s‚ÇÅ_by_s_to_s‚ÇÅ = ‚Ñí.kron(s_to_s‚ÇÅ, s_to_s‚ÇÅ) |> collect
        e_to_s‚ÇÅ_by_e_to_s‚ÇÅ = ‚Ñí.kron(e_to_s‚ÇÅ, e_to_s‚ÇÅ)
        s_to_s‚ÇÅ_by_e_to_s‚ÇÅ = ‚Ñí.kron(s_to_s‚ÇÅ, e_to_s‚ÇÅ)

        # third order
        kron_s_v = ‚Ñí.kron(s_in_s‚Å∫, v_in_s‚Å∫)
        kron_e_v = ‚Ñí.kron(e_in_s‚Å∫, v_in_s‚Å∫)

        s_s_s_to_y‚ÇÉ = ùêí‚ÇÉ[obs_in_y,:][:, ‚Ñí.kron(kron_s_s, s_in_s‚Å∫)]
        s_s_e_to_y‚ÇÉ = ùêí‚ÇÉ[obs_in_y,:][:, ‚Ñí.kron(kron_s_s, e_in_s‚Å∫)]
        s_e_e_to_y‚ÇÉ = ùêí‚ÇÉ[obs_in_y,:][:, ‚Ñí.kron(kron_s_e, e_in_s‚Å∫)]
        e_e_e_to_y‚ÇÉ = ùêí‚ÇÉ[obs_in_y,:][:, ‚Ñí.kron(kron_e_e, e_in_s‚Å∫)]
        s_v_v_to_y‚ÇÉ = ùêí‚ÇÉ[obs_in_y,:][:, ‚Ñí.kron(kron_s_v, v_in_s‚Å∫)]
        e_v_v_to_y‚ÇÉ = ùêí‚ÇÉ[obs_in_y,:][:, ‚Ñí.kron(kron_e_v, v_in_s‚Å∫)]

        s_s_s_to_s‚ÇÉ = ùêí‚ÇÉ[iÀ¢, ‚Ñí.kron(kron_s_s, s_in_s‚Å∫)]
        s_s_e_to_s‚ÇÉ = ùêí‚ÇÉ[iÀ¢, ‚Ñí.kron(kron_s_s, e_in_s‚Å∫)]
        s_e_e_to_s‚ÇÉ = ùêí‚ÇÉ[iÀ¢, ‚Ñí.kron(kron_s_e, e_in_s‚Å∫)]
        e_e_e_to_s‚ÇÉ = ùêí‚ÇÉ[iÀ¢, ‚Ñí.kron(kron_e_e, e_in_s‚Å∫)]
        s_v_v_to_s‚ÇÉ = ùêí‚ÇÉ[iÀ¢, ‚Ñí.kron(kron_s_v, v_in_s‚Å∫)]
        e_v_v_to_s‚ÇÉ = ùêí‚ÇÉ[iÀ¢, ‚Ñí.kron(kron_e_v, v_in_s‚Å∫)]

        # Set up pruned state transition matrices
        sÃÇ_to_sÃÇ‚ÇÉ = [  s_to_s‚ÇÅ                zeros(nÀ¢, 2*nÀ¢ + 2*nÀ¢^2 + nÀ¢^3)
                                            zeros(nÀ¢, nÀ¢) s_to_s‚ÇÅ   s_s_to_s‚ÇÇ / 2   zeros(nÀ¢, nÀ¢ + nÀ¢^2 + nÀ¢^3)
                                            zeros(nÀ¢^2, 2 * nÀ¢)               s_to_s‚ÇÅ_by_s_to_s‚ÇÅ  zeros(nÀ¢^2, nÀ¢ + nÀ¢^2 + nÀ¢^3)
                                            s_v_v_to_s‚ÇÉ / 2    zeros(nÀ¢, nÀ¢ + nÀ¢^2)      s_to_s‚ÇÅ       s_s_to_s‚ÇÇ    s_s_s_to_s‚ÇÉ / 6
                                            ‚Ñí.kron(s_to_s‚ÇÅ,v_v_to_s‚ÇÇ / 2)    zeros(nÀ¢^2, 2*nÀ¢ + nÀ¢^2)     s_to_s‚ÇÅ_by_s_to_s‚ÇÅ  ‚Ñí.kron(s_to_s‚ÇÅ,s_s_to_s‚ÇÇ / 2)    
                                            zeros(nÀ¢^3, 3*nÀ¢ + 2*nÀ¢^2)   ‚Ñí.kron(s_to_s‚ÇÅ,s_to_s‚ÇÅ_by_s_to_s‚ÇÅ)]

        eÃÇ_to_sÃÇ‚ÇÉ = [ e_to_s‚ÇÅ   zeros(nÀ¢,n·µâ^2 + 2*n·µâ * nÀ¢ + n·µâ * nÀ¢^2 + n·µâ^2 * nÀ¢ + n·µâ^3)
                                        zeros(nÀ¢,n·µâ)  e_e_to_s‚ÇÇ / 2   s_e_to_s‚ÇÇ   zeros(nÀ¢,n·µâ * nÀ¢ + n·µâ * nÀ¢^2 + n·µâ^2 * nÀ¢ + n·µâ^3)
                                        zeros(nÀ¢^2,n·µâ)  e_to_s‚ÇÅ_by_e_to_s‚ÇÅ  I_plus_s_s * s_to_s‚ÇÅ_by_e_to_s‚ÇÅ  zeros(nÀ¢^2, n·µâ * nÀ¢ + n·µâ * nÀ¢^2 + n·µâ^2 * nÀ¢ + n·µâ^3)
                                        e_v_v_to_s‚ÇÉ / 2    zeros(nÀ¢,n·µâ^2 + n·µâ * nÀ¢)  s_e_to_s‚ÇÇ    s_s_e_to_s‚ÇÉ / 2    s_e_e_to_s‚ÇÉ / 2    e_e_e_to_s‚ÇÉ / 6
                                        ‚Ñí.kron(e_to_s‚ÇÅ, v_v_to_s‚ÇÇ / 2)    zeros(nÀ¢^2, n·µâ^2 + n·µâ * nÀ¢)      s_s * s_to_s‚ÇÅ_by_e_to_s‚ÇÅ    ‚Ñí.kron(s_to_s‚ÇÅ, s_e_to_s‚ÇÇ) + s_s * ‚Ñí.kron(s_s_to_s‚ÇÇ / 2, e_to_s‚ÇÅ)  ‚Ñí.kron(s_to_s‚ÇÅ, e_e_to_s‚ÇÇ / 2) + s_s * ‚Ñí.kron(s_e_to_s‚ÇÇ, e_to_s‚ÇÅ)  ‚Ñí.kron(e_to_s‚ÇÅ, e_e_to_s‚ÇÇ / 2)
                                        zeros(nÀ¢^3, n·µâ + n·µâ^2 + 2*n·µâ * nÀ¢) ‚Ñí.kron(s_to_s‚ÇÅ_by_s_to_s‚ÇÅ,e_to_s‚ÇÅ) + ‚Ñí.kron(s_to_s‚ÇÅ, s_s * s_to_s‚ÇÅ_by_e_to_s‚ÇÅ) + ‚Ñí.kron(e_to_s‚ÇÅ,s_to_s‚ÇÅ_by_s_to_s‚ÇÅ) * e_ss   ‚Ñí.kron(s_to_s‚ÇÅ_by_e_to_s‚ÇÅ,e_to_s‚ÇÅ) + ‚Ñí.kron(e_to_s‚ÇÅ,s_to_s‚ÇÅ_by_e_to_s‚ÇÅ) * e_es + ‚Ñí.kron(e_to_s‚ÇÅ, s_s * s_to_s‚ÇÅ_by_e_to_s‚ÇÅ) * e_es  ‚Ñí.kron(e_to_s‚ÇÅ,e_to_s‚ÇÅ_by_e_to_s‚ÇÅ)]

        sÃÇ_to_y‚ÇÉ = [s_to_y‚ÇÅ + s_v_v_to_y‚ÇÉ / 2  s_to_y‚ÇÅ  s_s_to_y‚ÇÇ / 2   s_to_y‚ÇÅ    s_s_to_y‚ÇÇ     s_s_s_to_y‚ÇÉ / 6]

        eÃÇ_to_y‚ÇÉ = [e_to_y‚ÇÅ + e_v_v_to_y‚ÇÉ / 2  e_e_to_y‚ÇÇ / 2  s_e_to_y‚ÇÇ   s_e_to_y‚ÇÇ     s_s_e_to_y‚ÇÉ / 2    s_e_e_to_y‚ÇÉ / 2    e_e_e_to_y‚ÇÉ / 6]

        ŒºÀ¢‚ÇÉŒ¥ŒºÀ¢‚ÇÅ = reshape((‚Ñí.I - s_to_s‚ÇÅ_by_s_to_s‚ÇÅ) \ vec( 
                                    (s_s_to_s‚ÇÇ  * reshape(ss_s * vec(Œ£ÃÇ·∂ª‚ÇÇ[2 * nÀ¢ + 1 : end, nÀ¢ + 1:2*nÀ¢] + vec(Œ£ÃÇ·∂ª‚ÇÅ) * ŒîÃÇŒºÀ¢‚ÇÇ'),nÀ¢^2, nÀ¢) +
                                    s_s_s_to_s‚ÇÉ * reshape(Œ£ÃÇ·∂ª‚ÇÇ[2 * nÀ¢ + 1 : end , 2 * nÀ¢ + 1 : end] + vec(Œ£ÃÇ·∂ª‚ÇÅ) * vec(Œ£ÃÇ·∂ª‚ÇÅ)', nÀ¢^3, nÀ¢) / 6 +
                                    s_e_e_to_s‚ÇÉ * ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÅ, vec(‚Ñí.I(n·µâ))) / 2 +
                                    s_v_v_to_s‚ÇÉ * Œ£ÃÇ·∂ª‚ÇÅ / 2) * s_to_s‚ÇÅ' +
                                    (s_e_to_s‚ÇÇ  * ‚Ñí.kron(ŒîÃÇŒºÀ¢‚ÇÇ,‚Ñí.I(n·µâ)) +
                                    e_e_e_to_s‚ÇÉ * reshape(e‚Å¥, n·µâ^3, n·µâ) / 6 +
                                    s_s_e_to_s‚ÇÉ * ‚Ñí.kron(vec(Œ£ÃÇ·∂ª‚ÇÅ), ‚Ñí.I(n·µâ)) / 2 +
                                    e_v_v_to_s‚ÇÉ * ‚Ñí.I(n·µâ) / 2) * e_to_s‚ÇÅ'
                                    ), nÀ¢, nÀ¢)

        Œì‚ÇÉ = [ ‚Ñí.I(n·µâ)             spzeros(n·µâ, n·µâ^2 + n·µâ * nÀ¢)    ‚Ñí.kron(ŒîÃÇŒºÀ¢‚ÇÇ', ‚Ñí.I(n·µâ))  ‚Ñí.kron(vec(Œ£ÃÇ·∂ª‚ÇÅ)', ‚Ñí.I(n·µâ)) spzeros(n·µâ, nÀ¢ * n·µâ^2)    reshape(e‚Å¥, n·µâ, n·µâ^3)
                spzeros(n·µâ^2, n·µâ)    reshape(e‚Å¥, n·µâ^2, n·µâ^2) - vec(‚Ñí.I(n·µâ)) * vec(‚Ñí.I(n·µâ))'     spzeros(n·µâ^2, 2*nÀ¢*n·µâ + nÀ¢^2*n·µâ + nÀ¢*n·µâ^2 + n·µâ^3)
                spzeros(nÀ¢ * n·µâ, n·µâ + n·µâ^2)    ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÅ, ‚Ñí.I(n·µâ))   spzeros(nÀ¢ * n·µâ, nÀ¢*n·µâ + nÀ¢^2*n·µâ + nÀ¢*n·µâ^2 + n·µâ^3)
                ‚Ñí.kron(ŒîÃÇŒºÀ¢‚ÇÇ,‚Ñí.I(n·µâ))    spzeros(n·µâ * nÀ¢, n·µâ^2 + n·µâ * nÀ¢)    ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÇ[nÀ¢ + 1:2*nÀ¢,nÀ¢ + 1:2*nÀ¢] + ŒîÃÇŒºÀ¢‚ÇÇ * ŒîÃÇŒºÀ¢‚ÇÇ',‚Ñí.I(n·µâ)) ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÇ[nÀ¢ + 1:2*nÀ¢,2 * nÀ¢ + 1 : end] + ŒîÃÇŒºÀ¢‚ÇÇ * vec(Œ£ÃÇ·∂ª‚ÇÅ)',‚Ñí.I(n·µâ))   spzeros(n·µâ * nÀ¢, nÀ¢ * n·µâ^2) ‚Ñí.kron(ŒîÃÇŒºÀ¢‚ÇÇ, reshape(e‚Å¥, n·µâ, n·µâ^3))
                ‚Ñí.kron(vec(Œ£ÃÇ·∂ª‚ÇÅ), ‚Ñí.I(n·µâ))  spzeros(n·µâ * nÀ¢^2, n·µâ^2 + n·µâ * nÀ¢)    ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÇ[2 * nÀ¢ + 1 : end, nÀ¢ + 1:2*nÀ¢] + vec(Œ£ÃÇ·∂ª‚ÇÅ) * ŒîÃÇŒºÀ¢‚ÇÇ', ‚Ñí.I(n·µâ))  ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÇ[2 * nÀ¢ + 1 : end, 2 * nÀ¢ + 1 : end] + vec(Œ£ÃÇ·∂ª‚ÇÅ) * vec(Œ£ÃÇ·∂ª‚ÇÅ)', ‚Ñí.I(n·µâ))   spzeros(n·µâ * nÀ¢^2, nÀ¢ * n·µâ^2)  ‚Ñí.kron(vec(Œ£ÃÇ·∂ª‚ÇÅ), reshape(e‚Å¥, n·µâ, n·µâ^3))
                spzeros(nÀ¢*n·µâ^2, n·µâ + n·µâ^2 + 2*n·µâ * nÀ¢ + nÀ¢^2*n·µâ)   ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÅ, reshape(e‚Å¥, n·µâ^2, n·µâ^2))    spzeros(nÀ¢*n·µâ^2,n·µâ^3)
                reshape(e‚Å¥, n·µâ^3, n·µâ)  spzeros(n·µâ^3, n·µâ^2 + n·µâ * nÀ¢)    ‚Ñí.kron(ŒîÃÇŒºÀ¢‚ÇÇ', reshape(e‚Å¥, n·µâ^3, n·µâ))     ‚Ñí.kron(vec(Œ£ÃÇ·∂ª‚ÇÅ)', reshape(e‚Å¥, n·µâ^3, n·µâ))  spzeros(n·µâ^3, nÀ¢*n·µâ^2)     reshape(e‚Å∂, n·µâ^3, n·µâ^3)]


        E·¥∏·∂ª = [ spzeros(n·µâ + n·µâ^2 + 2*n·µâ*nÀ¢ + n·µâ*nÀ¢^2, 3*nÀ¢ + 2*nÀ¢^2 +nÀ¢^3)
                ‚Ñí.kron(Œ£ÃÇ·∂ª‚ÇÅ,vec(‚Ñí.I(n·µâ)))   zeros(nÀ¢*n·µâ^2, nÀ¢ + nÀ¢^2)  ‚Ñí.kron(ŒºÀ¢‚ÇÉŒ¥ŒºÀ¢‚ÇÅ',vec(‚Ñí.I(n·µâ)))    ‚Ñí.kron(reshape(ss_s * vec(Œ£ÃÇ·∂ª‚ÇÇ[nÀ¢ + 1:2*nÀ¢,2 * nÀ¢ + 1 : end] + ŒîÃÇŒºÀ¢‚ÇÇ * vec(Œ£ÃÇ·∂ª‚ÇÅ)'), nÀ¢, nÀ¢^2), vec(‚Ñí.I(n·µâ)))  ‚Ñí.kron(reshape(Œ£ÃÇ·∂ª‚ÇÇ[2 * nÀ¢ + 1 : end, 2 * nÀ¢ + 1 : end] + vec(Œ£ÃÇ·∂ª‚ÇÅ) * vec(Œ£ÃÇ·∂ª‚ÇÅ)', nÀ¢, nÀ¢^3), vec(‚Ñí.I(n·µâ)))
                spzeros(n·µâ^3, 3*nÀ¢ + 2*nÀ¢^2 +nÀ¢^3)]
        
        droptol!(sÃÇ_to_sÃÇ‚ÇÉ, eps())
        droptol!(eÃÇ_to_sÃÇ‚ÇÉ, eps())
        droptol!(E·¥∏·∂ª, eps())
        droptol!(Œì‚ÇÉ, eps())
        
        A = eÃÇ_to_sÃÇ‚ÇÉ * E·¥∏·∂ª * sÃÇ_to_sÃÇ‚ÇÉ'
        droptol!(A, eps())

        C = eÃÇ_to_sÃÇ‚ÇÉ * Œì‚ÇÉ * eÃÇ_to_sÃÇ‚ÇÉ' + A + A'
        droptol!(C, eps())

        r1,c1,v1 = findnz(sÃÇ_to_sÃÇ‚ÇÉ)

        coordinates = Tuple{Vector{Int}, Vector{Int}}[]
        push!(coordinates,(r1,c1))
        
        dimensions = Tuple{Int, Int}[]
        push!(dimensions,size(sÃÇ_to_sÃÇ‚ÇÉ))
        push!(dimensions,size(C))
        
        values = vcat(v1, vec(collect(-C)))

        Œ£·∂ª‚ÇÉ, info = solve_matrix_equation_AD(values, coords = coordinates, dims = dimensions, solver = :doubling)

        Œ£ ∏‚ÇÉtmp = sÃÇ_to_y‚ÇÉ * Œ£·∂ª‚ÇÉ * sÃÇ_to_y‚ÇÉ' + eÃÇ_to_y‚ÇÉ * Œì‚ÇÉ * eÃÇ_to_y‚ÇÉ' + eÃÇ_to_y‚ÇÉ * E·¥∏·∂ª * sÃÇ_to_y‚ÇÉ' + sÃÇ_to_y‚ÇÉ * E·¥∏·∂ª' * eÃÇ_to_y‚ÇÉ'

        for obs in variance_observable
            Œ£ ∏‚ÇÉ[indexin([obs], ùìÇ.timings.var), indexin(variance_observable, ùìÇ.timings.var)] = Œ£ ∏‚ÇÉtmp[indexin([obs], variance_observable), :]
        end

        if autocorrelation
            autocorr_tmp = sÃÇ_to_sÃÇ‚ÇÉ * E·¥∏·∂ª' * eÃÇ_to_y‚ÇÉ' + eÃÇ_to_sÃÇ‚ÇÉ * Œì‚ÇÉ * eÃÇ_to_y‚ÇÉ'

            s_to_s‚ÇÅ‚Å± = zero(s_to_s‚ÇÅ)
            s_to_s‚ÇÅ‚Å± += ‚Ñí.diagm(ones(nÀ¢))

            sÃÇ_to_sÃÇ‚ÇÉ‚Å± = zero(sÃÇ_to_sÃÇ‚ÇÉ)
            sÃÇ_to_sÃÇ‚ÇÉ‚Å± += ‚Ñí.diagm(ones(size(Œ£·∂ª‚ÇÉ,1)))

            Œ£·∂ª‚ÇÉ‚Å± = Œ£·∂ª‚ÇÉ

            for i in autocorrelation_periods
                Œ£·∂ª‚ÇÉ‚Å± .= sÃÇ_to_sÃÇ‚ÇÉ * Œ£·∂ª‚ÇÉ‚Å± + eÃÇ_to_sÃÇ‚ÇÉ * E·¥∏·∂ª
                s_to_s‚ÇÅ‚Å± *= s_to_s‚ÇÅ

                E·¥∏·∂ª = [ spzeros(n·µâ + n·µâ^2 + 2*n·µâ*nÀ¢ + n·µâ*nÀ¢^2, 3*nÀ¢ + 2*nÀ¢^2 +nÀ¢^3)
                ‚Ñí.kron(s_to_s‚ÇÅ‚Å± * Œ£ÃÇ·∂ª‚ÇÅ,vec(‚Ñí.I(n·µâ)))   zeros(nÀ¢*n·µâ^2, nÀ¢ + nÀ¢^2)  ‚Ñí.kron(s_to_s‚ÇÅ‚Å± * ŒºÀ¢‚ÇÉŒ¥ŒºÀ¢‚ÇÅ',vec(‚Ñí.I(n·µâ)))    ‚Ñí.kron(s_to_s‚ÇÅ‚Å± * reshape(ss_s * vec(Œ£ÃÇ·∂ª‚ÇÇ[nÀ¢ + 1:2*nÀ¢,2 * nÀ¢ + 1 : end] + ŒîÃÇŒºÀ¢‚ÇÇ * vec(Œ£ÃÇ·∂ª‚ÇÅ)'), nÀ¢, nÀ¢^2), vec(‚Ñí.I(n·µâ)))  ‚Ñí.kron(s_to_s‚ÇÅ‚Å± * reshape(Œ£ÃÇ·∂ª‚ÇÇ[2 * nÀ¢ + 1 : end, 2 * nÀ¢ + 1 : end] + vec(Œ£ÃÇ·∂ª‚ÇÅ) * vec(Œ£ÃÇ·∂ª‚ÇÅ)', nÀ¢, nÀ¢^3), vec(‚Ñí.I(n·µâ)))
                spzeros(n·µâ^3, 3*nÀ¢ + 2*nÀ¢^2 +nÀ¢^3)]

                for obs in variance_observable
                    autocorr[indexin([obs], ùìÇ.timings.var), i] .= (‚Ñí.diag(sÃÇ_to_y‚ÇÉ * Œ£·∂ª‚ÇÉ‚Å± * sÃÇ_to_y‚ÇÉ' + sÃÇ_to_y‚ÇÉ * sÃÇ_to_sÃÇ‚ÇÉ‚Å± * autocorr_tmp + eÃÇ_to_y‚ÇÉ * E·¥∏·∂ª * sÃÇ_to_y‚ÇÉ') ./ ‚Ñí.diag(Œ£ ∏‚ÇÉtmp))[indexin([obs], variance_observable)]
                end

                sÃÇ_to_sÃÇ‚ÇÉ‚Å± *= sÃÇ_to_sÃÇ‚ÇÉ
            end

        end
    end

    if autocorrelation
        return Œ£ ∏‚ÇÉ, Œº ∏‚ÇÇ, autocorr, SS_and_pars
    else
        return Œ£ ∏‚ÇÉ, Œº ∏‚ÇÇ, SS_and_pars
    end

end





function calculate_kalman_filter_loglikelihood(ùìÇ::‚Ñ≥, data::AbstractArray{Float64}, observables::Vector{Symbol}; parameters = nothing, verbose::Bool = false, tol::AbstractFloat = eps())
    @assert length(observables) == size(data)[1] "Data columns and number of observables are not identical. Make sure the data contains only the selected observables."
    @assert length(observables) <= ùìÇ.timings.nExo "Cannot estimate model with more observables than exogenous shocks. Have at least as many shocks as observable variables."

    @ignore_derivatives sort!(observables)

    @ignore_derivatives solve!(ùìÇ, verbose = verbose)

    if isnothing(parameters)
        parameters = ùìÇ.parameter_values
    else
        ub = @ignore_derivatives fill(1e12+rand(),length(ùìÇ.parameters) + length(ùìÇ.‚ûï_vars))
        lb = @ignore_derivatives -ub

        for (i,v) in enumerate(ùìÇ.bounded_vars)
            if v ‚àà ùìÇ.parameters
                @ignore_derivatives lb[i] = ùìÇ.lower_bounds[i]
                @ignore_derivatives ub[i] = ùìÇ.upper_bounds[i]
            end
        end

        if min(max(parameters,lb),ub) != parameters 
            return -Inf
        end
    end

    SS_and_pars, (solution_error, iters) = ùìÇ.SS_solve_func(parameters, ùìÇ, verbose, false, ùìÇ.solver_parameters)
    
    if solution_error > tol || isnan(solution_error)
        return -Inf
    end

    NSSS_labels = @ignore_derivatives [sort(union(ùìÇ.exo_present,ùìÇ.var))...,ùìÇ.calibration_equations_parameters...]

    obs_indices = @ignore_derivatives indexin(observables,NSSS_labels)

    data_in_deviations = collect(data(observables)) .- SS_and_pars[obs_indices]

	‚àá‚ÇÅ = calculate_jacobian(parameters, SS_and_pars, ùìÇ) |> Matrix

<<<<<<< HEAD
    sol, success = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
=======
    sol, solved = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)

    if !solved
        return -Inf
    end
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806

    observables_and_states = @ignore_derivatives sort(union(ùìÇ.timings.past_not_future_and_mixed_idx,indexin(observables,sort(union(ùìÇ.aux,ùìÇ.var,ùìÇ.exo_present)))))

    A = @views sol[observables_and_states,1:ùìÇ.timings.nPast_not_future_and_mixed] * ‚Ñí.diagm(ones(length(observables_and_states)))[@ignore_derivatives(indexin(ùìÇ.timings.past_not_future_and_mixed_idx,observables_and_states)),:]
    B = @views sol[observables_and_states,ùìÇ.timings.nPast_not_future_and_mixed+1:end]

    C = @views ‚Ñí.diagm(ones(length(observables_and_states)))[@ignore_derivatives(indexin(sort(indexin(observables,sort(union(ùìÇ.aux,ùìÇ.var,ùìÇ.exo_present)))),observables_and_states)),:]

    ùêÅ = B * B'

    # Gaussian Prior
    coordinates = Tuple{Vector{Int}, Vector{Int}}[]
    
    dimensions = [size(A),size(ùêÅ)]
    
    values = vcat(vec(A), vec(collect(-ùêÅ)))

    P, _ = solve_matrix_equation_AD(values, coords = coordinates, dims = dimensions, solver = :doubling)
    # P = reshape((‚Ñí.I - ‚Ñí.kron(A, A)) \ reshape(ùêÅ, prod(size(A)), 1), size(A))

    u = zeros(length(observables_and_states))
    # u = SS_and_pars[sort(union(ùìÇ.timings.past_not_future_and_mixed,observables))] |> collect
    z = C * u
    
    loglik = 0.0

    for t in 1:size(data)[2]
        v = data_in_deviations[:,t] - z

        F = C * P * C'

        # F = (F + F') / 2

        # loglik += log(max(eps(),‚Ñí.det(F))) + v' * ‚Ñí.pinv(F) * v
        # K = P * C' * ‚Ñí.pinv(F)

        # loglik += log(max(eps(),‚Ñí.det(F))) + v' / F  * v
        Fdet = ‚Ñí.det(F)

        if Fdet < eps() return -Inf end

        FÃÑ = ‚Ñí.lu(F, check = false)

        if !‚Ñí.issuccess(FÃÑ) return -Inf end

        invF = inv(FÃÑ)

        loglik += log(Fdet) + v' * invF  * v
        
        K = P * C' * invF

        P = A * (P - K * C * P) * A' + ùêÅ

        u = A * (u + K * v)
        
        z = C * u 
    end

    return -(loglik + length(data) * log(2 * 3.141592653589793)) / 2 # otherwise conflicts with model parameters assignment
end


function filter_and_smooth(ùìÇ::‚Ñ≥, data_in_deviations::AbstractArray{Float64}, observables::Vector{Symbol}; verbose::Bool = false, tol::AbstractFloat = eps())
    # Based on Durbin and Koopman (2012)
    # https://jrnold.github.io/ssmodels-in-stan/filtering-and-smoothing.html#smoothing

    @assert length(observables) == size(data_in_deviations)[1] "Data columns and number of observables are not identical. Make sure the data contains only the selected observables."
    @assert length(observables) <= ùìÇ.timings.nExo "Cannot estimate model with more observables than exogenous shocks. Have at least as many shocks as observable variables."

    sort!(observables)

    solve!(ùìÇ, verbose = verbose)

    parameters = ùìÇ.parameter_values

    SS_and_pars, (solution_error, iters) = ùìÇ.SS_solve_func(parameters, ùìÇ, verbose, false, ùìÇ.solver_parameters)
    
    @assert solution_error < tol "Could not solve non stochastic steady state." 

	‚àá‚ÇÅ = calculate_jacobian(parameters, SS_and_pars, ùìÇ) |> Matrix

<<<<<<< HEAD
    sol, success = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
=======
    sol, solved = calculate_first_order_solution(‚àá‚ÇÅ; T = ùìÇ.timings)
>>>>>>> e619aaec65a28c7a90a27a598bf86a89931ec806

    A = @views sol[:,1:ùìÇ.timings.nPast_not_future_and_mixed] * ‚Ñí.diagm(ones(ùìÇ.timings.nVars))[ùìÇ.timings.past_not_future_and_mixed_idx,:]

    B = @views sol[:,ùìÇ.timings.nPast_not_future_and_mixed+1:end]

    C = @views ‚Ñí.diagm(ones(ùìÇ.timings.nVars))[sort(indexin(observables,sort(union(ùìÇ.aux,ùìÇ.var,ùìÇ.exo_present)))),:]

    ùêÅ = B * B'

    PÃÑ = calculate_covariance(ùìÇ.parameter_values, ùìÇ, verbose = verbose)[1]

    n_obs = size(data_in_deviations,2)

    v = zeros(size(C,1), n_obs)
    Œº = zeros(size(A,1), n_obs+1) # filtered_states
    P = zeros(size(A,1), size(A,1), n_obs+1) # filtered_covariances
    œÉ = zeros(size(A,1), n_obs) # filtered_standard_deviations
    iF= zeros(size(C,1), size(C,1), n_obs)
    L = zeros(size(A,1), size(A,1), n_obs)
    œµ = zeros(size(B,2), n_obs) # filtered_shocks

    P[:, :, 1] = PÃÑ

    # Kalman Filter
    for t in axes(data_in_deviations,2)
        v[:, t]     .= data_in_deviations[:, t] - C * Œº[:, t]
        iF[:, :, t] .= inv(C * P[:, :, t] * C')
        PCiF         = P[:, :, t] * C' * iF[:, :, t]
        L[:, :, t]  .= A - A * PCiF * C
        P[:, :, t+1].= A * P[:, :, t] * L[:, :, t]' + ùêÅ
        œÉ[:, t]     .= sqrt.(abs.(‚Ñí.diag(P[:, :, t+1]))) # small numerica errors in this computation
        Œº[:, t+1]   .= A * (Œº[:, t] + PCiF * v[:, t])
        œµ[:, t]     .= B' * C' * iF[:, :, t] * v[:, t]
    end


    # Historical shock decompositionm (filter)
    filter_decomposition = zeros(size(A,1), size(B,2)+2, n_obs)

    filter_decomposition[:,end,:] .= Œº[:, 2:end]
    filter_decomposition[:,1:end-2,1] .= B .* repeat(œµ[:, 1]', size(A,1))
    filter_decomposition[:,end-1,1] .= filter_decomposition[:,end,1] - sum(filter_decomposition[:,1:end-2,1],dims=2)

    for i in 2:size(data_in_deviations,2)
        filter_decomposition[:,1:end-2,i] .= A * filter_decomposition[:,1:end-2,i-1]
        filter_decomposition[:,1:end-2,i] .+= B .* repeat(œµ[:, i]', size(A,1))
        filter_decomposition[:,end-1,i] .= filter_decomposition[:,end,i] - sum(filter_decomposition[:,1:end-2,i],dims=2)
    end
    
    ŒºÃÑ = zeros(size(A,1), n_obs) # smoothed_states
    œÉÃÑ = zeros(size(A,1), n_obs) # smoothed_standard_deviations
    œµÃÑ = zeros(size(B,2), n_obs) # smoothed_shocks

    r = zeros(size(A,1))
    N = zeros(size(A,1), size(A,1))

    # Kalman Smoother
    for t in n_obs:-1:1
        r       .= C' * iF[:, :, t] * v[:, t] + L[:, :, t]' * r
        ŒºÃÑ[:, t] .= Œº[:, t] + P[:, :, t] * r
        N       .= C' * iF[:, :, t] * C + L[:, :, t]' * N * L[:, :, t]
        œÉÃÑ[:, t] .= sqrt.(abs.(‚Ñí.diag(P[:, :, t] - P[:, :, t] * N * P[:, :, t]'))) # can go negative
        œµÃÑ[:, t] .= B' * r
    end

    # Historical shock decompositionm (smoother)
    smooth_decomposition = zeros(size(A,1), size(B,2)+2, n_obs)

    smooth_decomposition[:,end,:] .= ŒºÃÑ
    smooth_decomposition[:,1:end-2,1] .= B .* repeat(œµÃÑ[:, 1]', size(A,1))
    smooth_decomposition[:,end-1,1] .= smooth_decomposition[:,end,1] - sum(smooth_decomposition[:,1:end-2,1],dims=2)

    for i in 2:size(data_in_deviations,2)
        smooth_decomposition[:,1:end-2,i] .= A * smooth_decomposition[:,1:end-2,i-1]
        smooth_decomposition[:,1:end-2,i] .+= B .* repeat(œµÃÑ[:, i]', size(A,1))
        smooth_decomposition[:,end-1,i] .= smooth_decomposition[:,end,i] - sum(smooth_decomposition[:,1:end-2,i],dims=2)
    end

    return ŒºÃÑ, œÉÃÑ, œµÃÑ, smooth_decomposition, Œº[:, 2:end], œÉ, œµ, filter_decomposition
end



@setup_workload begin
    # Putting some things in `setup` can reduce the size of the
    # precompile file and potentially make loading faster.
    @model FS2000 precompile = true begin
        dA[0] = exp(gam + z_e_a  *  e_a[x])
        log(m[0]) = (1 - rho) * log(mst)  +  rho * log(m[-1]) + z_e_m  *  e_m[x]
        - P[0] / (c[1] * P[1] * m[0]) + bet * P[1] * (alp * exp( - alp * (gam + log(e[1]))) * k[0] ^ (alp - 1) * n[1] ^ (1 - alp) + (1 - del) * exp( - (gam + log(e[1])))) / (c[2] * P[2] * m[1])=0
        W[0] = l[0] / n[0]
        - (psi / (1 - psi)) * (c[0] * P[0] / (1 - n[0])) + l[0] / n[0] = 0
        R[0] = P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ ( - alp) / W[0]
        1 / (c[0] * P[0]) - bet * P[0] * (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) / (m[0] * l[0] * c[1] * P[1]) = 0
        c[0] + k[0] = exp( - alp * (gam + z_e_a  *  e_a[x])) * k[-1] ^ alp * n[0] ^ (1 - alp) + (1 - del) * exp( - (gam + z_e_a  *  e_a[x])) * k[-1]
        P[0] * c[0] = m[0]
        m[0] - 1 + d[0] = l[0]
        e[0] = exp(z_e_a  *  e_a[x])
        y[0] = k[-1] ^ alp * n[0] ^ (1 - alp) * exp( - alp * (gam + z_e_a  *  e_a[x]))
        gy_obs[0] = dA[0] * y[0] / y[-1]
        gp_obs[0] = (P[0] / P[-1]) * m[-1] / dA[0]
        log_gy_obs[0] = log(gy_obs[0])
        log_gp_obs[0] = log(gp_obs[0])
    end

    @parameters FS2000 silent = true precompile = true begin  
        alp     = 0.356
        bet     = 0.993
        gam     = 0.0085
        mst     = 1.0002
        rho     = 0.129
        psi     = 0.65
        del     = 0.01
        z_e_a   = 0.035449
        z_e_m   = 0.008862
    end
    
    ENV["GKSwstype"] = "nul"

    @compile_workload begin
        # all calls in this block will be precompiled, regardless of whether
        # they belong to your package or not (on Julia 1.8 and higher)
        @model RBC precompile = true begin
            1  /  c[0] = (0.95 /  c[1]) * (Œ± * exp(z[1]) * k[0]^(Œ± - 1) + (1 - Œ¥))
            c[0] + k[0] = (1 - Œ¥) * k[-1] + exp(z[0]) * k[-1]^Œ±
            z[0] = 0.2 * z[-1] + 0.01 * eps_z[x]
        end

        @parameters RBC silent = true precompile = true begin
            Œ¥ = 0.02
            Œ± = 0.5
        end

        get_SS(FS2000)
        get_SS(FS2000, parameters = :alp => 0.36)
        get_solution(FS2000)
        get_solution(FS2000, parameters = :alp => 0.35)
        get_standard_deviation(FS2000)
        get_correlation(FS2000)
        get_autocorrelation(FS2000)
        get_variance_decomposition(FS2000)
        get_conditional_variance_decomposition(FS2000)
        get_irf(FS2000)

        data = simulate(FS2000)[:,:,1]
        observables = [:c,:k]
        calculate_kalman_filter_loglikelihood(FS2000, data(observables), observables)
        get_mean(FS2000, silent = true)
        # get_SSS(FS2000, silent = true)
        # get_SSS(FS2000, algorithm = :third_order, silent = true)

        # import Plots, StatsPlots
        # plot_irf(FS2000)
        # plot_solution(FS2000,:k) # fix warning when there is no sensitivity and all values are the same. triggers: no strict ticks found...
        # plot_conditional_variance_decomposition(FS2000)
    end
end

end
